<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n-title="pageTitle.main">–ì–ª–∞–≤–Ω–∞—è | Youvi</title>
    <!-- Load header CSS FIRST to prevent layout shifts -->
    <link rel="stylesheet" href="youvi/header/youvi-header.css">
    <script>
        (function() {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            
            var htmlClasses = [];
            if (theme === 'dark') htmlClasses.push('dark-theme');
            else if (theme === 'skeuo') htmlClasses.push('skeuo-theme');
            if (sidebar === 'true') htmlClasses.push('sidebar-collapsed');
            if (htmlClasses.length) document.documentElement.className = htmlClasses.join(' ');
        })();
    </script>
    <style>

        
        :root {
            --latest-cols: 6;
            --playlist-cols: 6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            width: 100%;
        }

        body {
            font-family: Arial, sans-serif;
            background: #fff;
            color: #111;
            max-width: 100vw;
        }

        .top-nav {
            background: #d94b88;
            border-bottom: 1px solid #c2185b;
            padding: 4px 0;
        }

        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
            padding: 0 20px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .top-nav a {
            color: #fff;
            text-decoration: none;
            font-size: 12px;
            padding: 2px 0;
            transition: color 0.2s;
        }

        .top-nav a:hover {
            color: #ffd6ea;
        }

        .top-nav a.active {
            color: #ffd6ea;
            font-weight: 600;
        }

        .lang-switcher {
            margin-left: auto;
        }
        
        .lang-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }
        
        .lang-select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .lang-select option {
            background: #d94b88;
            color: #fff;
        }
        
        .container,
        .banner-section,
        .tags-section,
        .video-grid,
        .latest-grid,
        .playlists-grid,
        .video-carousel,
        .playlist-section-header,
        .video-carousel-wrapper,
        #topPlaylistsContainer {
            max-width: 100%;
        }

        .sidebar-collapsed .sidebar,
        html.sidebar-collapsed .sidebar,
        body.sidebar-collapsed .sidebar {
            width: 60px !important;
            padding: 10px 8px !important;
            display: block !important; 
            position: sticky !important;
            top: 40px !important; 
            max-height: calc(var(--sidebar-max-height, 100vh) - 75px) !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            z-index: 10 !important;
            background: #f5f5f5 !important;
        }

        .sidebar-collapsed .sidebar-section:has(#sidebarTagsContainer),
        html.sidebar-collapsed .sidebar-section:has(#sidebarTagsContainer) {
            display: none !important;
        }

        body.dark-theme .sidebar-collapsed .sidebar,
        body.dark-theme html.sidebar-collapsed .sidebar,
        html.dark-theme .sidebar-collapsed .sidebar,
        html.dark-theme.sidebar-collapsed .sidebar,
        body.dark-theme.sidebar-collapsed .sidebar {
            background: #111111 !important;
        }

        .sidebar-collapsed .container,
        html.sidebar-collapsed .container {
            padding-left: 20px;
        }

        .sidebar-collapsed .main-content,
        html.sidebar-collapsed .main-content {
            margin-left: 0;
        }
        
        .sidebar-collapsed .content-wrapper,
        html.sidebar-collapsed .content-wrapper {
            max-width: 1500px;
        }
        


        .sidebar-collapsed .sidebar-title,
        html.sidebar-collapsed .sidebar-title {
            display: none !important;
        }

        .sidebar-collapsed .sidebar-item,
        html.sidebar-collapsed .sidebar-item {
            padding: 8px !important;
            padding-left: 5px !important;
            padding-right: 8px !important;
            justify-content: center !important;
            border-left: 3px solid transparent !important;
            border-radius: 4px;
            font-size: 0 !important;
        }

        .sidebar-collapsed .sidebar-item:hover,
        html.sidebar-collapsed .sidebar-item:hover {
            background: rgba(255, 105, 180, 0.1);
        }

        .sidebar-collapsed .sidebar-item.active,
        html.sidebar-collapsed .sidebar-item.active {
            background: rgba(255, 105, 180, 0.15);
        }

        .sidebar-collapsed .sidebar-item svg,
        .sidebar-collapsed .sidebar-item img,
        html.sidebar-collapsed .sidebar-item svg,
        html.sidebar-collapsed .sidebar-item img {
            margin: 0 !important;
            width: 20px !important;
            height: 20px !important;
            font-size: 16px !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item {
            justify-content: center !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item span,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item span {
            display: none !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item div,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item div {
            margin: 0 !important;
        }

        .sidebar-collapsed .library-item,
        .sidebar-collapsed .nav-item,
        html.sidebar-collapsed .library-item,
        html.sidebar-collapsed .nav-item {
            justify-content: center !important;
            gap: 0 !important;
        }

        .sidebar-collapsed .library-item span,
        .sidebar-collapsed .nav-item span,
        html.sidebar-collapsed .library-item span,
        html.sidebar-collapsed .nav-item span {
            display: none !important;
        }

        .sidebar-collapsed .library-item svg,
        .sidebar-collapsed .nav-item svg,
        html.sidebar-collapsed .library-item svg,
        html.sidebar-collapsed .nav-item svg {
            margin: 0 !important;
        }


        .btn{
            padding:4px 8px;
            border-radius:8px;
            background:linear-gradient(180deg,#fff,#ffd6ea);
            border:1px solid rgba(0,0,0,0.06);
            cursor:pointer;
            font-weight:700;
            text-decoration:none;
            color:inherit;
            display:inline-block;
            font-size:12px;
            font-family: Verdana, Geneva;
        }
        .btn.active{
            background:linear-gradient(180deg,var(--accent),var(--accent-dark));
            color:#fff;
        }

        .container {
            width: 100%;
            margin: 0;
            padding: 0 20px 0 20px;
            display: flex;
            gap: 20px;
            align-items: stretch;
            min-height: calc(100vh - 200px);
        }
        
        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1500px;
            margin: 0 auto;
            gap: 20px;
        }
        
        
        .header {
            background: #FFE7F4; 
            padding: 0;
            border-bottom: 1px solid #f2cfe1;
            min-height: 40px;
            width: 100%; 
        }
        
        body.dark-theme .header {
            background: #2c1810 !important;
            border-bottom: 1px solid #444 !important;
        }
        
        body.dark-theme .sidebar-toggle-btn {
            color: #fff !important;
        }
        
        body.dark-theme .sidebar-toggle-btn svg {
            fill: #fff !important;
        }
        
        body.dark-theme .user-actions a {
            color: #fff !important;
        }
        
        body.dark-theme .user-actions a:hover {
            color: #ff69b4 !important;
        }
        
        body.dark-theme .settings-btn {
            color: #fff !important;
        }
        
        body.dark-theme .settings-btn:hover {
            color: #ff69b4 !important;
        }

        .header-content-wrapper {
            display: flex;
            align-items: center;
            position: relative;
            box-sizing: border-box;
            max-width: none !important; 
            margin: 0 !important; 
            padding: 0 20px; 
            width: 100%; 
            min-height: 40px; 
        }
        
        .footer-content {
            max-width: 1600px !important;
            margin: 0 auto !important;
            padding: 0 20px !important;
        }
        

        
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1600px;
            }
            
            .footer-content {
                max-width: 1700px !important;
            }
        }
        
        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1850px;
            }
            
            .footer-content {
                max-width: 1900px !important;
            }
        }

        @media (min-width: 2400px) {
            .content-wrapper {
                max-width: 2200px;
            }

            .footer-content {
                max-width: 2200px !important;
            }
        }

        @media (min-width: 2800px) {
            .content-wrapper {
                max-width: 2500px;
            }

            .footer-content {
                max-width: 2500px !important;
            }
        }



        .main-content {
            flex: 1;
            display: flex; 
            flex-direction: column; 
        }

        .video-player {
            width: 100%;
            height: 400px;
            background: #eee;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .video-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px;
        }

        .video-title {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .video-meta {
            color: #ccc;
            font-size: 14px;
        }

        .play-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 105, 180, 0.9);
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: #ff69b4;
            width: 35%;
        }

        .time-display {
            position: absolute;
            bottom: 10px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }

        .video-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 24px; 
            margin-bottom: 15px;
            color: #fff;
            padding-left: 20px; 
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            grid-auto-flow: row;
            align-items: start;
        }

        .video-card {
            position: relative;
            cursor: pointer;
            width: 100%;
            min-width: 0;
            overflow: hidden;
            contain: layout;
        }

        .video-thumbnail {
            width: 100%;
            height: auto;
            background: #eee;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin-bottom: 7px;
            display: block; 
            aspect-ratio: 16/9;
			object-fit: cover;
        }

        .video-duration {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
            color: #fff; 
            z-index: 2; 
        }

        .video-quality {
            position: absolute;
            top: 5px;
            left: 5px;
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 10px;
            color: #fff;
            z-index: 2;
            font-weight: bold;
        }
        .video-quality[data-quality="4K"] { background: rgba(156,39,176,0.8); }
        .video-quality[data-quality="1080p"] { background: rgba(255,105,180,0.8); }
        .video-quality[data-quality="720p"] { background: rgba(76,175,80,0.8); }
        .video-quality[data-quality="480p"] { background: rgba(255,152,0,0.8); }
        .video-quality[data-quality="SD"] { background: rgba(102,102,102,0.8); }
        
        body.dark-theme .video-quality[data-quality="4K"] { background: rgba(156,39,176,0.9); }
        body.dark-theme .video-quality[data-quality="1080p"] { background: rgba(255,105,180,0.9); }
        body.dark-theme .video-quality[data-quality="720p"] { background: rgba(76,175,80,0.9); }
        body.dark-theme .video-quality[data-quality="480p"] { background: rgba(255,152,0,0.9); }
        body.dark-theme .video-quality[data-quality="SD"] { background: rgba(102,102,102,0.9); }

        .video-new {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #ff4444;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 10px;
            color: #fff;
            z-index: 2;
            font-weight: bold;
            text-transform: uppercase;
        }

        .badges-hidden .video-quality,
        .badges-hidden .video-new {
            display: none !important;
        }

        .badges-hidden [style*="position:absolute"][style*="top:5px"][style*="left:5px"][style*="background: rgba(255,134,195,0.8)"],
        .badges-hidden [style*="position:absolute"][style*="top:5px"][style*="right:5px"][style*="background:#ff4444"] {
            display: none !important;
        }

        .badges-hidden [style*="background: rgba(255,134,195,0.8)"],
        .badges-hidden [style*="background:#ff4444"] {
            display: none !important;
        }

        .badges-hidden [class*="video-quality"],
        .badges-hidden [class*="video-new"] {
            display: none !important;
        }

        .badges-hidden .video-carousel [class*="video-quality"],
        .badges-hidden .video-carousel [class*="video-new"],
        .badges-hidden .playlist-section-carousel [class*="video-quality"],
        .badges-hidden .playlist-section-carousel [class*="video-new"] {
            display: none !important;
        }

        .badges-hidden .latest-grid [class*="video-quality"],
        .badges-hidden .latest-grid [class*="video-new"] {
            display: none !important;
        }

        .badges-hidden .playlists-grid [class*="video-quality"],
        .badges-hidden .playlists-grid [class*="video-new"] {
            display: none !important;
        }

        .badges-hidden #topPlaylistsContainer [class*="video-quality"],
        .badges-hidden #topPlaylistsContainer [class*="video-new"] {
            display: none !important;
        }

        .badges-hidden [style*="position:absolute"][style*="z-index"][style*="top:5px"] {
            display: none !important;
        }

        .video-info {
            padding: 0 5px;
            width: 100%;
            min-width: 0;
            overflow-wrap: break-word;
            word-break: break-word;
        }
        
        .video-card-meta-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-top: 4px;
        }
        
        .video-card-avatar-link {
            text-decoration: none;
            display: block;
            flex-shrink: 0;
        }
        
        .video-card-avatar {
            width: 32px;
            height: 32px;
            background-color: #ff69b4;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent;
            align-self: flex-start;
        }
        
        .video-card-avatar.custom-avatar {
            background-color: transparent;
        }
        
        .video-card-text {
            flex: 1;
            min-width: 0;
        }

        .video-card-title {
            font-size: 13px;
            margin-bottom: 3px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-clamp: 2;
            color: #111;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .video-playlist {
            font-size: 11px;
            color: #ff69b4;
            margin-bottom: 2px;
        }

        .video-category {
            font-size: 11px;
            color: #666;
        }
        

        
        .video-views {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .video-stats {
            font-size: 11px;
            color: #888;
        }
        
        .video-date {
            font-size: 11px;
            color: #888;
        }
        
        .video-views::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            background: currentColor;
            -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z'/%3E%3C/svg%3E") center/contain no-repeat;
            mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z'/%3E%3C/svg%3E") center/contain no-repeat;
        }
        
        .video-danmaku {
            font-size: 11px;
            color: #666;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            margin-left: 8px;
        }
        
        .video-danmaku::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 12px;
            background: currentColor;
            -webkit-mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z'/%3E%3C/svg%3E") center/contain no-repeat;
            mask: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath d='M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z'/%3E%3C/svg%3E") center/contain no-repeat;
        }

        .video-tag-link, .video-category-link { 
            color: #666; 
            text-decoration: none; 
            margin-right: 5px; 
            cursor: pointer; 
        }

        .playlists-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 10px;
            grid-auto-flow: row;
            align-items: start;
        }

        .playlist-section-carousel {
            margin-bottom: 10px; 
        }

        .playlist-item {
            background: #fff; 
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform .2s, box-shadow .2s;
            position: relative;
            border: 1px solid #eee;
            width: 100%;
            min-width: 0;
            contain: layout;
        }

        .playlist-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .playlist-thumbnail {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            aspect-ratio: 16/9;
            background: #eee;
            position: relative;
            height: 80px;
        }

        .playlist-thumb {
            background: #f2f2f2;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 10px;
            border: 1px solid #e6e6e6;
            position: relative;
            overflow: hidden;
        }

        .playlist-info {
            padding: 10px; 
            background: #fafafa; 
            border-top: 1px solid #eee;
        }

        .playlist-title {
            font-weight: 600;
            margin-bottom: 3px; 
            font-size: 13px; 
            color: #111;
        }

        .playlist-meta {
            font-size: 11px; 
            color: #777;
            margin-bottom: 3px; 
        }

        .playlist-channel {
            font-size: 11px; 
            color: #ff69b4; 
        }

        .playlist-channel-link {
            color: #ff69b4;
            text-decoration: none;
            font-weight: 500;
        }

        .playlist-channel-link:hover {
            text-decoration: underline;
        }


        .empty-state {
            text-align: center;
            color: #666;
            padding: 60px 20px;
            font-size: 16px;
        }
        
        .no-data-message {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-size: 14px;
            background: #f9f9f9;
            border-radius: 8px;
            margin: 20px 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .latest-section {
            margin-top: 10px;
            flex: 1; 
            display: flex;
            flex-direction: column;
        }
        .latest-title {
            font-size: 20px;
            margin: 10px 0 8px 20px;
            color: #111;
        }
        .latest-grid {
            display: grid;
            grid-template-columns: repeat(var(--latest-cols, 6), 1fr);
            gap: 12px;
            padding: 0 20px 0 20px;
            flex: 1; 
            min-height: 0; 
            align-content: start;
            justify-content: start;
            grid-auto-flow: row;
            align-items: start;
            min-height: 400px;
        }

        .skeleton-card {
            position: relative;
            cursor: default;
            width: 100%;
            min-width: 0;
            overflow: hidden;
            contain: layout;
            opacity: 0.7;
        }
        
        .skeleton-thumb {
            width: 100%;
            height: auto;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 6px;
            margin-bottom: 4px;
            aspect-ratio: 16/9;
        }
        
        .skeleton-info {
            padding: 0 5px;
            width: 100%;
            min-width: 0;
        }
        
        .skeleton-title {
            height: 13px;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 2px;
            margin-bottom: 3px;
        }
        
        .skeleton-channel {
            height: 11px;
            width: 70%;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 2px;
            margin-bottom: 2px;
        }
        
        .skeleton-views {
            height: 11px;
            width: 50%;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 2px;
        }
        
        @keyframes skeleton-loading {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 1000;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #ffffff40;
            border-top: 2px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 3px;
            background: #ff69b4;
            transition: width 0.3s ease;
            z-index: 1001;
        }
        .latest-card {
            position: relative;
            cursor: pointer;
            width: 100%;
            min-width: 0;
            overflow: hidden;
            contain: layout;
        }
        .latest-thumb {
            width: 100%;
            height: auto;
			object-fit: cover;
            background: #eee;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin-bottom: 4px;
            display: block;
            aspect-ratio: 16/9;
        }
        .latest-info {
            padding: 0 5px;
            width: 100%;
            min-width: 0;
            overflow-wrap: break-word;
            word-break: break-word;
        }
        .latest-title-text {
            font-size: 13px;
            margin-bottom: 3px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-clamp: 2;
            color: #111;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }
        .latest-sub {
            font-size: 11px;
            color: #666;
        }
        .latest-channel {
            font-size: 11px;
            color: #ff69b4;
            margin-bottom: 2px;
        }
        
        .latest-duration {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
            color: #fff;
            z-index: 2;
        }

        @media (min-width: 1280px) and (max-width: 1440px) {
            .banner-section {
                height: 180px !important;
            }
        }

        @media (min-width: 1441px) and (max-width: 1699px) {
            .banner-section {
                height: 220px !important;
            }
        }

        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1600px;
            }
            
            .banner-section {
                height: 250px !important;
            }
        }

        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1850px;
            }
            
            .banner-section {
                height: 280px !important;
            }
        }

        @media (min-width: 2400px) {
            .content-wrapper {
                max-width: 2200px;
            }
            
            .banner-section {
                height: 300px !important;
            }
            
            :root {
                --latest-cols: 8;
            }
        }

        @media (min-width: 2800px) {
            .content-wrapper {
                max-width: 2500px;
            }
            
            .banner-section {
                height: 320px !important;
            }
            
            :root {
                --latest-cols: 9;
            }
        }
        
        @media (min-width: 1400px) and (max-width: 1999px) {
            :root {
                --latest-cols: 6;
            }
        }
        
        @media (min-width: 1200px) and (max-width: 1399px) {
            :root {
                --latest-cols: 5;
            }
        }
        
        @media (min-width: 1000px) and (max-width: 1199px) {
            :root {
                --latest-cols: 4;
            }
        }
        
        @media (min-width: 850px) and (max-width: 999px) {
            :root {
                --latest-cols: 4;
            }
        }
        
        @media (min-width: 650px) and (max-width: 849px) {
            :root {
                --latest-cols: 3;
            }
        }
        
        @media (min-width: 480px) and (max-width: 649px) {
            :root {
                --latest-cols: 2;
            }
        }
        
        @media (max-width: 479px) {
            :root {
                --latest-cols: 2;
            }
        }

        @media (max-width: 1200px) {
            .video-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }
            .playlists-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            }
        }

        @media (max-width: 1000px) {
            .video-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }
            .playlists-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }
        }

        @media (max-width: 850px) {
            .video-grid {
                grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            }
            .playlists-grid {
                grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            }
        }

        @media (max-width: 650px) {
            .video-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 8px;
            }
            .playlists-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 8px;
            }
        }

        @media (max-width: 480px) {
            .video-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            .playlists-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            .video-carousel {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
        }

        @media (max-width: 1024px) {
            .sidebar-right {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 0 10px;
                gap: 10px;
            }
            
            .banner-section {
                height: 140px;
                margin: 0 0 3px 0;
                border-radius: 6px;
            }

            .tags-section {
                margin: 0 0 5px 0;
                padding-bottom: 4px;
                flex-wrap: wrap;
            }
            
            
            body:not(.sidebar-collapsed) .sidebar {
                display: none;
            }
            
            body.sidebar-collapsed .sidebar {
                display: block;
                width: 60px;
                padding: 10px 8px;
            }
            
            .sidebar-section {
                flex-shrink: 0;
                margin-bottom: 0;
            }
            
            .video-player {
                height: 250px;
            }
            
            .latest-grid {
                padding: 0;
                gap: 8px;
            }
            
            .playlist-section-header {
                padding: 0 10px;
            }
            
            .video-carousel-wrapper {
                padding: 0 10px;
            }
            
            .latest-title {
                margin-left: 10px;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                flex-direction: column;
                padding: 0 5px;
            }
            
            .banner-section {
                height: 110px;
                margin: 0 0 8px 0 !important;
            }

            .tags-section {
                margin: 0 0 8px 0 !important;
                padding-bottom: 6px;
                flex-direction: column;
                gap: 6px;
            }
            
            .tags-container {
                gap: 4px;
            }
            
            .tag-item {
                font-size: 11px;
                padding: 3px 6px;
            }
            
            .grid-switcher {
                gap: 4px;
            }
            
            .grid-btn {
                padding: 3px 6px;
                font-size: 10px;
            }
            
            
            .latest-grid {
                padding: 0 !important;
            }
            
            .video-carousel-wrapper {
                padding: 0 5px !important;
            }
            
            .playlist-section-header {
                padding: 0 5px !important;
            }
            
            .sidebar {
                width: 100% !important;
            }
            
            .video-player {
                height: 200px;
            }
            
            .video-title {
                font-size: 18px;
            }
            
            .play-btn {
                width: 60px;
                height: 60px;
                font-size: 18px;
            }
            
            .video-card, .latest-card {
                width: 100%;
                min-width: 0;
                overflow: hidden;
                max-width: none;
            }
            
            .video-thumbnail, .latest-thumb {
                width: 100%;
                aspect-ratio: 16/9;
                object-fit: cover;
                height: auto;
                min-height: 0;
            }
            
            .video-info, .latest-info {
                width: 100%;
                min-width: 0;
                overflow-wrap: break-word;
                word-break: break-word;
            }
            
            .video-card-title, .latest-title-text {
                font-size: 12px;
                line-height: 1.2;
                overflow: hidden;
                text-overflow: ellipsis;
                word-wrap: break-word;
            }
            
            .playlist-item {
                width: 100%;
                min-width: 0;
                overflow: hidden;
            }
            
            .playlist-thumbnail {
                width: 100%;
                height: auto;
                aspect-ratio: 16/9;
                min-height: 60px;
            }
            
            .playlist-info {
                padding: 8px;
                min-width: 0;
            }
            
            .playlist-title {
                font-size: 12px;
                line-height: 1.2;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            

        }

        .banner-section {
            background: center/cover no-repeat;
            margin: 0 20px 5px 20px;
            overflow: hidden;
            height: 200px;
            width: auto; 
        }

        .tags-section {
            margin: 0 20px 3px 20px;
            border-bottom: 2px solid #ff69b4;
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap; 
        }

        .grid-switcher {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            margin: 0;
            flex-shrink: 0;
            flex-wrap: wrap; 
        }
        .grid-switcher .grid-btn {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #eee;
            background: #fff;
            color: #333;
            border-radius: 4px;
            cursor: pointer;
        }
        .grid-switcher .grid-btn.active {
            background: #ff69b4;
            color: #fff;
            border-color: #ff69b4;
        .tags-container {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 1px 0;
            flex: 1;
            flex-wrap: wrap; 
            min-width: 0; 
        }   flex: 1;
            flex-wrap: nowrap; 
        }

        .tags-container::-webkit-scrollbar {
            display: none;
        }

        .tag-item {
            color: #666;
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 3px;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
            line-height: 1.2;
        }

        .tag-item:hover {
            color: #ff69b4;
            background: rgba(255, 105, 180, 0.1);
        }

        .tag-item.active {
            color: #ff69b4;
            font-weight: 600;
        }

        .tag-item.active::after {
            content: none; 
            display: none;
        }

        @media (max-width: 768px) {
            .banner-section {
                height: 140px;
                margin: 0 5px 3px 5px;
            }

            .tags-section {
                margin: 0 5px 5px 5px;
                padding-bottom: 4px;
            }

            .tags-container {
                gap: 5px;
                overflow-x: hidden;
            }

            .tag-item {
                font-size: 11px;
                padding: 3px 6px;
            }

            .tag-item.active::after {
                bottom: -6px;
                width: 70%;
            }
        }

        @media (max-width: 480px) {
            .banner-section {
                height: 110px;
                margin: 0 3px 2px 3px;
            }

            .tags-section {
                margin: 0 3px 3px 3px;
                padding-bottom: 3px;
            }

            .tags-container {
                gap: 4px;
                overflow-x: hidden;
            }

            .tag-item {
                font-size: 10px;
                padding: 2px 5px;
            }
        }

        .playlists-header-title {
            font-size: 20px;
            margin: 10px 0 8px 20px;
            color: #111;
            font-weight: 600;
        }

        .playlist-section-title {
            font-size: 16px;
            margin-bottom: 0px;
            color: #111;
        }

        .playlist-section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 20px; 
    margin-bottom: 0px; 
    min-height: 20px; 
    gap: 10px; 
}

        .playlist-section-all-link {
            color: #333;
            text-decoration: none;
            font-size: 11px; 
            cursor: pointer;
            flex-shrink: 0;
            white-space: nowrap;
            margin-left: auto;
        }

        .video-carousel-wrapper {
            position: relative;
            padding: 0 20px; 
            margin-bottom: 10px; 
        }



        .footer {
            background: #2c2c2c;
            color: #fff;
            padding: 25px 0 15px 0;
            margin-top: 0;
        }

        .footer-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .footer-logo {
            flex-shrink: 0;
            width: 200px;
        }

        .footer-logo img {
            height: 40px;
            width: auto;
        }

        .footer-logo p {
            margin-top: 8px;
            font-size: 11px;
            color: #ccc;
            line-height: 1.3;
        }

        .footer-sections {
            display: flex;
            gap: 30px;
            flex: 1;
        }

        .footer-main {
            display: flex;
            gap: 30px;
            flex: 1;
        }

        .footer-right {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .footer-mascot {
            flex-shrink: 0;
        }

        .footer-mascot img {
            height: 180px;
            width: auto;
        }





        .footer-section {
            flex: 1;
        }

        .footer-section h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #fff;
            font-weight: 600;
        }

        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .footer-section li {
            margin-bottom: 6px;
        }

        .footer-section a {
            color: #ccc;
            text-decoration: none;
            font-size: 11px;
            transition: color 0.2s;
        }

        .footer-section a:hover {
            color: #ff69b4;
        }

        .footer-bottom {
            border-top: 1px solid #444;
            margin-top: 20px;
            padding-top: 15px;
            text-align: center;
            color: #999;
            font-size: 10px;
        }

        @media (max-width: 768px) {
            .footer-content {
                flex-direction: column;
                gap: 30px;
            }
            
            .footer-sections {
                flex-direction: column;
                gap: 20px;
            }
            
            .footer-main {
                flex-direction: column;
                gap: 20px;
            }
            
            .footer-right {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .footer-mascot img {
                height: 120px;
            }
            
            .footer-section {
                text-align: center;
            }
        }

        .video-carousel {
    display: grid;
    grid-template-columns: repeat(var(--latest-cols, 6), 1fr);
    gap: 8px;
    width: 100%;
    align-content: start;
    justify-content: start;
    grid-auto-flow: row;
    align-items: start;
}



                 .video-carousel .video-card {
     flex: initial;
     max-width: none;
     min-width: 0;
     overflow: hidden;
     transition: transform .2s, box-shadow .2s;
     width: 100%;
     contain: layout;
 }
                 .video-carousel .video-thumbnail {
             background: #eee;
             position: relative;
             overflow: hidden;
             width: 100%; 
             height: auto;
			 object-fit: cover;
             margin-bottom: 4px;
             display: block; 
             aspect-ratio: 16/9;
			 object-fit: cover;
         }

        .video-carousel .video-duration {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
            color: #fff;
            z-index: 2; 
        }

        .video-carousel .video-info {
            padding: 0 5px; 
        }
        
        .video-carousel .video-playlist { 
            font-size: 11px;
            color: #ff69b4;
            margin-bottom: 1px; 
        }

        .video-carousel .video-card-title {
            font-size: 13px;
            margin-bottom: 2px;
            color: #111;
        }

        .video-carousel .video-category {
            font-size: 10px;
            color: #666; 
        }
        
        .video-carousel .video-views {
            font-size: 11px;
            color: #666;
            margin-top: 1px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .video-carousel .video-views::before {
            content: 'üëÅ';
            font-size: 10px;
        }
        


        .carousel-nav-btn {
            position: absolute;
            top: 50%; 
            transform: translateY(-50%); 
            background: rgba(128, 128, 128, 0.8); 
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            z-index: 10;
            border-radius: 50%; 
            font-size: 20px;
            line-height: 1;
            height: 50px;
            width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: opacity 0.2s;
            margin-top: -25px; 
        }

        .carousel-nav-btn.prev-btn {
            left: 20px; 
        }

        .carousel-nav-btn.next-btn {
            right: 20px; 
        }
		
		

        @media (max-width: 1024px) {
            .carousel-nav-btn {
                padding: 8px 12px;
                font-size: 18px;
                height: 40px;
                width: 40px;
            }
        }

        @media (max-width: 768px) {
            .carousel-nav-btn {
                padding: 6px 10px;
                font-size: 16px;
                height: 35px;
                width: 35px;
            }
            .playlist-section-title {
                font-size: 16px;
                padding-left: 0;
                text-align: center;
            }
            
            .footer-content {
                flex-direction: column;
                gap: 30px;
            }
            
            .footer-sections {
                flex-direction: column;
                gap: 20px;
            }
            
            .footer-main {
                flex-direction: column;
                gap: 20px;
            }
            
            .footer-right {
                width: 100%;
                flex-direction: column;
                align-items: center;
                gap: 15px;
                margin-top: 15px;
            }
            
            .footer-mascot img {
                height: 120px;
            }
            
            .footer-section {
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .video-carousel-wrapper {
                padding: 0 10px;
            }
            .carousel-nav-btn {
                display: none; 
            }
            .playlist-section-title {
                font-size: 16px;
                padding-left: 0;
                text-align: center;
            }
        }

        .sidebar {
            padding-top: 0 !important;
            padding-bottom: 20px !important;
            margin-top: 0 !important;
        }

        .sidebar-section:first-child {
            margin-top: 10px;
        }

        .sidebar-collapsed .sidebar-section:first-child,
        html.sidebar-collapsed .sidebar-section:first-child {
            margin-top: 0;
        }


/* =========================================
           MOBILE ADAPTIVE STYLES (START)
           ========================================= */
        
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px; 
            background: #fff;
            border-top: 1px solid #eee;
            z-index: 1000;
            justify-content: space-around;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .mobile-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: #111;
            font-size: 10px;
            flex: 1;
            height: 100%;
        }

        .mobile-nav-item svg {
            width: 24px;
            height: 24px;
            margin-bottom: 2px;
            stroke: #111;
            fill: none;
        }

        .mobile-nav-item.active {
            color: #ff69b4;
        }
        
        .mobile-nav-item.active svg {
            stroke: #ff69b4;
        }

        .mobile-nav-item.upload-btn svg {
            width: 32px;
            height: 32px;
        }


        @media (max-width: 768px) {
            .mobile-bottom-nav {
                display: flex;
            }

            .top-nav {
                display: none;
            }

            body {
                padding-bottom: 60px; 
            }

            .header {
                position: sticky;
                top: 0;
                padding: 0;
                height: 50px; 
            }
            
            .header-content-wrapper {
                padding: 0 10px;
            }
            
            .header-content-wrapper {
                padding: 0;
            }

            .logo img {
                height: 24px; 
            }

            
            .container {
                padding-left: 10px;
                padding-right: 10px;
            }

            .main-content {
                width: 100%;
                margin-left: 0 !important;
            }
        }

        @media (max-width: 480px) {
            :root {
                --latest-cols: 1; 
            }

            .latest-grid, 
            .video-carousel {
                grid-template-columns: 1fr !important; 
                gap: 15px;
            }

            .video-card, 
            .latest-card {
                margin-bottom: 10px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
                border-radius: 8px;
                background: #fff;
            }
            
            .video-thumbnail, 
            .latest-thumb {
                border-radius: 8px 8px 0 0; 
                margin-bottom: 0;
            }

            .video-info, 
            .latest-info {
                padding: 10px;
            }

            .video-card-title {
                font-size: 14px; 
                margin-bottom: 5px;
            }
            
            .video-playlist, .video-views {
                font-size: 12px;
            }

            .banner-section {
                margin: 0 -10px 10px -10px !important; 
                border-radius: 0;
                height: 160px;
            }
            
            .tags-section {
                margin-bottom: 10px;
            }
            
            .user-actions a:not(#badgesToggle) {
                display: none;
            }
            
            .settings-container {
                display: block;
            }
        }
        /* =========================================
           MOBILE ADAPTIVE STYLES (END)
           ========================================= */

        /* Large screen adaptations for sidebar-collapsed */
        @media (min-width: 1700px) {
            .sidebar-collapsed .content-wrapper,
            html.sidebar-collapsed .content-wrapper {
                max-width: 1700px !important;
            }
        }

        @media (min-width: 2000px) {
            .sidebar-collapsed .content-wrapper,
            html.sidebar-collapsed .content-wrapper {
                max-width: 1950px !important;
            }
        }

        @media (min-width: 2400px) {
            .sidebar-collapsed .content-wrapper,
            html.sidebar-collapsed .content-wrapper {
                max-width: 2300px !important;
            }
        }

        @media (min-width: 2800px) {
            .sidebar-collapsed .content-wrapper,
            html.sidebar-collapsed .content-wrapper {
                max-width: 2600px !important;
            }
        }
    </style>
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    
    <!-- Theme System -->
    <link rel="stylesheet" href="youvi/themes/dark-theme.css">
    <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    <link rel="stylesheet" href="youvi/pagination.css">
    
    <!-- Adaptive Grid System -->
    <link rel="stylesheet" href="youvi/adaptive-grid.css">
    
    <!-- Adaptive Grid System -->
    <link rel="stylesheet" href="youvi/adaptive-grid.css">
    
    <!-- YouVi Hover Preview System -->
    <script src="youvi/hover/hover-preview-queue.js"></script>
    <script src="youvi/hover/hover-preview.js"></script>
    <script src="youvi/hover/hover-init.js"></script>
    <script src="youvi/hover/hover-bundle.js"></script>
    
    <!-- Adaptive Grid System -->
    <script src="youvi/adaptive-grid.js"></script>
    
    <!-- Theme Toggle Script -->
    <script src="youvi/themes/theme-toggle.js"></script>
    
    <!-- Header Script -->
    <script src="youvi/header/youvi-header.js"></script>
    
    
    <!-- Sidebar Script -->
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/danmaku-counter.js"></script>
    <link rel="stylesheet" href="youvi/danmaku-counter.css">
    <link rel="stylesheet" href="youvi/sticky-video.css">
  
  <!-- Autocomplete Module -->
  <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
  <script src="youvi/autocomplete-data-loader.js"></script>
  <script src="youvi/autocomplete/autocomplete-cache.js"></script>
  <script src="youvi/autocomplete/autocomplete.js"></script>
  <script src="youvi/autocomplete/autocomplete-integration.js"></script>
  
  <!-- Avatar Cache Module -->
  <script src="youvi/avatar-cache.js"></script>
  
  <!-- Video ID System -->
  <script src="youvi/video-id.js"></script>
  
  <!-- i18n System -->
  <script src="youvi/i18n/ru.js"></script>
  <script src="youvi/i18n/en.js"></script>
  <script src="youvi/i18n/uk.js"></script>
  <script src="youvi/i18n/i18n.js"></script>
</head>
<link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">
<body>
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
      <a href="youvi_main.html" class="active" data-i18n="nav.video">–í–∏–¥–µ–æ</a>
      <a href="index.html" data-i18n="nav.management">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</a>
      <a href="youvi_ch_list.html" data-i18n="nav.channels">–ö–∞–Ω–∞–ª—ã</a>
      <a href="youvi_playlists_list.html" data-i18n="nav.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</a>
      <a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a> 
      <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
      <div class="lang-switcher">
        <select id="langSwitcher" class="lang-select">
          <option value="ru">üá∑üá∫ RU</option>
          <option value="en">üá¨üáß EN</option>
          <option value="uk">üá∫üá¶ UK</option>
        </select>
      </div>
        </div>
    </div>

  <!-- Header -->
  <header class="header">
    <div class="header-content-wrapper">
      <div class="header-left">
        <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle sidebar" data-i18n-aria="header.toggleSidebar">
          <svg viewBox="0 0 24 24">
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
          </svg>
        </button>
        
        <div class="logo">
          <a href="youvi_main.html">
            <img src="images/logo_youvi_ind.png" alt="Youvi logo">
          </a>
        </div>
        

      </div>
      
      <div class="header-center">
        <div class="search-area autocomplete-wrapper">
          <input type="text" id="globalSearch" data-i18n-placeholder="search.placeholder" placeholder="–ü–æ–∏—Å–∫ –≤–∏–¥–µ–æ..." class="search-input">
          <button id="doSearch" class="search-btn" data-i18n="search.button">–ù–∞–π—Ç–∏</button>
        </div>
      </div>
      
      <div class="header-right">
        <div class="user-actions">
          <a href="#" id="badgesToggle" data-i18n="header.badges">–ú–µ—Ç–∫–∏</a>
          <a href="#" id="forceRefreshBtn" data-i18n="header.scan" data-i18n-title="header.scanTitle" title="–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à –∏ –ø–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –≤–∏–¥–µ–æ">–°–∫–∞–Ω</a>
          <div class="settings-container">
            <a href="#" class="settings-btn">‚öô</a>
            <div class="theme-dropdown">
              <button class="theme-dropdown-item" data-theme="light" data-i18n="themes.light">–ë–µ–ª–∞—è</button>
              <button class="theme-dropdown-item" data-theme="dark" data-i18n="themes.dark">–ß–µ—Ä–Ω–∞—è</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation">–ù–∞–≤–∏–≥–∞—Ü–∏—è</div>
                <a href="youvi_main.html" class="sidebar-item nav-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9,22 9,12 15,12 15,22"/>
                    </svg>
                    <span data-i18n="sidebar.home">–ì–ª–∞–≤–Ω–∞—è</span>
                </a>
                <a href="youvi_feed_all.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 11a9 9 0 0 1 9 9"/>
                        <path d="M4 4a16 16 0 0 1 16 16"/>
                        <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                    </svg>
                    <span data-i18n="sidebar.feed">Feed</span>
                </a>
                <a href="youvi_tags.html" class="sidebar-item nav-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                     <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                  <line x1="7" y1="7" x2="7.01" y2="7"/>
                 </svg>
                    <span data-i18n="sidebar.allTags">–í—Å–µ —Ç–µ–≥–∏</span>
                </a>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library">–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞</div>

                <a href="youvi_history.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.history">–ò—Å—Ç–æ—Ä–∏—è</span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <span data-i18n="sidebar.favorites">–ò–∑–±—Ä–∞–Ω–Ω–æ–µ</span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="8" y1="8" x2="16" y2="8"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="16" x2="16" y2="16"/>
                        <circle cx="6" cy="8" r="1"/>
                        <circle cx="6" cy="12" r="1"/>
                        <circle cx="6" cy="16" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span data-i18n="sidebar.channels">–ö–∞–Ω–∞–ª—ã</span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
                        <polyline points="17,2 12,7 7,2"/>
                    </svg>
                    <span data-i18n="sidebar.subscriptions">–ü–æ–¥–ø–∏—Å–∫–∏</span>
                </a>
            </div>
            
            <div class="sidebar-section">
              <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle">–ü–æ–¥–ø–∏—Å–∫–∏</div>
              <div id="subscribedChannelsContainer"></div>
          </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.sorting">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞</div>
                <div id="sortOptionsContainer">
                <a href="#" class="sidebar-item library-item" id="sortNew">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.sortNew">–ù–æ–≤—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortPopular">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                    </svg>
                    <span data-i18n="sidebar.sortPopular">–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortOld">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    <span data-i18n="sidebar.sortOld">–°—Ç–∞—Ä—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortRandom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="3" ry="3"/>
                        <circle cx="8" cy="8" r="1"/>
                        <circle cx="16" cy="8" r="1"/>
                        <circle cx="8" cy="16" r="1"/>
                        <circle cx="16" cy="16" r="1"/>
                        <circle cx="12" cy="12" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.sortRandom">–°–ª—É—á–∞–π–Ω—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortAlphabetical">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 16L8 6l4 10"/>
                        <path d="M5 13h6"/>
                        <path d="M14 6h6"/>
                        <path d="M14 12h6"/>
                        <path d="M14 18h6"/>
                    </svg>
                    <span data-i18n="sidebar.sortAlphabetical">–ü–æ –∞–ª—Ñ–∞–≤–∏—Ç—É</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortDanmaku">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                    </svg>
                    <span data-i18n="sidebar.sortDanmaku">–ü–æ –¥–∞–Ω–º–∞–∫—É</span>
                </a>
                </div>
            </div>
                
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.tags">–¢–µ–≥–∏</div>
                <a href="#" class="sidebar-item active" id="allPlaylistsLink" data-i18n="sidebar.allTagsLink">–í—Å–µ —Ç–µ–≥–∏</a> <!-- Renamed and moved -->
                <div id="sidebarTagsContainer"></div>
            </div>
        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
        <!-- Main Content -->
        <main class="main-content">
            <div id="topPlaylistsContainer"></div>
            <section class="latest-section">
                <h2 class="latest-title" id="latestTitle" data-i18n="main.latestVideos">–°–≤–µ–∂–∏–µ –≤–∏–¥–µ–æ</h2>
                <div id="latestGrid" class="latest-grid"></div>
            </section>
        </main>
        </div><!-- /content-wrapper -->

    </div>

            <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <div class="footer-main">
                    <div class="footer-logo">
                        <img src="images/logo_youvi_ind_ex.png" alt="Youvi">
                        <p data-i18n="footer.description">–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤–∏–¥–µ–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ, –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∏—Ä—É–π—Ç–µ –∏ —Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∏–¥–µ–æ.</p>
                    </div>
                    <div class="footer-sections">
                        <div class="footer-section">
                            <h3 data-i18n="footer.sections">–†–∞–∑–¥–µ–ª—ã</h3>
                            <ul>
              <li><a href="youvi_main.html" data-i18n="footer.video">–í–∏–¥–µ–æ</a></li>
              <li><a href="youvi_tags.html" data-i18n="sidebar.tags">–¢–µ–≥–∏</a></li>
              <li><a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a></li>
              <li><a href="index.html" data-i18n="nav.management">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="sidebar.library">–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞</h3>
            <ul>
              <li><a href="youvi_ch_list.html" data-i18n="sidebar.channels">–ö–∞–Ω–∞–ª—ã</a></li>
              <li><a href="youvi_playlists_list.html" data-i18n="sidebar.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</a></li>
              <li><a href="youvi_subscriptions.html" data-i18n="sidebar.subscriptions">–ü–æ–¥–ø–∏—Å–∫–∏</a></li>
              <li><a href="youvi_fav.html" data-i18n="sidebar.favorites">–ò–∑–±—Ä–∞–Ω–Ω–æ–µ</a></li>
              <li><a href="youvi_history.html" data-i18n="sidebar.history">–ò—Å—Ç–æ—Ä–∏—è</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="nav.wiki">Wiki</h3>
            <ul>
              <li><a href="wiki/index.html" data-i18n="sidebar.home">–ì–ª–∞–≤–Ω–∞—è</a></li>
              <li><a href="wiki/player.html" data-i18n="footer.wiki.player">–ü–ª–µ–µ—Ä</a></li>
              <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku">–î–∞–Ω–º–∞–∫—É</a></li>
              <li><a href="wiki/tags/general.html" data-i18n="sidebar.tags">–¢–µ–≥–∏</a></li>
              <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules">–ü—Ä–∞–≤–∏–ª–∞ —Ç–µ–≥–∏—Ä–æ–≤–∞–Ω–∏—è</a></li>
              <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search">–ü–æ–∏—Å–∫</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.pgc">PGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
              <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
              <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
              <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
              <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.ugc">UGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
              <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
              <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
              <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
              <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
              <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
              <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
            </ul>
          </div>
        
          <div class="footer-section">
            <h3 data-i18n="footer.about">–û —Å–∞–π—Ç–µ</h3>
            <ul>
              <li><a href="wiki/about.html" data-i18n="footer.aboutSite">–ü—Ä–æ —Å–∞–π—Ç</a></li>
               <li><a href="wiki/docs.html" data-i18n="footer.docs">–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</a></li>
              <li><a href="wiki/tech.html" data-i18n="footer.tech">–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏</a></li>
            </ul>
                        </div>
                    </div>
                </div>
                <div class="footer-right">
                    <div class="footer-mascot">
                        <img src="images/mascot1.png" alt="Yuvi">
                    </div>
                </div>
            </div>
        </footer>

    <script>
      const DEBUG = false;
      const debug = {
        log: (...args) => { if (DEBUG) console.log(...args); },
        warn: (...args) => { if (DEBUG) console.warn(...args); },
        error: (...args) => { if (DEBUG) console.error(...args); }
      };

      let isRenderingVideos = false;
      let isRenderingMixedContent = false;
      let lastRenderTime = 0;
      let currentRenderVersion = 0;
      const RENDER_DEBOUNCE_MS = 150;
      
      const supportsFS = 'showDirectoryPicker' in window;

      let videoDirectoryHandle = null;
      let allPlaylists = [];
      let allPlaylistsComplete = [];
      let allVideos = [];
      let filteredPlaylists = [];
      
      let globalMetadataCache = new Map();
      
      let previewLoadingState = new Map();
      
      function forceRefreshCache() {
        localStorage.removeItem('lastVideoScan');
        globalMetadataCache.clear();
        debug.log('üîÑ Cache cleared, next load will perform full scan');
      }
      let currentPage = parseInt(new URLSearchParams(window.location.search).get('page')) || 1;
      const itemsPerPage = 8;
      const videosPerPage = 6;
      const videosPerRow = 5;
      const rowsPerPage = 8;
      let carouselVideoPages = new Map();
      let allPlaylistCategories = new Map();
      let currentSearchQuery = new URLSearchParams(window.location.search).get('search') || '';
      let currentSort = new URLSearchParams(window.location.search).get('sort') || localStorage.getItem('playlistSort') || 'new';
      let currentFilter = new URLSearchParams(window.location.search).get('tag') || 'all';
      let db = null;
      let bannerLoaded = false;
      let savedBannerElement = null;

      const categoryAliases = {
        'anime (ct)': '–∞–Ω–∏–º–µ (ct)',
        'animation (ct)': '–∞–Ω–∏–º–∞—Ü–∏—è (ct)',
        'games (ct)': '–∏–≥—Ä—ã (ct)',
        'series (ct)': '—Å–µ—Ä–∏–∞–ª—ã (ct)',
        'movies (ct)': '–∫–∏–Ω–æ (ct)',
        'music (ct)': '–º—É–∑—ã–∫–∞ (ct)',
        'entertainment (ct)': '—Ä–∞–∑–≤–ª–µ—á–µ–Ω–∏—è (ct)',
        'technology (ct)': '—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (ct)',
        'education (ct)': '—É—á–µ–±–∞ (ct)',
        'irl (ct)': '–∏—Ä–ª (ct)',
        'tv (ct)': '—Ç–≤ (ct)',
        'other (ct)': '—Ä–∞–Ω–¥–æ–º (ct)'
      };
      
      function resolveCategoryAlias(tag) {
        if (!tag || tag === 'all') return tag;
        const lower = tag.toLowerCase().trim();
        return categoryAliases[lower] || tag;
      }

      async function openDB(){
        return new Promise((resolve,reject)=>{
          const req = indexedDB.open('8SiteDB', 1);
          req.onupgradeneeded = ()=> {
            const db = req.result;
            if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
            if (!db.objectStoreNames.contains('videos')) {
              const videoStore = db.createObjectStore('videos', { keyPath: 'name' });

              videoStore.createIndex('created', 'created', { unique: false });
              videoStore.createIndex('modified', 'modified', { unique: false });
              videoStore.createIndex('views', 'views', { unique: false });
              videoStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
              videoStore.createIndex('quality', 'quality', { unique: false });
            }
            if (!db.objectStoreNames.contains('playlists')) db.createObjectStore('playlists', { keyPath: 'id' });
          };
          req.onsuccess = ()=> resolve(req.result);
          req.onerror = ()=> reject(req.error);
        });
      }

      async function clearCache() {
        if (!db) return;
        
        try {

          if (db.objectStoreNames.contains('videos')) {
            const videoTx = db.transaction('videos', 'readwrite');
            const videoStore = videoTx.objectStore('videos');
            await videoStore.clear();
          }

          if (db.objectStoreNames.contains('playlists')) {
            const playlistTx = db.transaction('playlists', 'readwrite');
            const playlistStore = playlistTx.objectStore('playlists');
            await playlistStore.clear();
          }

          try {
            const handlesTx = db.transaction('handles', 'readwrite');
            const handlesStore = handlesTx.objectStore('handles');
            const allKeys = await new Promise((resolve, reject) => {
              const req = handlesStore.getAllKeys();
              req.onsuccess = () => resolve(req.result);
              req.onerror = () => reject(req.error);
            });

            for (const key of allKeys) {
              if (typeof key === 'string' && key.startsWith('preview_')) {
                await handlesStore.delete(key);
              }
            }
          } catch (e) {
            debug.warn('Failed to clear old format cache:', e);
          }

          if (typeof AutocompleteDataLoader !== 'undefined') {
            AutocompleteDataLoader.clearCache();
            debug.log('Autocomplete global cache cleared');
          }

          if (typeof autocompleteCache !== 'undefined') {
            await autocompleteCache.clearCache();
            debug.log('Autocomplete IndexedDB cache cleared');
          }
          
          debug.log('Cache cleared successfully');
        } catch (e) {
          debug.error('Error clearing cache:', e);
        }
      }

      async function forceRefreshData() {
        debug.log('üîÑ Force refreshing data - clearing cache and rescanning all videos...');

        await clearCache();

        allVideos = [];
        allPlaylists = [];

        const perfStart = performance.now();
        await loadAllVideosForced();
        await loadAllPlaylists();
        
        debug.log(`‚úÖ Force refresh completed in ${Math.round(performance.now() - perfStart)}ms`);
        debug.log(`üìä Total videos after refresh: ${allVideos.length}`);
        
        currentPage = 1;
        updateUrlParameter('page', null);
        applyFiltersAndRender();
        updatePageTitle();
      }

      function showLoadingIndicator(message) {
        const indicator = document.createElement('div');
        indicator.className = 'loading-indicator';
        indicator.id = 'loadingIndicator';
        indicator.innerHTML = `
          <div class="loading-spinner"></div>
          <span>${message}</span>
        `;
        document.body.appendChild(indicator);
        
        const progressBar = document.createElement('div');
        progressBar.className = 'loading-progress';
        progressBar.id = 'loadingProgress';
        document.body.appendChild(progressBar);
      }
      
      function updateLoadingProgress(percent) {
        const progressBar = document.getElementById('loadingProgress');
        if (progressBar) {
          progressBar.style.width = `${percent}%`;
        }
      }
      
      function hideLoadingIndicator() {
        const indicator = document.getElementById('loadingIndicator');
        const progressBar = document.getElementById('loadingProgress');
        if (indicator) indicator.remove();
        if (progressBar) progressBar.remove();
      }

      function reservePlaylistSpace() {
        const topContainer = document.getElementById('topPlaylistsContainer');
        if (!topContainer) return;

        const playlistPlaceholder = document.createElement('div');
        playlistPlaceholder.className = 'playlist-loading-placeholder';
        playlistPlaceholder.id = 'playlistLoadingPlaceholder';
        playlistPlaceholder.style.cssText = `
          min-height: 200px;
          background: #f8f8f8;
          border-radius: 8px;
          margin: 10px 20px;
          display: flex;
          align-items: center;
          justify-content: center;
          color: #999;
          font-size: 14px;
        `;
        playlistPlaceholder.innerHTML = typeof i18n !== 'undefined' ? i18n.t('main.loadingPlaylists', '–ó–∞–≥—Ä—É–∑–∫–∞ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤...') : '–ó–∞–≥—Ä—É–∑–∫–∞ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤...';
        topContainer.appendChild(playlistPlaceholder);
      }

      function removePlaylistPlaceholder() {
        const placeholder = document.getElementById('playlistLoadingPlaceholder');
        if (placeholder) placeholder.remove();
      }
      
      let skeletonVisible = false;
      
      function showSkeletonLoading() {
        const grid = document.getElementById('latestGrid');
        if (!grid || skeletonVisible) return;
        
        skeletonVisible = true;

        let cols;
        if (typeof adaptiveGrid !== 'undefined') {
          cols = adaptiveGrid.getCurrentColumns('video');
        } else {
          cols = Number(localStorage.getItem('youvi_latest_cols')) || 6;
        }

        const skeletonCount = 48;
        grid.innerHTML = '';
        
        for (let i = 0; i < skeletonCount; i++) {
          const card = document.createElement('div');
          card.className = 'skeleton-card';
          card.innerHTML = `
            <div class="skeleton-thumb"></div>
            <div class="skeleton-info">
              <div class="skeleton-title"></div>
              <div class="skeleton-channel"></div>
              <div class="skeleton-views"></div>
            </div>
          `;
          grid.appendChild(card);
        }
      }

      function hideSkeletonLoading() {
        if (!skeletonVisible) return;
        
        const grid = document.getElementById('latestGrid');
        if (grid && allVideos.length > 0) {
          const skeletons = grid.querySelectorAll('.skeleton-card');
          skeletons.forEach(skeleton => skeleton.remove());
          skeletonVisible = false;
        }
      }

      async function loadAllVideosForced() {
        if (!videoDirectoryHandle) return;
        
        debug.log('‚ö†Ô∏è FORCED SCAN - bypassing cache');
        const startTime = performance.now();
        allVideos = [];
        const exts = ['.mp4','.avi','.mov','.mkv','.webm','.m4v'];
        
        const BATCH_SIZE = 100;
        let videosToSave = [];
        let createdTimestamp = Date.now();
        
        async function saveBatch() {
          if (videosToSave.length === 0) return;
          await Promise.all(videosToSave.map(v => saveVideoToDB(v)));
          videosToSave = [];
        }
        
        async function scan(dir, path = ''){
          const entries = [];
          for await (const [name, handle] of dir.entries()){
            entries.push({name, handle});
          }
          
          entries.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
          
          for (let i = 0; i < entries.length; i += BATCH_SIZE) {
            const batch = entries.slice(i, i + BATCH_SIZE);
            
            await Promise.all(batch.map(async ({name, handle}) => {
              if (handle.kind === 'file'){
                const lower = name.toLowerCase();
                if (exts.some(ext => lower.endsWith(ext))){
                  try {
                    const file = await handle.getFile();
                    const meta = await getVideoMetadata(dir, name);
                    const videoCreated = meta.created || createdTimestamp++;
                    const videoData = {
                      name, 
                      size: file.size,
                      modified: file.lastModified,
                      created: videoCreated,
                      fileCreated: meta.fileCreated || file.lastModified,
                      views: meta.views || 0,
                      likes: meta.likes || 0,
                      dislikes: meta.dislikes || 0,
                      tags: meta.tags || [],
                      quality: meta.quality || getVideoQuality({ name, size: file.size }),
                      metaModified: Date.now(),
                      ...meta
                    };
                    
                    allVideos.push({
                      ...videoData,
                      handle: handle,
                      file: file,
                      dirHandle: dir
                    });
                    
                    videosToSave.push(videoData);
                  } catch (e) {
                    debug.warn('Cannot access file:', name, e.message);
                  }
                }
              } else if (handle.kind === 'directory' && !name.startsWith('.')){
                await scan(handle, path + '/' + name);
              }
            }));
            
            if (videosToSave.length >= BATCH_SIZE) {
              await saveBatch();
            }
          }
        }
        
        await scan(videoDirectoryHandle);
        await saveBatch();
        
        const totalTime = performance.now() - startTime;
        debug.log(`‚úÖ Forced scan: ${allVideos.length} videos in ${Math.round(totalTime)}ms`);
      }

      async function validateCacheIntegrity() {
        if (!db || !videoDirectoryHandle) return;
        
        try {
          const cachedVideos = await getVideosFromDB();
          if (cachedVideos.length === 0) return;
          
          const actualFiles = new Set();
          const exts = ['.mp4','.avi','.mov','.mkv','.webm','.m4v'];

          async function quickScan(dir) {
            for await (const [name, handle] of dir.entries()) {
              if (handle.kind === 'file') {
                const lower = name.toLowerCase();
                if (exts.some(ext => lower.endsWith(ext))) {
                  actualFiles.add(name);
                }
              } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                await quickScan(handle);
              }
            }
          }
          
          await quickScan(videoDirectoryHandle);

          let staleCount = 0;
          for (const cachedVideo of cachedVideos) {
            if (!actualFiles.has(cachedVideo.name)) {
              await deleteVideoFromDB(cachedVideo.name);
              staleCount++;
            }
          }
          
          if (staleCount > 0) {
            debug.log(`Cleaned up ${staleCount} stale video entries from cache`);
          }
        } catch (e) {
          debug.warn('Error validating cache integrity:', e);
        }
      }
      

      async function getFromDB(db, key){
        if (!db || !key || typeof key !== 'string' || key.length === 0) {
          debug.warn('Invalid parameters for getFromDB:', { hasDB: !!db, key, keyType: typeof key });
          return null;
        }
        
        try {
          const tx = db.transaction('handles','readonly');
          const store = tx.objectStore('handles');
          return new Promise((resolve)=> {
            const r = store.get(key);
            r.onsuccess = ()=> resolve(r.result);
            r.onerror = (e)=> {
              debug.warn('IndexedDB get error:', e);
              resolve(null);
            };
          });
        } catch (e) {
          debug.warn('Failed to create transaction for key:', key, e);
          return null;
        }
      }
      async function saveToDB(db, key, value) {
        if (!db || !key || typeof key !== 'string' || key.length === 0) {
          debug.warn('Invalid parameters for saveToDB:', { hasDB: !!db, key, keyType: typeof key });
          return;
        }
        
        try {
          const tx = db.transaction('handles', 'readwrite');
          const store = tx.objectStore('handles');
          await store.put(value, key);
        } catch (e) {
          debug.warn('Failed to save to DB:', key, e);
        }
      }

      async function saveVideoToDB(video) {
        if (!db) {
          db = await openDB();
        }

        if (db.objectStoreNames.contains('videos')) {
          const tx = db.transaction('videos', 'readwrite');
          const store = tx.objectStore('videos');
          await store.put(video);
        }

        if (video.preview && video.name) {
          try {
            await saveToDB(db, 'preview_' + video.name, {
              preview: video.preview,
              duration: video.duration || '0:00',
              timestamp: Date.now()
            });
          } catch (e) {
            debug.warn('Failed to save preview in old format:', e);
          }
        }
      }

      async function getVideosFromDB() {
        if (!db) {
          db = await openDB();
        }
        
        const tx = db.transaction('videos', 'readonly');
        const store = tx.objectStore('videos');
        
        return new Promise((resolve) => {
          const videos = [];
          const request = store.openCursor();
          
          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              videos.push(cursor.value);
              cursor.continue();
            } else {

              debug.log(`üì¶ Retrieved ${videos.length} videos from IndexedDB cache`);
              resolve(videos);
            }
          };
          
          request.onerror = () => {
            debug.warn('Failed to read videos from IndexedDB');
            resolve([]);
          };
        });
      }

      async function getVideosByTag(tag) {
        if (!db) return [];
        try {
          const tx = db.transaction('videos', 'readonly');
          const store = tx.objectStore('videos');
          const index = store.index('tags');
          
          return new Promise((resolve) => {
            const req = index.getAll(tag);
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => resolve([]);
          });
        } catch (e) {
          debug.warn('Index query failed, falling back to full scan:', e);
          return [];
        }
      }

      async function getVideosSortedByIndex(indexName = 'created', direction = 'prev', limit = null) {
        if (!db) return [];
        try {
          const tx = db.transaction('videos', 'readonly');
          const store = tx.objectStore('videos');
          const index = store.index(indexName);
          const videos = [];
          
          return new Promise((resolve) => {
            const cursorReq = index.openCursor(null, direction);
            let count = 0;
            
            cursorReq.onsuccess = (e) => {
              const cursor = e.target.result;
              if (!cursor || (limit && count >= limit)) {
                resolve(videos);
                return;
              }
              videos.push(cursor.value);
              count++;
              cursor.continue();
            };
            cursorReq.onerror = () => resolve([]);
          });
        } catch (e) {
          debug.warn('Sorted index query failed:', e);
          return [];
        }
      }

      async function getVideosPaginated(offset = 0, limit = 48) {
        if (!db) return [];
        try {
          const tx = db.transaction('videos', 'readonly');
          const store = tx.objectStore('videos');
          const videos = [];
          let skipped = 0;
          let count = 0;
          
          return new Promise((resolve) => {
            const cursorReq = store.openCursor();
            
            cursorReq.onsuccess = (e) => {
              const cursor = e.target.result;
              if (!cursor || count >= limit) {
                resolve(videos);
                return;
              }
              
              if (skipped < offset) {
                skipped++;
                cursor.continue();
                return;
              }
              
              videos.push(cursor.value);
              count++;
              cursor.continue();
            };
            cursorReq.onerror = () => resolve([]);
          });
        } catch (e) {
          debug.warn('Paginated query failed:', e);
          return [];
        }
      }

      async function deleteVideoFromDB(videoName) {
        if (!db || !videoName) {
          debug.warn('Invalid parameters for deleteVideoFromDB:', { hasDB: !!db, videoName });
          return;
        }
        
        try {

          if (db.objectStoreNames.contains('videos')) {
            const tx = db.transaction('videos', 'readwrite');
            const store = tx.objectStore('videos');
            await store.delete(videoName);
          }

          const oldPreviewKey = 'preview_' + videoName;
          try {
            const tx2 = db.transaction('handles', 'readwrite');
            const store2 = tx2.objectStore('handles');
            await store2.delete(oldPreviewKey);
          } catch (e) {
            debug.warn('Failed to delete from handles store:', e);
          }
          
          debug.log(`Deleted cached data for removed video: ${videoName}`);
        } catch (e) {
          debug.error('Error deleting video from DB:', videoName, e);
        }
      }

      async function savePlaylistToDB(playlist) {
        const tx = db.transaction('playlists', 'readwrite');
        const store = tx.objectStore('playlists');
        await store.put(playlist);
      }

      async function getPlaylistsFromDB() {
        const tx = db.transaction('playlists', 'readonly');
        const store = tx.objectStore('playlists');
        return new Promise((resolve) => {
          const r = store.getAll();
          r.onsuccess = () => resolve(r.result);
          r.onerror = () => resolve([]);
        });
      }

      async function deletePlaylistFromDB(playlistId) {
        const tx = db.transaction('playlists', 'readwrite');
        const store = tx.objectStore('playlists');
        await store.delete(playlistId);
      }

      async function getFromDBGeneric(storeName, key) {
        if (!db || !storeName || !key || typeof key !== 'string' || key.length === 0) {
          debug.warn('Invalid parameters for getFromDBGeneric:', { hasDB: !!db, storeName, key, keyType: typeof key });
          return null;
        }
        
        try {
          if (!db.objectStoreNames.contains(storeName)) {
            debug.warn('Store does not exist:', storeName);
            return null;
          }
          
          const tx = db.transaction(storeName, 'readonly');
          const store = tx.objectStore(storeName);
          return new Promise((resolve) => {
            const r = store.get(key);
            r.onsuccess = () => resolve(r.result);
            r.onerror = (e) => {
              debug.warn('IndexedDB getFromDBGeneric error:', e);
              resolve(null);
            };
          });
        } catch (e) {
          debug.warn('Failed to create transaction for store/key:', storeName, key, e);
          return null;
        }
      }

      async function readJSONFile(dirHandle, fileName, def=null){
        try{
          const fh = await dirHandle.getFileHandle(fileName);
          const f = await fh.getFile();
          return JSON.parse(await f.text());
        }catch(e){ return def; }
      }
      async function writeJSONFile(dirHandle, fileName, data){
        const fh = await dirHandle.getFileHandle(fileName, { create:true });
        const w = await fh.createWritable();
        await w.write(JSON.stringify(data, null, 2));
        await w.close();
      }

      async function getVideoMetadata(dirHandle, fileName){
        try{
          const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create:true });
          const metaHandle = await metaDir.getFileHandle(fileName + '.meta.json');
          const file = await metaHandle.getFile();
          const metadata = JSON.parse(await file.text());
          return metadata;
        }catch(e){

          if (pendingMetadataCreation.has(fileName)) {
            debug.log(`[GetMetadata] ‚è≥ Creation pending for: ${fileName}`);

            return { views: 0, likes: 0, dislikes: 0, tags: [], created: Date.now(), _temporary: true };
          }

          try {
            const fileHandle = await dirHandle.getFileHandle(fileName);
            const file = await fileHandle.getFile();
            const newMetadata = { 
              views:0, 
              likes:0, 
              dislikes:0, 
              tags:[], 
              created: Date.now(),
              fileCreated: file.lastModified,
              modified: file.lastModified, 
              size: file.size 
            };

            pendingMetadataCreation.add(fileName);

            try {
              const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
              const metaFileName = fileName + '.meta.json';

              try {
                const existingHandle = await metaDir.getFileHandle(metaFileName);
                const existingFile = await existingHandle.getFile();
                const existingMeta = JSON.parse(await existingFile.text());

                if (existingMeta) {
                  debug.log(`[GetMetadata] ‚ö†Ô∏è Metadata appeared for ${fileName}, using existing`);
                  pendingMetadataCreation.delete(fileName);
                  return existingMeta;
                }
              } catch (readErr) {

              }
              
              await writeJSONFile(metaDir, metaFileName, newMetadata);
              debug.log(`[GetMetadata] ‚úÖ Created new metadata for ${fileName}`);
            } catch (saveError) {
              debug.warn('Could not save new metadata for', fileName);
            } finally {
              pendingMetadataCreation.delete(fileName);
            }
            
            return newMetadata;
          } catch(_) {

            debug.warn(`[GetMetadata] ‚ö†Ô∏è Cannot access video file ${fileName}, returning temporary metadata`);
            const fallbackMetadata = { views:0, likes:0, dislikes:0, tags:[], created:Date.now(), _temporary: true };

            return fallbackMetadata;
          }
        }
      }

// Batch danmaku count loader - uses shared module
let danmakuCountsLoaded = false;

async function loadAllDanmakuCounts() {
  if (danmakuCountsLoaded || !videoDirectoryHandle || !allVideos.length) return;
  
  if (window.DanmakuCounter) {
    const counts = await window.DanmakuCounter.load(videoDirectoryHandle, allVideos);
    window.DanmakuCounter.updateUI();
    danmakuCountsLoaded = true;
    debug.log(`‚úÖ Danmaku counts: ${counts.size} files found`);
  }
}

const metadataWriteLocks = new Map();

const pendingMetadataCreation = new Set();

async function getVideoMetadataOptimized(dirHandle, fileName, cache) {
  const cacheKey = `${dirHandle.name || 'root'}/${fileName}`;

  if (cache && cache.has(cacheKey)) {
    const cached = cache.get(cacheKey);

    if (cached._cacheTime && (Date.now() - cached._cacheTime < 300000)) {
      return cached;
    }
  }
  
  try {
    const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
    const metaHandle = await metaDir.getFileHandle(fileName + '.meta.json');
    const file = await metaHandle.getFile();
    const metadata = JSON.parse(await file.text());

    if (cache) {
      metadata._cacheTime = Date.now();
      cache.set(cacheKey, metadata);
    }
    
    return metadata;
  } catch (e) {

    if (cache && cache.has(cacheKey)) {
      const cached = cache.get(cacheKey);
      if (cached._cacheTime) {
        return cached;
      }
    }

    if (pendingMetadataCreation.has(fileName)) {
      debug.log(`[MetadataOptimized] ‚è≥ Waiting for pending creation: ${fileName}`);

      await new Promise(resolve => setTimeout(resolve, 100));
      if (cache && cache.has(cacheKey)) {
        return cache.get(cacheKey);
      }

      return { views: 0, likes: 0, dislikes: 0, tags: [], created: Date.now(), _temporary: true };
    }

    try {
      const fileHandle = await dirHandle.getFileHandle(fileName);
      const file = await fileHandle.getFile();
      const newMetadata = { 
        views: 0, 
        likes: 0, 
        dislikes: 0, 
        tags: [], 
        created: Date.now(),
        fileCreated: file.lastModified,
        modified: file.lastModified, 
        size: file.size 
      };
      
      if (cache) {
        newMetadata._cacheTime = Date.now();
        cache.set(cacheKey, newMetadata);
      }
      
      pendingMetadataCreation.add(fileName);
      
      setTimeout(async () => {
        try {
          
          const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
          const metaFileName = fileName + '.meta.json';

          try {
            const existingHandle = await metaDir.getFileHandle(metaFileName);
            const existingFile = await existingHandle.getFile();
            const existingMeta = JSON.parse(await existingFile.text());
            
            if (existingMeta && (existingMeta.tags?.length > 0 || existingMeta.views > 0)) {
              debug.log(`[MetadataOptimized] ‚ö†Ô∏è Metadata already exists for ${fileName}, skipping write`);
              if (cache) {
                existingMeta._cacheTime = Date.now();
                cache.set(cacheKey, existingMeta);
              }
              return;
            }
          } catch (readErr) {

          }
          
          await writeJSONFile(metaDir, metaFileName, newMetadata);
          debug.log(`[MetadataOptimized] ‚úÖ Created new metadata for ${fileName}`);
        } catch (saveError) {
          debug.warn('Could not save new metadata for', fileName, saveError);
        } finally {
          pendingMetadataCreation.delete(fileName);
        }
      }, 0);
      
      return newMetadata;
    } catch (_) {
      
      debug.warn(`[MetadataOptimized] ‚ö†Ô∏è Cannot access video file ${fileName}, returning temporary metadata`);
      
      const fallbackMetadata = { views: 0, likes: 0, dislikes: 0, tags: [], created: Date.now(), _temporary: true };
    
      return fallbackMetadata;
    }
  }
}

async function saveVideoMetadata(dirHandle, fileName, metadata) {
  try {

    const lockKey = `${dirHandle.name || 'root'}/${fileName}`;

    if (metadataWriteLocks.has(lockKey)) {
      debug.log(`[SaveMetadata] ‚è≥ Waiting for lock: ${fileName}`);
      await metadataWriteLocks.get(lockKey);
    }

    let releaseLock;
    const lockPromise = new Promise(resolve => { releaseLock = resolve; });
    metadataWriteLocks.set(lockKey, lockPromise);
    
    try {

      const existingMeta = await getVideoMetadata(dirHandle, fileName);
      
      let finalTags = metadata.tags;
      if ((!metadata.tags || metadata.tags.length === 0) && existingMeta.tags && existingMeta.tags.length > 0) {
        debug.warn(`[SaveMetadata] ‚ö†Ô∏è Preventing tag loss for ${fileName}: keeping ${existingMeta.tags.length} existing tags`);
        finalTags = existingMeta.tags;
      }
      
      const safeMeta = {
        ...existingMeta,
        ...metadata,
        views: Math.max(existingMeta.views || 0, metadata.views || 0),
        quality: metadata.quality || existingMeta.quality,
        tags: finalTags || existingMeta.tags || [],

        created: existingMeta.created || metadata.created || Date.now(),
        fileCreated: existingMeta.fileCreated || metadata.fileCreated
      };
      
      if (existingMeta.tags && metadata.tags && metadata.tags.length < existingMeta.tags.length) {
        debug.warn(`[SaveMetadata] ‚ö†Ô∏è Tags reduced for ${fileName}: ${existingMeta.tags.length} -> ${metadata.tags.length}`);
      }
      
      const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
      const metaFileName = fileName + '.meta.json';
      await writeJSONFile(metaDir, metaFileName, safeMeta);
      
      if (typeof globalMetadataCache !== 'undefined' && globalMetadataCache) {
        safeMeta._cacheTime = Date.now();
        globalMetadataCache.set(lockKey, safeMeta);
      }
      
    } finally {

      metadataWriteLocks.delete(lockKey);
      releaseLock();
    }
  } catch (e) {
    debug.error('Error saving video metadata:', e);
  }
}

      async function preloadMetadataForVideos(videos) {
        const CHUNK_SIZE = 5;
        let processed = 0;
        
        for (let i = 0; i < videos.length; i += CHUNK_SIZE) {
          const chunk = videos.slice(i, i + CHUNK_SIZE);
          
          const metadataPromises = chunk.map(async (video) => {
            try {
              const dirHandle = video.dirHandle || videoDirectoryHandle;
              const meta = await getVideoMetadataOptimized(dirHandle, video.name, globalMetadataCache);

              video._preloadedMeta = meta;
              return meta;
            } catch (e) {
              debug.warn(`Failed to preload metadata for ${video.name}:`, e);
              return null;
            }
          });
          
          await Promise.all(metadataPromises);
          processed += chunk.length;

          if (i + CHUNK_SIZE < videos.length) {
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
        
        debug.log(`‚úÖ Preloaded metadata for ${processed} videos (chunked)`);
      }
      
      async function getPreviewAndDuration(video){

        if (video._cachedPreview && video._cachedDuration) {
          debug.log(`Using memory cache for: ${video.name}`);
          return { preview: video._cachedPreview, duration: video._cachedDuration };
        }
        
        if (video.preview && video.preview.length > 50 && video.duration) {
          debug.log(`Using video object preview for: ${video.name}`);
          video._cachedPreview = video.preview;
          video._cachedDuration = video.duration;
          return { preview: video.preview, duration: video.duration };
        }

        debug.log(`getPreviewAndDuration called for: ${video.name}`, {
          hasFile: !!video.file,
          hasHandle: !!video.handle,
          hasDirHandle: !!video.dirHandle
        });
        
        const dirHandle = video.dirHandle || videoDirectoryHandle;

        const meta = video._preloadedMeta || await getVideoMetadataOptimized(dirHandle, video.name, globalMetadataCache);

        const fileChanged = video.file ? (meta.size !== video.file.size || meta.modified !== video.file.lastModified) : false;

        if (meta.preview && meta.duration && !fileChanged) {
          debug.log(`Using cached preview for: ${video.name}`);

          video._cachedPreview = meta.preview;
          video._cachedDuration = meta.duration;
          return { preview: meta.preview, duration: meta.duration };
        }

        try {
          if (!db) {
            db = await openDB();
          }

          if (db.objectStoreNames.contains('videos')) {
            const cachedVideo = await getFromDBGeneric('videos', video.name);
            if (cachedVideo && cachedVideo.preview && !fileChanged) {
              debug.log(`Using IndexedDB (videos) cached preview for: ${video.name}`);
              video._cachedPreview = cachedVideo.preview;
              video._cachedDuration = cachedVideo.duration;
              return { preview: cachedVideo.preview, duration: cachedVideo.duration };
            }
          }

          if (video.name && typeof video.name === 'string' && video.name.length > 0) {
            const oldCacheKey = 'preview_' + video.name;
            const cachedPreview = await getFromDB(db, oldCacheKey);
            if (cachedPreview && cachedPreview.preview && !fileChanged) {
              debug.log(`Using IndexedDB (handles) cached preview for: ${video.name}`);
              video._cachedPreview = cachedPreview.preview;
              video._cachedDuration = cachedPreview.duration || '0:00';
              return { preview: cachedPreview.preview, duration: cachedPreview.duration || '0:00' };
            }
          }
        } catch (e) {
          debug.warn('Failed to get from IndexedDB cache:', e);
        }

        if (!video.file) {
          debug.warn('No file available for video:', video.name);
          return { preview: '', duration: '0:00' };
        }

        return new Promise((resolve, reject) => {
          const el = document.createElement('video');
          el.muted = true;
          el.playsInline = true;
          el.preload = 'metadata';
          el.crossOrigin = 'anonymous';
          
          const url = URL.createObjectURL(video.file);
          
          const cleanup = () => {
            URL.revokeObjectURL(url);
            el.remove();
          };
          
          const timeout = setTimeout(() => {
            cleanup();
            debug.warn(`Timeout generating preview for ${video.name}`);
            resolve({ preview: null, duration: '0:00' });
          }, 10000);
          
          el.addEventListener('error', (e) => {
            clearTimeout(timeout);
            cleanup();
            debug.warn(`Video loading error for ${video.name}:`, e);
            resolve({ preview: null, duration: '0:00' });
          }, { once: true });
          
          el.addEventListener('loadedmetadata', async () => {
            try {
              if (!isFinite(el.duration) || el.duration <= 0) {
                clearTimeout(timeout);
                cleanup();
                debug.warn(`Invalid duration for ${video.name}:`, el.duration);
                resolve({ preview: null, duration: '0:00' });
                return;
              }
              
              const duration = formatDuration(el.duration);
              el.currentTime = Math.max(0, el.duration / 2);
              
              el.addEventListener('seeked', async () => {
                try {
                  const canvas = document.createElement('canvas');
                  canvas.width = 240; canvas.height = 140;
                  const ctx = canvas.getContext('2d');
                  
                  if (el.videoWidth === 0 || el.videoHeight === 0) {
                    throw new Error('Invalid video dimensions');
                  }
                  
                  ctx.drawImage(el, 0, 0, canvas.width, canvas.height);

                  let preview;
                  try {
                    preview = canvas.toDataURL('image/webp', 0.8);

                    if (!preview || preview === 'data:,' || preview.length < 50) {
                      throw new Error('Empty preview data');
                    }
                  } catch (e) {

                    try {
                      preview = canvas.toDataURL('image/jpeg', 0.7);
                      if (!preview || preview === 'data:,' || preview.length < 50) {
                        throw new Error('Empty JPEG preview data');
                      }
                    } catch (jpegError) {
                      debug.error('Failed to generate both WebP and JPEG previews:', jpegError);
                      preview = null;
                    }
                  }
                  
                  clearTimeout(timeout);
                  cleanup();
                  
                  if (preview && preview !== null) {

                    const updatedMeta = {
                      ...meta,
                      preview: preview,
                      duration: duration,
                      size: video.file.size,
                      modified: video.file.lastModified,
                      compressed: preview.includes('image/webp')
                    };
                    saveVideoMetadata(dirHandle, video.name, updatedMeta).catch(debug.error);
                    await saveVideoToDB({ ...video, preview, duration, compressed: preview.includes('image/webp') });

                    video._cachedPreview = preview;
                    video._cachedDuration = duration;
                    
                    debug.log(`Successfully generated preview for: ${video.name}`);
                    resolve({ preview, duration });
                  } else {
                    debug.warn(`Failed to generate valid preview for: ${video.name}`);
                    resolve({ preview: null, duration });
                  }
                } catch (e) {
                  clearTimeout(timeout);
                  cleanup();
                  debug.error(`Error generating preview for ${video.name}:`, e);
                  resolve({ preview: null, duration: '0:00' });
                }
              }, { once: true });
              
              el.addEventListener('error', (e) => {
                clearTimeout(timeout);
                cleanup();
                debug.warn(`Seek error for ${video.name}:`, e);
                resolve({ preview: null, duration: '0:00' });
              }, { once: true });
              
            } catch (e) {
              clearTimeout(timeout);
              cleanup();
              debug.error(`Error in loadedmetadata for ${video.name}:`, e);
              resolve({ preview: null, duration: '0:00' });
            }
          }, { once: true });
          
          el.src = url;
        });
      }

      class TaskQueue {
        constructor(concurrency = 4) {
          this.concurrency = concurrency;
          this.running = 0;
          this.queue = [];
          this.priorityQueue = [];
          this.isProcessing = false;
          this.pendingTaskIds = new Set();
        }
        
        add(task, priority = 0, taskId = null) {

          if (taskId && this.pendingTaskIds.has(taskId)) {
            debug.log(`‚ö†Ô∏è Skipping duplicate task: ${taskId}`);
            return;
          }
          
          const taskWrapper = { task, priority, id: taskId || (Date.now() + Math.random()), taskId };
          
          if (taskId) {
            this.pendingTaskIds.add(taskId);
          }
          
          if (priority > 0) {
            this.priorityQueue.push(taskWrapper);
            this.priorityQueue.sort((a, b) => b.priority - a.priority);
          } else {
            this.queue.push(taskWrapper);
          }
          
          this.process();
        }
        
        async process() {

          while (this.running < this.concurrency && (this.priorityQueue.length > 0 || this.queue.length > 0)) {
            this.running++;
            
            let taskWrapper;
            if (this.priorityQueue.length > 0) {
              taskWrapper = this.priorityQueue.shift();
            } else {
              taskWrapper = this.queue.shift();
            }
            
            if (taskWrapper) {

              this.runTask(taskWrapper);
            } else {
              this.running--;
            }
          }
        }
        
        async runTask(taskWrapper) {
          try {
            await taskWrapper.task();
          } catch (error) {
            debug.error('Task execution error:', error);
          } finally {
            this.running--;

            if (taskWrapper.taskId) {
              this.pendingTaskIds.delete(taskWrapper.taskId);
            }

            setTimeout(() => this.process(), 0);
          }
        }

        clear() {
          this.queue = [];
          this.priorityQueue = [];
          this.pendingTaskIds.clear();
          debug.log('TaskQueue cleared');
        }
        
        getStats() {
          return {
            running: this.running,
            queued: this.queue.length,
            priorityQueued: this.priorityQueue.length,
            pending: this.pendingTaskIds.size
          };
        }
      }

      const taskQueue = new TaskQueue(4);

      const avatarLoadManager = {
        pending: new Map(),
        processing: false,
        batchTimer: null,
        batchDelay: 16,
        cache: new Map(),
        
        load(channelName, avatarId) {
          if (!channelName) return;

          if (this.cache.has(channelName)) {
            const cachedUrl = this.cache.get(channelName);

            if (cachedUrl) {

              requestAnimationFrame(() => {
                this.applyAvatar(avatarId, cachedUrl);
              });
            }
            return;
          }

          if (!this.pending.has(channelName)) {
            this.pending.set(channelName, []);
          }

          const existingIds = this.pending.get(channelName);
          if (!existingIds.includes(avatarId)) {
            existingIds.push(avatarId);
          }

          this.scheduleBatch();
        },
        
        scheduleBatch() {
          if (this.batchTimer) {
            clearTimeout(this.batchTimer);
          }
          
          this.batchTimer = setTimeout(() => {
            this.processBatch();
          }, this.batchDelay);
        },
        
        async processBatch() {
          if (this.processing || this.pending.size === 0) {
            return;
          }
          
          this.processing = true;
          const batch = Array.from(this.pending.entries());
          this.pending.clear();

          const PARALLEL_LIMIT = 12;
          for (let i = 0; i < batch.length; i += PARALLEL_LIMIT) {
            const chunk = batch.slice(i, i + PARALLEL_LIMIT);
            await Promise.all(chunk.map(async ([channelName, avatarIds]) => {
              try {
                if (typeof loadChannelAvatar === 'undefined') return;
                
                const avatarUrl = await loadChannelAvatar(channelName, videoDirectoryHandle);

                this.cache.set(channelName, avatarUrl);

                const existingIds = avatarIds.filter(id => document.getElementById(id));
                
                if (existingIds.length === 0) return;

                existingIds.forEach(id => this.applyAvatar(id, avatarUrl));
              } catch (err) {
                debug.error('Avatar load error:', channelName, err);
              }
            }));
          }
          
          this.processing = false;

          if (this.pending.size > 0) {
            this.scheduleBatch();
          }
        },
        
        applyAvatar(avatarId, avatarUrl) {
          if (!avatarUrl) return;
          
          const avatarEl = document.getElementById(avatarId);
          if (!avatarEl) return;

          avatarEl.style.backgroundImage = `url(${avatarUrl})`;
          avatarEl.classList.add('custom-avatar');
          avatarEl.textContent = '';
        },
        
        clearCache() {
          this.cache.clear();
        },

        clearPending() {
          if (this.batchTimer) {
            clearTimeout(this.batchTimer);
            this.batchTimer = null;
          }
          this.pending.clear();
        },

        reapplyAllCached() {
          document.querySelectorAll('.video-card-avatar[id]').forEach(el => {
            const id = el.id;

            const link = el.closest('a');
            if (link && link.href) {
              const match = link.href.match(/channel=([^&]+)/);
              if (match) {
                const channelName = decodeURIComponent(match[1]);
                if (this.cache.has(channelName)) {
                  const url = this.cache.get(channelName);
                  if (url) {
                    el.style.backgroundImage = `url(${url})`;
                    el.classList.add('custom-avatar');
                    el.textContent = '';
                  }
                }
              }
            }
          });
        }
      };

      let previewObserver = null;
      const observedThumbnails = new WeakSet();

      function resetPreviewObserver() {
        if (previewObserver) {
          previewObserver.disconnect();
          previewObserver = null;
          debug.log('[PreviewObserver] Disconnected and reset');
        }
      }
      
      function initPreviewObserver() {
        if (previewObserver) return previewObserver;
        
        previewObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting && entry.intersectionRatio > 0) {
              const thumb = entry.target;
              const videoName = thumb.dataset.videoName;
              
              if (!videoName || thumb.dataset.previewLoaded === 'true') return;

              const video = allVideos.find(v => v.name === videoName);


              if (video) {

                thumb.dataset.previewLoaded = 'true';

                const priority = entry.intersectionRatio > 0.5 ? 10 : 5;
                taskQueue.add(async () => {
                  try {
                    await loadVideoPreviewImmediately(video, thumb);
                  } catch (e) {
                    debug.error('Preview load failed:', video.name, e);

                    thumb.dataset.previewLoaded = 'false';
                  }
                }, priority);

                previewObserver.unobserve(thumb);
              }

            }
          });
        }, {
          rootMargin: '400px',
          threshold: [0.01, 0.5]
        });
        
        return previewObserver;
      }

      async function parallelLimit(tasks, limit = 2) {
        const results = [];
        const executing = new Set();
        
        for (const task of tasks) {
          const p = Promise.resolve().then(() => task());
          results.push(p);
          executing.add(p);
          p.finally(() => executing.delete(p));
          
          if (executing.size >= limit) {
            await Promise.race(executing);
            await new Promise(resolve => setTimeout(resolve, 50));
          }
        }
        return Promise.all(results);
      }

      async function loadAllPlaylists(){
          const startTime = performance.now();
          debug.log('Loading all playlists (optimized v3 - cache-first)...');
          allPlaylists.length = 0;
          
          // O(1) video lookup instead of O(n) find() calls
          const videoMap = new Map(allVideos.map(v => [v.name, v]));
          
          const cachedPlaylists = await getPlaylistsFromDB();
          debug.log(`Cache has ${cachedPlaylists.length} playlists`);
          
          // Helper: merge video with O(1) lookup
          function mergeVideo(video) {
            const foundVideo = videoMap.get(video.name);
            if (!foundVideo) return null;
            return { 
              ...foundVideo,
              ...video,
              handle: foundVideo.handle, 
              file: foundVideo.file, 
              dirHandle: foundVideo.dirHandle,
              views: foundVideo.views || video.views || 0,
              created: foundVideo.created || video.created || foundVideo.modified || 0,
              tags: foundVideo.tags || video.tags || [],
              quality: foundVideo.quality || video.quality
            };
          }

          // Helper: process playlist videos
          function processPlaylistVideos(videos) {
            return (videos || []).map(mergeVideo).filter(v => v !== null);
          }

          // FAST PATH: If we have cached playlists, use them immediately
          const lastPlaylistScan = localStorage.getItem('lastPlaylistScan');
          const PLAYLIST_CACHE_TTL = 5 * 60 * 1000; // 5 minutes
          const cacheIsValid = cachedPlaylists.length > 0 && lastPlaylistScan && 
                              (Date.now() - parseInt(lastPlaylistScan)) < PLAYLIST_CACHE_TTL;
          
          if (cacheIsValid) {
            debug.log('‚úÖ Using cached playlists (fast path)');
            
            // Quickly hydrate cached playlists with video handles
            for (const cachedPl of cachedPlaylists) {
              const videosWithHandles = processPlaylistVideos(cachedPl.videos);
              allPlaylists.push({
                ...cachedPl,
                videos: videosWithHandles
              });
            }
            
            allPlaylistsComplete = [...allPlaylists];
            allPlaylists = allPlaylists.filter(playlist => (playlist.videos?.length || 0) >= 6);
            allPlaylists.sort((a,b) => (b.created || 0) - (a.created || 0));
            
            debug.log(`‚úÖ Fast path: ${allPlaylists.length} playlists ready in ${Math.round(performance.now() - startTime)}ms`);
            
            // Schedule background refresh
            setTimeout(() => loadAllPlaylistsFull(videoMap, processPlaylistVideos), 100);
            return;
          }
          
          // SLOW PATH: Full scan needed
          await loadAllPlaylistsFull(videoMap, processPlaylistVideos);
          
          const totalTime = Math.round(performance.now() - startTime);
          debug.log(`‚úÖ Playlists loaded: ${allPlaylists.length} (${allPlaylistsComplete.length} total) in ${totalTime}ms`);
        }
        
      async function loadAllPlaylistsFull(videoMap, processPlaylistVideos) {
          const startTime = performance.now();
          debug.log('üîÑ Full playlist scan starting...');
          
          const cachedPlaylists = await getPlaylistsFromDB();
          const playlistMap = new Map(cachedPlaylists.map(pl => [pl.id, pl]));
          const currentPlaylistIds = new Set();
          const playlistsToSave = [];
          const newPlaylists = [];

          try{
            const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create:true });
            
            // Collect all channel entries first
            const channelEntries = [];
            for await (const [name, handle] of channelsDir.entries()){
              if (handle.kind === 'directory') channelEntries.push({ name, handle });
            }
            
            debug.log(`Found ${channelEntries.length} channels, loading in parallel...`);
            
            // Process ALL channels in parallel
            const channelResults = await Promise.all(channelEntries.map(async ({ name, handle }) => {
              const channelData = await readJSONFile(handle, 'channel.json', { playlists: [] });
              const playlists = [];
              for (const pl of (channelData.playlists || [])) {
                const playlistId = pl.id;
                const cachedPlaylist = playlistMap.get(playlistId);
                
                const needsUpdate = !cachedPlaylist || 
                    cachedPlaylist.title !== pl.title ||
                    (cachedPlaylist.videos?.length || 0) !== (pl.videos?.length || 0);

                const sourceVideos = needsUpdate ? pl.videos : cachedPlaylist.videos;
                const videosWithHandles = processPlaylistVideos(sourceVideos);
                
                playlists.push({
                  playlist: { 
                    ...(needsUpdate ? pl : cachedPlaylist), 
                    videos: videosWithHandles, 
                    channelName: name, 
                    channelHandle: handle, 
                    isChannelPlaylist: true 
                  },
                  playlistId,
                  needsSave: needsUpdate || videosWithHandles.length !== (sourceVideos?.length || 0),
                  videosWithHandles
                });
              }
              return playlists;
            }));
            
            // Flatten and process results
            for (const channelPlaylists of channelResults) {
              for (const { playlist, playlistId, needsSave, videosWithHandles } of channelPlaylists) {
                currentPlaylistIds.add(playlistId);
                newPlaylists.push(playlist);
                if (needsSave) {
                  playlistsToSave.push({ 
                    ...playlist, 
                    handle: null, 
                    dirHandle: null, 
                    channelHandle: null,
                    videos: videosWithHandles.map(v => ({ name: v.name, tags: v.tags })) 
                  });
                }
              }
            }
            
            // Process global playlists
            const globalPlaylists = await readJSONFile(videoDirectoryHandle, '.global_playlists.json', []);
            for (const pl of (globalPlaylists || [])) {
              const playlistId = pl.id;
              currentPlaylistIds.add(playlistId);
              const cachedPlaylist = playlistMap.get(playlistId);
              
              const needsUpdate = !cachedPlaylist || 
                  cachedPlaylist.title !== pl.title ||
                  (cachedPlaylist.videos?.length || 0) !== (pl.videos?.length || 0);

              const sourceVideos = needsUpdate ? pl.videos : cachedPlaylist.videos;
              const videosWithHandles = processPlaylistVideos(sourceVideos);
              
              const playlistToPush = { 
                ...(needsUpdate ? pl : cachedPlaylist), 
                videos: videosWithHandles, 
                channelName: null, 
                isChannelPlaylist: false 
              };
              
              if (needsUpdate || videosWithHandles.length !== (sourceVideos?.length || 0)) {
                playlistsToSave.push({ 
                  ...playlistToPush, 
                  handle: null, 
                  dirHandle: null, 
                  videos: videosWithHandles.map(v => ({ name: v.name, tags: v.tags })) 
                });
              }
              
              newPlaylists.push(playlistToPush);
            }

            // Batch save all playlists and delete stale ones in parallel
            const deletePromises = cachedPlaylists
              .filter(cp => !currentPlaylistIds.has(cp.id))
              .map(cp => deletePlaylistFromDB(cp.id));
            
            await Promise.all([
              ...playlistsToSave.map(pl => savePlaylistToDB(pl)),
              ...deletePromises
            ]);
            
            // Update cache timestamp
            localStorage.setItem('lastPlaylistScan', Date.now().toString());

            // Update global arrays
            allPlaylists.length = 0;
            allPlaylists.push(...newPlaylists);
            allPlaylistsComplete = [...allPlaylists];

            allPlaylists = allPlaylists.filter(playlist => (playlist.videos?.length || 0) >= 6);
            allPlaylists.sort((a,b) => (b.created || 0) - (a.created || 0));

            debug.log(`‚úÖ Full scan complete: ${allPlaylists.length} playlists in ${Math.round(performance.now() - startTime)}ms`);
            
            // Re-render if we were using cached data
            if (typeof applyFiltersAndRender === 'function') {
              applyFiltersAndRender();
            }
          }catch(e){
            debug.error('loadAllPlaylistsFull error', e);
          }
        }

async function loadAllVideosProgressive(){
  debug.log('‚úÖ Starting progressive loadAllVideos...');
  const startTime = performance.now();
  allVideos = [];
  const exts = ['.mp4','.avi','.mov','.mkv','.webm','.m4v'];
  
  if (!videoDirectoryHandle) {
    debug.error('No videoDirectoryHandle available');
    return;
  }

  const cachedVideos = await getVideosFromDB();
  debug.log(`‚úÖ Loaded ${cachedVideos.length} videos from cache in ${Math.round(performance.now() - startTime)}ms`);
  
  const videoMap = new Map(cachedVideos.map(v => [v.name, v]));
  const currentVideoNames = new Set();

  const BATCH_SIZE = 100;
  let videosToSave = [];
  let processedCount = 0;

  const metadataCache = globalMetadataCache;
  let createdTimestamp = Date.now();

  if (cachedVideos.length > 0) {

    const seenNames = new Set();
    const deduplicatedCache = [];
    for (const v of cachedVideos) {
      if (!seenNames.has(v.name)) {
        seenNames.add(v.name);
        deduplicatedCache.push({
          ...v,

          handle: null,
          file: null,
          dirHandle: null
        });
      }
    }
    
    allVideos = deduplicatedCache;
    debug.log(`‚úÖ ${allVideos.length} videos ready for display (removed ${cachedVideos.length - deduplicatedCache.length} duplicates from cache)`);

    applyFiltersAndRender();

    const lastScanTime = localStorage.getItem('lastVideoScan');
    const currentTime = Date.now();
    const SCAN_INTERVAL = 5 * 60 * 1000;
    
    const shouldScan = !lastScanTime || (currentTime - parseInt(lastScanTime)) > SCAN_INTERVAL;
    
    if (shouldScan) {
      debug.log('üîÑ Starting background verification scan (cache is old)...');
      localStorage.setItem('lastVideoScan', currentTime.toString());



      setTimeout(async () => {

      if (document.hidden) {
        debug.log('‚è∏Ô∏è Tab hidden, deferring background scan...');
        return;
      }
      debug.log('üîÑ Starting background verification scan after grace period...');
      const scanStart = performance.now();
      
      const oldCount = allVideos.length;
      const tempVideos = [];
      const tempVideosToSave = [];
      let tempCreatedTimestamp = Date.now();

      async function fullScan(dir, path = '') {
        const entries = [];
        for await (const [name, handle] of dir.entries()) {
          entries.push({name, handle});
        }
        
        entries.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
        
        const totalEntries = entries.length;
        for (let i = 0; i < entries.length; i += BATCH_SIZE) {
          const batch = entries.slice(i, i + BATCH_SIZE);

          const progress = Math.round((i + batch.length) / totalEntries * 100);
          debug.log(`üîÑ Background scan progress: ${progress}% (${i + batch.length}/${totalEntries} files processed)`);

          if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 5));
          }
          
          await Promise.all(batch.map(async ({name, handle}) => {
            if (handle.kind === 'file') {
              const lower = name.toLowerCase();
              if (['.mp4','.avi','.mov','.mkv','.webm','.m4v'].some(ext => lower.endsWith(ext))) {
                try {
                  const file = await handle.getFile();
                  const cachedVideo = videoMap.get(name);


                  const hasMetadata = cachedVideo && cachedVideo.metaModified;
                  const shouldRefresh = !cachedVideo || cachedVideo.modified !== file.lastModified || !hasMetadata;
                  
                  if (shouldRefresh) {
                    const meta = await getVideoMetadataOptimized(dir, name, metadataCache);
                    const videoCreated = meta.created || (cachedVideo?.created) || tempCreatedTimestamp++;
                    const videoData = {
                      name,
                      size: file.size,
                      modified: file.lastModified,
                      created: videoCreated,
                      fileCreated: meta.fileCreated || file.lastModified,
                      views: meta.views || 0,
                      likes: meta.likes || 0,
                      dislikes: meta.dislikes || 0,
                      tags: meta.tags || [],
                      quality: meta.quality || getVideoQuality({ name, size: file.size }),
                      metaModified: Date.now(),
                      ...meta
                    };
                    
                    tempVideos.push({
                      ...videoData,
                      handle: handle,
                      file: file,
                      dirHandle: dir
                    });
                    
                    tempVideosToSave.push(videoData);
                  } else {
                    tempVideos.push({
                      ...cachedVideo,
                      handle: handle,
                      file: file,
                      dirHandle: dir
                    });
                  }
                } catch (e) {
                  debug.warn('Cannot access file:', name);
                }
              }
            } else if (handle.kind === 'directory' && !name.startsWith('.')) {
              await fullScan(handle, path + '/' + name);
            }
          }));

          if (tempVideosToSave.length >= BATCH_SIZE) {
            await Promise.all(tempVideosToSave.map(v => saveVideoToDB(v)));
            tempVideosToSave.length = 0;
          }
        }
      }
      
      await fullScan(videoDirectoryHandle);

      if (tempVideosToSave.length > 0) {
        await Promise.all(tempVideosToSave.map(v => saveVideoToDB(v)));
      }

      const seenNames = new Set();
      const deduplicatedVideos = [];
      for (const video of tempVideos) {
        if (!seenNames.has(video.name)) {
          seenNames.add(video.name);
          deduplicatedVideos.push(video);
        }
      }

      allVideos = deduplicatedVideos;
      
      debug.log(`‚úÖ Background scan completed in ${Math.round(performance.now() - scanStart)}ms`);
      debug.log(`üìä Total videos: ${allVideos.length} (was ${oldCount} in cache, removed ${tempVideos.length - deduplicatedVideos.length} duplicates)`);


      localStorage.setItem('lastVideoScan', currentTime.toString());
      debug.log('‚úÖ Background scan completed silently, cache updated');

      requestIdleCallback(() => {
        const failedThumbnails = document.querySelectorAll('.video-thumbnail[data-preview-loaded="false"], .video-thumbnail:not([data-preview-loaded])');
        debug.log(`üîÑ Retrying ${failedThumbnails.length} failed preview loads after background scan`);
        
        failedThumbnails.forEach(thumb => {
          const videoName = thumb.dataset.videoName;
          if (!videoName) return;
          
          const video = allVideos.find(v => v.name === videoName);
          if (video && video.file && video.handle) {

            thumb.dataset.previewLoaded = 'false';
            if (previewObserver) {
              previewObserver.observe(thumb);
            }
          }
        });
      });
    }, 5000);
    } else {
      debug.log('‚ö° Skipping background scan - cache is fresh (less than 5 minutes old)');
    }
  } else {

    showSkeletonLoading();

    await scan(videoDirectoryHandle);
    await saveBatch();
    
    debug.log(`‚úÖ Initial scan completed: ${allVideos.length} videos`);

    applyFiltersAndRender();
  }
  
  
  async function saveBatch() {
    if (videosToSave.length === 0) return;
    await Promise.all(videosToSave.map(v => saveVideoToDB(v)));
    videosToSave = [];
  }

  async function scan(dir, path = ''){
    const entries = [];
    for await (const [name, handle] of dir.entries()){
      entries.push({name, handle});
    }

    entries.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));

    const totalEntries = entries.length;
    for (let i = 0; i < entries.length; i += BATCH_SIZE) {
      const batch = entries.slice(i, i + BATCH_SIZE);

      const progress = Math.round((i + batch.length) / totalEntries * 100);
      if (i % (BATCH_SIZE * 5) === 0) {
        debug.log(`üìä Scan progress: ${progress}% (${i + batch.length}/${totalEntries} files)`);
      }

      if (i > 0) {
        await new Promise(resolve => setTimeout(resolve, 3));
      }
      
      await Promise.all(batch.map(async ({name, handle}) => {
        if (handle.kind === 'file'){
          const lower = name.toLowerCase();
          if (exts.some(ext => lower.endsWith(ext))){
            currentVideoNames.add(name);
            
            try {
              const file = await handle.getFile();
              const cachedVideo = videoMap.get(name);


              const hasMetadata = cachedVideo && cachedVideo.metaModified;
              let shouldRefresh = !cachedVideo || cachedVideo.modified !== file.lastModified || !hasMetadata;
              
              if (!shouldRefresh && cachedVideo) {

                try {
                  const metaDir = await dir.getDirectoryHandle('.metadata', { create: false });
                  const metaHandle = await metaDir.getFileHandle(name + '.meta.json', { create: false });
                  const metaFile = await metaHandle.getFile();

                  if (metaFile.lastModified > (cachedVideo.metaModified || 0)) {
                    shouldRefresh = true;
                  }
                } catch (e) {

                }
              }

              if (shouldRefresh) {
                const meta = await getVideoMetadataOptimized(dir, name, metadataCache);
                const videoCreated = meta.created || (cachedVideo?.created) || createdTimestamp++;
                const videoData = {
                  name, 
                  size: file.size,
                  modified: file.lastModified,
                  created: videoCreated,
                  fileCreated: meta.fileCreated || file.lastModified,
                  views: meta.views || 0,
                  likes: meta.likes || 0,
                  dislikes: meta.dislikes || 0,
                  tags: meta.tags || [],
                  quality: meta.quality || getVideoQuality({ name, size: file.size }),
                  metaModified: Date.now(),
                  ...meta
                };
                
                const videoWithHandles = {
                  ...videoData,
                  handle: handle,
                  file: file,
                  dirHandle: dir
                };

                const idx = allVideos.findIndex(v => v.name === name);
                if (idx >= 0) {
                  allVideos[idx] = videoWithHandles;
                } else {
                  allVideos.push(videoWithHandles);
                }

                videoMap.set(name, videoWithHandles);
                
                videosToSave.push(videoData);
              } else {
                const videoWithHandles = {
                  ...cachedVideo,
                  handle: handle,
                  file: file,
                  dirHandle: dir
                };

                const idx = allVideos.findIndex(v => v.name === name);
                if (idx >= 0) {
                  allVideos[idx] = videoWithHandles;
                } else {
                  allVideos.push(videoWithHandles);
                }

                videoMap.set(name, videoWithHandles);
              }
            } catch (e) {
              debug.warn('Cannot access file:', name, e.message);
            }
          }
        } else if (handle.kind === 'directory' && !name.startsWith('.')){
          await scan(handle, path + '/' + name);
        }
      }));
      
      if (videosToSave.length >= BATCH_SIZE) {
        await saveBatch();
      }
    }
  }

  await scan(videoDirectoryHandle);
  await saveBatch();
  
  const scanTime = performance.now() - startTime;
  debug.log(`‚úÖ File scan completed in ${Math.round(scanTime)}ms`);

  const deletePromises = cachedVideos
    .filter(cachedVideo => !currentVideoNames.has(cachedVideo.name))
    .flatMap(cachedVideo => {
      debug.log(`Removing deleted video from cache: ${cachedVideo.name}`);
      return [
        deleteVideoFromDB(cachedVideo.name),
        (async () => {
          try {
            const metaDir = await videoDirectoryHandle.getDirectoryHandle('.metadata', { create: false });
            await metaDir.removeEntry(cachedVideo.name + '.meta.json');
            debug.log(`Deleted metadata file for: ${cachedVideo.name}`);
          } catch (e) {

          }
        })()
      ];
    });
  
  const deletedVideoNames = new Set(
    cachedVideos
      .filter(v => !currentVideoNames.has(v.name))
      .map(v => v.name)
  );
  
  await Promise.all(deletePromises);

  if (deletedVideoNames.size > 0) {
    try {
      const globalPlaylists = await readJSONFile(videoDirectoryHandle, '.global_playlists.json', []);
      let playlistsUpdated = false;
      
      for (const playlist of globalPlaylists) {
        if (playlist.videos?.length > 0) {
          const originalLength = playlist.videos.length;
          playlist.videos = playlist.videos.filter(v => !deletedVideoNames.has(v.name));
          if (playlist.videos.length !== originalLength) {
            playlistsUpdated = true;
            debug.log(`Removed ${originalLength - playlist.videos.length} deleted videos from playlist: ${playlist.title}`);
          }
        }
      }
      
      if (playlistsUpdated) {
        await writeJSONFile(videoDirectoryHandle, '.global_playlists.json', globalPlaylists);
        debug.log('Updated .global_playlists.json to remove deleted videos');
      }
    } catch (e) {
      debug.warn('Failed to clean up global playlists file:', e);
    }
  }


  
  const totalTime = performance.now() - startTime;
  const avgTime = allVideos.length > 0 ? (totalTime / allVideos.length).toFixed(2) : 0;
  
  debug.log(`‚úÖ PERFORMANCE REPORT:`);
  debug.log(`   üìä Total videos: ${allVideos.length}`);
  debug.log(`   ‚è±Ô∏è Total time: ${Math.round(totalTime)}ms (${(totalTime/1000).toFixed(1)}s)`);
  debug.log(`   üìà Average per video: ${avgTime}ms`);
  debug.log(`   üöÄ Videos per second: ${(allVideos.length / (totalTime/1000)).toFixed(1)}`);
  
  if (allVideos.length > 0) {
    debug.log('‚úÖ Sample video metadata:', allVideos[0]);
  }

  debug.log(`üì¶ Metadata cache contains ${metadataCache.size} entries for future use`);
}

      async function renderPlaylists(){
        debug.log('RENDER PLAYLISTS CALLED');

        renderMixedContent();


      }

      let renderMixedContentTimeout = null;


      function renderMixedContent() {

        if (renderMixedContentTimeout) {
          clearTimeout(renderMixedContentTimeout);
        }

        renderMixedContentTimeout = setTimeout(() => {
          renderMixedContentImmediate();
        }, 50);
      }
      
      function renderMixedContentImmediate() {

        if (isRenderingMixedContent) {
          debug.log('‚ö†Ô∏è renderMixedContent already in progress, skipping...');
          return;
        }
        
        const topContainer = document.getElementById('topPlaylistsContainer');
        if (!topContainer) return;
        
        isRenderingMixedContent = true;
        debug.log('üé¨ Starting renderMixedContent...');
        
        try {

          removePlaylistPlaceholder();

          if (typeof avatarLoadManager !== 'undefined') {
            avatarLoadManager.clearPending();
          }
          
          topContainer.innerHTML = '';

        {

          const allPlaylistsSorted = (allPlaylists && allPlaylists.length) ? 
            allPlaylists.slice().sort((a, b) => (b.created || 0) - (a.created || 0)) : [];
          
          let contentIndex = 0;

          let bannerSection;
          if (savedBannerElement && bannerLoaded) {

            bannerSection = savedBannerElement;
            topContainer.appendChild(bannerSection);
          } else {

            bannerSection = document.createElement('section');
            bannerSection.className = 'banner-section';
            topContainer.appendChild(bannerSection);

            loadRandomBanner(bannerSection);
            bannerLoaded = true;
            savedBannerElement = bannerSection;
          }

          const tagsSection = document.createElement('section');
          tagsSection.className = 'tags-section';

          let currentCols;
          if (typeof adaptiveGrid !== 'undefined') {
            currentCols = adaptiveGrid.getCurrentColumns('video');
          } else {
            currentCols = Number(localStorage.getItem('youvi_latest_cols')) || 6;
          }

          document.documentElement.style.setProperty('--latest-cols', currentCols);

          const t = (key, def) => typeof i18n !== 'undefined' ? i18n.t(key, def) : def;
          
          tagsSection.innerHTML = `
            <div class="tags-container">
              <a href="#" class="tag-item active" data-tag="all" data-i18n="tags.all">${t('tags.all', 'All')}</a>
              <a href="#" class="tag-item" data-tag="Anime (ct)" data-i18n="footer.categories.anime">${t('footer.categories.anime', 'Anime')}</a>
              <a href="#" class="tag-item" data-tag="Animation (ct)" data-i18n="footer.categories.animation">${t('footer.categories.animation', 'Animation')}</a>
              <a href="#" class="tag-item" data-tag="Games (ct)" data-i18n="footer.categories.games">${t('footer.categories.games', 'Games')}</a>
              <a href="#" class="tag-item" data-tag="Series (ct)" data-i18n="footer.categories.series">${t('footer.categories.series', 'Series')}</a>
              <a href="#" class="tag-item" data-tag="Movies (ct)" data-i18n="footer.categories.movies">${t('footer.categories.movies', 'Movies')}</a>
              <a href="#" class="tag-item" data-tag="Music (ct)" data-i18n="footer.categories.music">${t('footer.categories.music', 'Music')}</a>
              <a href="#" class="tag-item" data-tag="Entertainment (ct)" data-i18n="footer.categories.entertainment">${t('footer.categories.entertainment', 'Entertainment')}</a>
              <a href="#" class="tag-item" data-tag="Technology (ct)" data-i18n="footer.categories.tech">${t('footer.categories.tech', 'Technology')}</a>
              <a href="#" class="tag-item" data-tag="Education (ct)" data-i18n="footer.categories.education">${t('footer.categories.education', 'Education')}</a>
              <a href="#" class="tag-item" data-tag="IRL (ct)" data-i18n="footer.categories.irl">${t('footer.categories.irl', 'IRL')}</a>
              <a href="#" class="tag-item" data-tag="TV (ct)" data-i18n="footer.categories.tv">${t('footer.categories.tv', 'TV')}</a>
              <a href="#" class="tag-item" data-tag="Other (ct)" data-i18n="footer.categories.random">${t('footer.categories.random', 'Other')}</a>
              <a href="#" class="tag-item" data-tag="random" data-i18n="tags.randomShort">${t('tags.randomShort', 'Random')}</a>
            </div>
            <div class="grid-switcher">
              <span class="grid-auto-indicator" id="gridModeIndicator" data-i18n-auto="grid.auto" data-i18n-manual="grid.manual">${t('grid.auto', '–∞–≤—Ç–æ')}</span>
              <button class="grid-btn" data-cols="2" data-grid-type="video">2</button>
              <button class="grid-btn" data-cols="3" data-grid-type="video">3</button>
              <button class="grid-btn" data-cols="4" data-grid-type="video">4</button>
              <button class="grid-btn" data-cols="5" data-grid-type="video">5</button>
              <button class="grid-btn" data-cols="6" data-grid-type="video">6</button>
              <button class="grid-btn" data-cols="7" data-grid-type="video">7</button>
              <button class="grid-reset-btn" id="gridResetBtn" data-i18n-title="grid.resetToAuto" title="${t('grid.resetToAuto', '–°–±—Ä–æ—Å–∏—Ç—å –Ω–∞ –∞–≤—Ç–æ')}" style="display: none;">‚Üª</button>
            </div>
          `;
          topContainer.appendChild(tagsSection);

          try {
            const bannerTags = tagsSection.querySelectorAll('.tag-item');
            bannerTags.forEach(el => el.classList.remove('active'));
            const wanted = String(currentFilter || 'all').toLowerCase();
            const matchEl = Array.from(bannerTags).find(el => String(el.dataset.tag || '').toLowerCase() === wanted);
            if (matchEl) matchEl.classList.add('active');
          } catch (_) {}

          const switcherEl = tagsSection.querySelector('.grid-switcher');
          const gridModeIndicator = tagsSection.querySelector('#gridModeIndicator');
          const gridResetBtn = tagsSection.querySelector('#gridResetBtn');

          if (typeof adaptiveGrid !== 'undefined') {
            const isManual = adaptiveGrid.isManualMode('video');
            const currentCols = adaptiveGrid.getCurrentColumns('video');

            if (gridModeIndicator) {
              gridModeIndicator.textContent = isManual ? (typeof i18n !== 'undefined' ? i18n.t('grid.manual', '—Ä—É—á–Ω–æ–π') : '—Ä—É—á–Ω–æ–π') : (typeof i18n !== 'undefined' ? i18n.t('grid.auto', '–∞–≤—Ç–æ') : '–∞–≤—Ç–æ');
            }

            if (gridResetBtn) {
              gridResetBtn.style.display = isManual ? 'inline-block' : 'none';
              gridResetBtn.addEventListener('click', () => {
                adaptiveGrid.resetManualMode('video');

                if (gridModeIndicator) {
                  gridModeIndicator.textContent = typeof i18n !== 'undefined' ? i18n.t('grid.auto', '–∞–≤—Ç–æ') : '–∞–≤—Ç–æ';
                }
                gridResetBtn.style.display = 'none';
              });
            }

            Array.from(switcherEl.querySelectorAll('.grid-btn')).forEach(btn => {
              btn.classList.toggle('active', Number(btn.dataset.cols) === currentCols);
            });
          } else {

            Array.from(switcherEl.querySelectorAll('.grid-btn')).forEach(btn=>{
              if (Number(btn.dataset.cols) === currentCols) btn.classList.add('active');
              btn.addEventListener('click', (e)=>{
                const cols = Number(e.currentTarget.dataset.cols);
                document.documentElement.style.setProperty('--latest-cols', cols);
                localStorage.setItem('youvi_latest_cols', String(cols));
                switcherEl.querySelectorAll('.grid-btn').forEach(b=>b.classList.remove('active'));
                e.currentTarget.classList.add('active');
                renderMixedContent();
              });
            });
          }

          tagsSection.addEventListener('click', (e) => {
            const target = e.target;
            if (target && target.classList && target.classList.contains('tag-item')) {
              e.preventDefault();

              const tag = target.dataset.tag;

              if (tag && tag.toLowerCase() === 'random') {
                try {
                  if (Array.isArray(allVideos) && allVideos.length > 0) {
                    const rnd = Math.floor(Math.random() * allVideos.length);
                    const v = allVideos[rnd];
                    const videoUrl = window.VideoID 
                        ? window.VideoID.buildVideoUrl(v.name)
                        : `youvi_video.html?name=${encodeURIComponent(v.name)}&playlist=`;
                    window.location.href = videoUrl;
                    return;
                  }
                } catch (_) {}
                return;
              }

              tagsSection.querySelectorAll('.tag-item').forEach(tagEl => tagEl.classList.remove('active'));
              target.classList.add('active');

              filterByTag(tag || 'all');
            }
          });

          function filterByTag(tag) {
            try {
              const next = (tag && tag.toLowerCase() === 'all') ? 'all' : (tag || 'all');
              currentFilter = next;
              currentPage = 1;
              updateUrlParameter('tag', currentFilter === 'all' ? null : currentFilter);
              applyFiltersAndRender();
              updateSectionTitle();
              updatePageTitle();
            } catch (e) { debug.warn('filterByTag error', e); }
          }
  
          function shuffleContent() {

            filteredPlaylists = [...allPlaylistsSorted].sort(() => Math.random() - 0.5);

            renderMixedContent();
          }

          if (currentPage === 1 && currentFilter === 'all' && currentSort === 'new' && !currentSearchQuery) {

            if (allPlaylistsSorted.length > 0) {
              const playlistsHeader = document.createElement('section');
              playlistsHeader.className = 'playlists-header-section';
              const latestPlaylistsText = typeof i18n !== 'undefined' ? i18n.t('main.latestPlaylists', '–°–≤–µ–∂–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç—ã') : '–°–≤–µ–∂–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç—ã';
              playlistsHeader.innerHTML = `
                <h2 class="playlists-header-title" data-i18n="main.latestPlaylists">${latestPlaylistsText}</h2>
              `;
              topContainer.appendChild(playlistsHeader);
            }

            const playlistsContainer = document.createElement('div');
            playlistsContainer.className = 'playlists-reserved-space';

            const containerHeight = allPlaylistsSorted.length > 0 ? '160px' : '0px';
            playlistsContainer.style.cssText = `
              min-height: ${containerHeight};
              position: relative;
              display: flex;
              flex-direction: column;
              gap: 10px;
            `;
            topContainer.appendChild(playlistsContainer);

            const untitledText = typeof i18n !== 'undefined' ? i18n.t('main.untitled', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è') : '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è';
            const openAllText = typeof i18n !== 'undefined' ? i18n.t('main.openAll', '–û—Ç–∫—Ä—ã—Ç—å –≤—Å–µ') : '–û—Ç–∫—Ä—ã—Ç—å –≤—Å–µ';
            
            if (allPlaylistsSorted.length > 0) {
              const playlist = allPlaylistsSorted[0];
              const uniqueCarouselId = `mixed-carousel-${playlist.id}-0`;
              const section = document.createElement('section');
              section.className = 'playlist-section-carousel';
              section.innerHTML = `
                <div class="playlist-section-header">
                  <h2 class="playlist-section-title">${escapeHtml(playlist.title || untitledText)}</h2>
                  <a href="youvi_playlists_view.html?playlistId=${playlist.id}" class="playlist-section-all-link">${openAllText}</a>
                </div>
                <div class="video-carousel-wrapper">
                  <div class="video-carousel" id="${uniqueCarouselId}"></div>
                </div>`;
              playlistsContainer.appendChild(section);

              requestAnimationFrame(() => {
                renderPlaylistCarousel(playlist, uniqueCarouselId);
              });
            }

            if (allPlaylistsSorted.length > 1) {
              const playlist = allPlaylistsSorted[1];
              const uniqueCarouselId = `mixed-carousel-${playlist.id}-1`;
              const section = document.createElement('section');
              section.className = 'playlist-section-carousel';
              section.innerHTML = `
                <div class="playlist-section-header">
                  <h2 class="playlist-section-title">${escapeHtml(playlist.title || untitledText)}</h2>
                  <a href="youvi_playlists_view.html?playlistId=${playlist.id}" class="playlist-section-all-link">${openAllText}</a>
                </div>
                <div class="video-carousel-wrapper">
                  <div class="video-carousel" id="${uniqueCarouselId}"></div>
                </div>`;
              playlistsContainer.appendChild(section);

              requestAnimationFrame(() => {
                renderPlaylistCarousel(playlist, uniqueCarouselId);
              });
            }
          }

          attachTagClickListeners();

          requestAnimationFrame(() => {
            if (avatarLoadManager.pending.size > 0) {
              debug.log(`üé® Processing ${avatarLoadManager.pending.size} avatar requests for carousels`);
              avatarLoadManager.processBatch();
            }
          });
        }
        } catch (error) {
          debug.error('‚ùå Error in renderMixedContent:', error);
        } finally {
          isRenderingMixedContent = false;
          debug.log('‚úÖ renderMixedContent completed');
        }
      }

      function renderPlaylistCarousel(playlist, carouselId) {

        clearAllHoverPreviews();
        
        const carousel = document.getElementById(carouselId);
        if (!carousel) return;

        const observer = initPreviewObserver();

        let cols;
        if (typeof adaptiveGrid !== 'undefined') {
          cols = adaptiveGrid.getCurrentColumns('video');
        } else {
          cols = Number(localStorage.getItem('youvi_latest_cols')) || 6;
        }
        const videosToShow = (playlist.videos || []).slice(0, Math.max(1, cols));
        
        for (const video of videosToShow) {
          const card = document.createElement('div');
          card.className = 'video-card';
          const link = document.createElement('a');
          link.className = 'video-thumbnail';
          const videoUrl = window.VideoID 
              ? window.VideoID.buildVideoUrl(video.name, playlist.id)
              : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist.id || '')}`;
          link.href = videoUrl;

          link.dataset.videoName = video.name;

          const fullVideo = allVideos.find(av => av.name === video.name);
          const videoWithMetadata = fullVideo ? { ...fullVideo, ...video } : video;

           const badges = [];
           if (videoWithMetadata.quality) {
             badges.push(`<div class="video-quality" data-quality="${videoWithMetadata.quality}" style="position:absolute;top:5px;left:5px;padding:2px 4px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;">${videoWithMetadata.quality}</div>`);
           }
           const newBadgeLabel = typeof i18n !== 'undefined' ? i18n.t('video.newBadge', '–ù–æ–≤–∏–Ω–∫–∞') : '–ù–æ–≤–∏–Ω–∫–∞';
           if (videoWithMetadata.created && (Date.now() - videoWithMetadata.created) < 24 * 60 * 60 * 1000) {
             badges.push(`<div class="video-new" style="position:absolute;top:5px;right:5px;background:#ff4444;padding:2px 6px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;text-transform:uppercase;">${newBadgeLabel}</div>`);
           }
          
          link.innerHTML = `
            <div class="video-duration">...</div>
            ${badges.join('')}
            <div style="width:100%;height:100%;background:#eee;display:flex;align-items:center;justify-content:center;color:#111;font-size:10px;text-align:center;padding:5px;">
              ${escapeHtml(getFileNameWithoutExtension(video.name))}
            </div>`;
          
          const info = document.createElement('div');
          info.className = 'video-info';

          const channelTags = (videoWithMetadata.tags || []).filter(t => t.includes('(–∫–∞)'));
          let channelDisplay = '';
          let channelName = '';
          
          if (channelTags.length > 0) {
            const channelLinks = channelTags.map(t => {
              const channelName = t.replace(' (–∫–∞)', '');
              return `<a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" class="playlist-channel-link">${escapeHtml(channelName)}</a>`;
            }).join(', ');
            channelDisplay = channelLinks;

            channelName = channelTags[0].replace(' (–∫–∞)', '');
          } else if (playlist.channelName) {
            channelDisplay = `<a href="youvi_ch_view.html?channel=${encodeURIComponent(playlist.channelName)}" class="playlist-channel-link">${escapeHtml(playlist.channelName)}</a>`;
            channelName = playlist.channelName;
          } else {
            channelDisplay = `<span>${typeof i18n !== 'undefined' ? i18n.t('video.noChannel', 'No channel') : 'No channel'}</span>`;
          }
          
          const channelInitial = channelName ? channelName.charAt(0).toUpperCase() : '?';
          const avatarId = `mainAvatar_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
          
          const createdDateObj = videoWithMetadata.created ? new Date(videoWithMetadata.created) : (videoWithMetadata.modified ? new Date(videoWithMetadata.modified) : null);
          const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
          const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
          const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
          const danmakuCount = videoWithMetadata.danmakuCount || 0;
          const statsLine = `<div class="video-stats" style="color:#888;font-size:11px;">${viewsSvg} ${(videoWithMetadata.views||0).toLocaleString()} ‚Ä¢ ${danmakuSvg} ${danmakuCount}</div>`;
          const dateLine = dateStr ? `<div class="video-date" style="color:#888;font-size:11px;">${dateStr}</div>` : '';
          
          info.innerHTML = `
            <div class="video-card-title"><a href="${videoUrl}" class="video-title-link" style="color:inherit;text-decoration:none;" title="${escapeHtml(getFileNameWithoutExtension(video.name))}">${escapeHtml(getFileNameWithoutExtension(video.name))}</a></div>
            ${statsLine}
            <div class="video-card-meta-row">
              <a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" class="video-card-avatar-link" onclick="event.stopPropagation()">
                <div class="video-card-avatar" id="${avatarId}">${channelInitial}</div>
              </a>
              <div class="video-card-text">
                <div class="video-playlist">${channelDisplay}</div>
                ${dateLine}
              </div>
            </div>
          `;

          if (channelName) {
            avatarLoadManager.load(channelName, avatarId);
          }

          card.appendChild(link);
          card.appendChild(info);
          carousel.appendChild(card);

          if (videoWithMetadata.file && videoWithMetadata.handle) {
            addHoverPreview(link, videoWithMetadata);
          }

          if (observer && !observedThumbnails.has(link)) {
            observer.observe(link);
            observedThumbnails.add(link);
          }
        }
      }

async function renderLatestVideos() {

  if (isRenderingVideos) {
    debug.log('‚ö†Ô∏è Skipping render - already in progress');
    return;
  }
  isRenderingVideos = true;

  const thisRenderVersion = ++currentRenderVersion;
  
  try {

  clearAllHoverPreviews();
  
  const grid = document.getElementById('latestGrid');
  if (!grid) {
    isRenderingVideos = false;
    return;
  }

  if (thisRenderVersion !== currentRenderVersion) {
    debug.log('‚ö†Ô∏è Render version changed, aborting stale render');
    isRenderingVideos = false;
    return;
  }

  hideSkeletonLoading();

  if (typeof avatarLoadManager !== 'undefined') {
    avatarLoadManager.clearPending();
  }
  
  grid.innerHTML = '';
  
  const perfStart = performance.now();

  let allVideosList = [];

  const playlistVideoData = new Map();
  for (const pl of allPlaylists) {
    for (const v of (pl.videos || [])) {
      if (!playlistVideoData.has(v.name)) {
        playlistVideoData.set(v.name, { _playlistId: pl.id, _playlist: pl });
      }
    }
  }

  const resolvedFilter = resolveCategoryAlias(currentFilter);
  if (currentFilter !== 'all' && !currentSearchQuery && db) {
    try {
      const cachedFilteredVideos = await getVideosByTag(resolvedFilter);
      if (cachedFilteredVideos.length > 0) {
        debug.log(`‚úÖ Used IndexedDB index for tag "${currentFilter}" (resolved: "${resolvedFilter}"): ${cachedFilteredVideos.length} videos`);

        allVideosList = cachedFilteredVideos.map(cachedVideo => {
          const liveVideo = allVideos.find(v => v.name === cachedVideo.name);
          const playlistData = playlistVideoData.get(cachedVideo.name);
          return {
            ...cachedVideo,

            views: liveVideo?.views ?? cachedVideo.views,
            tags: liveVideo?.tags ?? cachedVideo.tags,
            quality: liveVideo?.quality ?? cachedVideo.quality,
            created: liveVideo?.created ?? cachedVideo.created,
            handle: liveVideo?.handle || null,
            file: liveVideo?.file || null,
            dirHandle: liveVideo?.dirHandle || null,
            _playlistId: playlistData?._playlistId || null,
            _playlist: playlistData?._playlist || null
          };
        });
      } else {

        allVideosList = allVideos.filter(video => 
          video.tags && video.tags.some(tag => 
            !tag.includes('(–∫–∞)') && tag.trim().toLowerCase() === resolvedFilter.trim().toLowerCase()
          )
        ).map(video => ({
          ...video,
          _playlistId: playlistVideoData.get(video.name)?._playlistId || null,
          _playlist: playlistVideoData.get(video.name)?._playlist || null
        }));
      }
    } catch (e) {
      debug.warn('‚ùó IndexedDB index query failed, using in-memory filter:', e);

      allVideosList = allVideos.filter(video => 
        video.tags && video.tags.some(tag => 
          !tag.includes('(–∫–∞)') && tag.trim().toLowerCase() === resolvedFilter.trim().toLowerCase()
        )
      ).map(video => ({
        ...video,
        _playlistId: playlistVideoData.get(video.name)?._playlistId || null,
        _playlist: playlistVideoData.get(video.name)?._playlist || null
      }));
    }
  } else {

    allVideosList = allVideos.map(video => {
      const playlistData = playlistVideoData.get(video.name);
      return {
        ...video,
        _playlistId: playlistData?._playlistId || null,
        _playlist: playlistData?._playlist || null
      };
    });
  }
  
  const filterTime = performance.now() - perfStart;
  debug.log(`‚úÖ Filtering took ${Math.round(filterTime)}ms for ${allVideosList.length} videos`);

  renderSidebarCategories();

  updateSectionTitle();


  if (currentSearchQuery) {
    const query = currentSearchQuery.toLowerCase();
    const beforeSearch = allVideosList.length;
    allVideosList = allVideosList.filter(video => {
      const videoName = getFileNameWithoutExtension(video.name);

      if (window.autocompleteCache && window.autocompleteCache.matchesWithTranslit) {
        if (window.autocompleteCache.matchesWithTranslit(videoName, query)) return true;
        if (video.tags) {
          return video.tags.some(tag => 
            !tag.includes('(–∫–∞)') && window.autocompleteCache.matchesWithTranslit(tag, query)
          );
        }
        return false;
      }

      return videoName.toLowerCase().includes(query) ||
        (video.tags && video.tags.some(tag => 
          !tag.includes('(–∫–∞)') && tag.toLowerCase().includes(query)
        ));
    });
    debug.log(`Search filtered from ${beforeSearch} to ${allVideosList.length} videos (with transliteration)`);
  }
  
  let sortedVideos;
  const sortPerfStart = performance.now();
  
  if (!currentSearchQuery && db && currentFilter === 'all') {
    const indexMap = {
      'new': { index: 'created', direction: 'prev' },
      'old': { index: 'created', direction: 'next' },
      'popular': { index: 'views', direction: 'prev' }
    };
    
    const sortConfig = indexMap[currentSort];
    if (sortConfig) {
      try {
        const cachedSortedVideos = await getVideosSortedByIndex(sortConfig.index, sortConfig.direction);
        if (cachedSortedVideos.length > 0) {
          debug.log(`‚úÖ Used IndexedDB index for sorting "${currentSort}"`);

          sortedVideos = cachedSortedVideos.map(cachedVideo => {
            const liveVideo = allVideos.find(v => v.name === cachedVideo.name);
            const playlistData = playlistVideoData.get(cachedVideo.name);
            return {
              ...cachedVideo,

              views: liveVideo?.views ?? cachedVideo.views,
              tags: liveVideo?.tags ?? cachedVideo.tags,
              quality: liveVideo?.quality ?? cachedVideo.quality,
              created: liveVideo?.created ?? cachedVideo.created,
              handle: liveVideo?.handle || null,
              file: liveVideo?.file || null,
              dirHandle: liveVideo?.dirHandle || null,
              _playlistId: playlistData?._playlistId || null,
              _playlist: playlistData?._playlist || null
            };
          });
          allVideosList = sortedVideos;
        } else {
          sortedVideos = sortVideos(allVideosList);
          allVideosList = sortedVideos;
        }
      } catch (e) {
        debug.warn('‚ùó IndexedDB sort failed, using in-memory sort:', e);
        sortedVideos = sortVideos(allVideosList);
        allVideosList = sortedVideos;
      }
    } else {
      sortedVideos = sortVideos(allVideosList);
      allVideosList = sortedVideos;
    }
  } else {

    sortedVideos = sortVideos(allVideosList);
    allVideosList = sortedVideos;
  }
  
  const sortTime = performance.now() - sortPerfStart;
  debug.log(`‚úÖ Sorting took ${Math.round(sortTime)}ms`);

  debug.log('Sorting videos with currentSort:', currentSort);
  debug.log('Videos after sorting:', allVideosList.length);
  if (allVideosList.length > 0) {
    debug.log('Sample video metadata:', allVideosList.slice(0, 3).map(v => ({
      name: v.name,
      views: v.views,
      created: v.created,
      modified: v.modified,
      tags: v.tags,
      _playlistId: v._playlistId
    })));
  }

  debug.log('Total videos found for pagination:', allVideosList.length);
  debug.log('Current page:', currentPage);

  const VIDEOS_PER_PAGE = 84;
  const totalVideos = allVideosList.length;

  let totalVideoPages = Math.ceil(totalVideos / VIDEOS_PER_PAGE);
  totalVideoPages = Math.max(1, totalVideoPages);

  if (currentPage > totalVideoPages && totalVideoPages > 0) {
    currentPage = totalVideoPages;
    updateUrlParameter('page', currentPage > 1 ? currentPage : null);
  }

  let startIndex = (currentPage - 1) * VIDEOS_PER_PAGE;
  let endIndex = Math.min(startIndex + VIDEOS_PER_PAGE, allVideosList.length);
  
  debug.log(`Pagination: startIndex=${startIndex}, endIndex=${endIndex}, totalPages=${totalVideoPages}`);
  const pageVideos = allVideosList.slice(startIndex, endIndex);
  
  debug.log(`Rendering ${pageVideos.length} videos on page ${currentPage}`);

  if (thisRenderVersion !== currentRenderVersion) {
    debug.log('‚ö†Ô∏è Render version changed during pagination calc, aborting');
    isRenderingVideos = false;
    return;
  }

  if (allVideosList.length === 0) {
    const t = (key, def) => typeof i18n !== 'undefined' ? i18n.t(key, def) : def;
    if (currentFilter !== 'all') {
      grid.innerHTML = `<div class="empty-state">${t('main.noVideosWithTag', '–ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ —Å —Ç–µ–≥–æ–º').replace('{tag}', '')} "${escapeHtml(currentFilter)}"</div>`;
    } else if (currentSearchQuery) {
      grid.innerHTML = `<div class="empty-state">${t('main.noVideosForQuery', '–ù–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ –ø–æ –∑–∞–ø—Ä–æ—Å—É').replace('{query}', '')} "${escapeHtml(currentSearchQuery)}"</div>`;
    } else {
      grid.innerHTML = `<div class="empty-state">${t('main.noVideosInFolder', '–í –≤—ã–±—Ä–∞–Ω–Ω–æ–π –ø–∞–ø–∫–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∏–¥–µ–æ –∏–ª–∏ –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤')}</div>`;
    }
    return;
  }

  const observer = initPreviewObserver();

  const fragment = document.createDocumentFragment();

  const renderedInThisPage = new Set();
  
  for (const item of pageVideos) {

    if (renderedInThisPage.has(item.name)) {
      debug.warn(`‚ö†Ô∏è Skipping duplicate video: ${item.name}`);
      continue;
    }
    renderedInThisPage.add(item.name);
    const card = document.createElement('div');
    card.className = 'video-card';
    card.setAttribute('data-video-name', item.name);

    card.style.cssText = 'width: 100%; height: fit-content; contain: layout;';
    
    const thumb = document.createElement('a');
    thumb.className = 'video-thumbnail';
    const videoUrl = window.VideoID 
        ? window.VideoID.buildVideoUrl(item.name, item._playlistId)
        : `youvi_video.html?name=${encodeURIComponent(item.name)}&playlist=${encodeURIComponent(item._playlistId || '')}`;
    thumb.href = videoUrl;

    thumb.dataset.videoName = item.name;

    const badges = [];
    if (item.quality) {
      badges.push(`<div class="video-quality" data-quality="${item.quality}" style="position:absolute;top:5px;left:5px;padding:2px 4px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;">${item.quality}</div>`);
    }
    const newBadgeTxt = typeof i18n !== 'undefined' ? i18n.t('video.newBadge', '–ù–æ–≤–∏–Ω–∫–∞') : '–ù–æ–≤–∏–Ω–∫–∞';
    if (item.created && (Date.now() - item.created) < 24 * 60 * 60 * 1000) {
      badges.push(`<div class="video-new" style="position:absolute;top:5px;right:5px;background:#ff4444;padding:2px 6px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;text-transform:uppercase;">${newBadgeTxt}</div>`);
    }

    const hash = item.name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const hue = hash % 360;
    const placeholderColor = `hsl(${hue}, 25%, 85%)`;

    thumb.innerHTML = `
      <div class="latest-duration">...</div>
      ${badges.join('')}
      <div class="thumbnail-placeholder" style="width:100%;height:100%;background:${placeholderColor};display:flex;align-items:center;justify-content:center;color:#555;font-size:10px;text-align:center;padding:5px;">
        <span class="thumbnail-text">${escapeHtml(getFileNameWithoutExtension(item.name))}</span>
      </div>`;

    const info = document.createElement('div');
    info.className = 'video-info';
    info.style.cssText = 'width: 100%; min-width: 0; overflow-wrap: break-word; word-break: break-word;';

    const channelTags = (item.tags || []).filter(t => t.includes('(–∫–∞)'));
    let channelName = '';
    let channelDisplay = '';
    if (channelTags.length > 0) {
      channelName = channelTags[0].replace(' (–∫–∞)', '');
      const channelLinks = channelTags.map(t => {
        const cn = t.replace(' (–∫–∞)', '');
        return `<a href="youvi_ch_view.html?channel=${encodeURIComponent(cn)}" class="playlist-channel-link">${escapeHtml(cn)}</a>`;
      }).join(', ');
      channelDisplay = channelLinks;
    } else if (item._playlist?.channelName) {
      channelName = item._playlist.channelName;
      channelDisplay = `<a href="youvi_ch_view.html?channel=${encodeURIComponent(item._playlist.channelName)}" class="playlist-channel-link">${escapeHtml(item._playlist.channelName)}</a>`;
    } else if (item._playlist) {
      channelDisplay = `<span>${typeof i18n !== 'undefined' ? i18n.t('video.noChannel', 'No channel') : 'No channel'}</span>`;
    } else {
      channelDisplay = `<span>${typeof i18n !== 'undefined' ? i18n.t('video.noChannel', 'No channel') : 'No channel'}</span>`;
    }
    
    const channelInitial = channelName ? channelName.charAt(0).toUpperCase() : '?';
    const avatarId = `latestAvatar_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    
    const createdDateObj = item.created ? new Date(item.created) : (item.modified ? new Date(item.modified) : null);
    const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
    const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
    const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
    const danmakuCount = item.danmakuCount || 0;
    const zoom = window.devicePixelRatio || 1;
    
    const statsLine = `<div class="video-stats">${viewsSvg} ${(item.views||0).toLocaleString()} ‚Ä¢ ${danmakuSvg} ${danmakuCount}</div>`;
    const dateLine = dateStr ? `<div class="video-date">${dateStr}</div>` : '';
    
    info.innerHTML = `
      <div class="video-card-title"><a href="${videoUrl}" class="video-title-link" style="color:inherit;text-decoration:none;" title="${escapeHtml(getFileNameWithoutExtension(item.name))}">${escapeHtml(getFileNameWithoutExtension(item.name))}</a></div>
      ${statsLine}
      <div class="video-card-meta-row">
        <a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName || '')}" class="video-card-avatar-link" onclick="event.stopPropagation()">
          <div class="video-card-avatar" id="${avatarId}">${channelInitial}</div>
        </a>
        <div class="video-card-text">
          <div class="video-playlist">${channelDisplay}</div>
          ${dateLine}
        </div>
      </div>`;

    if (channelName) {
      avatarLoadManager.load(channelName, avatarId);
    }
    
    card.appendChild(thumb);
    card.appendChild(info);
    fragment.appendChild(card);

    if ((item.file && item.handle) || allVideos.find(av => av.name === item.name && av.file && av.handle)) {
      const videoData = item.file && item.handle ? item : allVideos.find(av => av.name === item.name && av.file && av.handle);
      addHoverPreview(thumb, videoData);
    }

    if (observer && !thumb.dataset.observed) {
      thumb.dataset.observed = 'true';
      thumb.dataset.videoName = item.name;
      observer.observe(thumb);
    }
  }

  grid.appendChild(fragment);

  const videosWithHandles = pageVideos.filter(v => v.file && v.handle).map(item => {
    return item.file && item.handle ? item : allVideos.find(av => av.name === item.name && av.file && av.handle);
  }).filter(Boolean);
  
  if (videosWithHandles.length > 0) {

    preloadMetadataForVideos(videosWithHandles).catch(e => debug.warn('Metadata preload error:', e));
  }

  if (currentPage < totalVideoPages) {
    setTimeout(() => {
      const nextPageStart = currentPage * VIDEOS_PER_PAGE;
      const nextPageEnd = Math.min(nextPageStart + VIDEOS_PER_PAGE, allVideosList.length);
      const nextPageVideos = allVideosList.slice(nextPageStart, nextPageEnd);

      const nextPageWithHandles = nextPageVideos.filter(v => {
        const fullVideo = allVideos.find(av => av.name === v.name);
        return fullVideo && fullVideo.file && fullVideo.handle;
      }).map(v => allVideos.find(av => av.name === v.name)).filter(Boolean);
      
      if (nextPageWithHandles.length > 0) {
        debug.log(`üîÑ Prefetching metadata for next page (${nextPageWithHandles.length} videos)`);
        preloadMetadataForVideos(nextPageWithHandles).catch(e => debug.warn('Next page prefetch error:', e));
      }
    }, 500);
  }

  const latestSection = document.querySelector('.latest-section');
  if (latestSection) {
    const existingPagination = latestSection.querySelector('.pagination');
    if (existingPagination) {
      existingPagination.remove();
    }
  }

  if (totalVideoPages > 1 && totalVideos > 25) {
    renderVideosPagination(totalVideoPages, totalVideos);
  }
  
  attachTagClickListeners();

  requestAnimationFrame(() => {
    if (avatarLoadManager.pending.size > 0) {
      avatarLoadManager.processBatch();
    }
  });
  } finally {
    isRenderingVideos = false;
  }
}

      function renderVideosPagination(totalPages, totalItems) {

        if (totalPages <= 1 || totalItems === 0) return;

        const PAGINATION_VIDEOS_PER_PAGE = 84;

        if (totalItems <= PAGINATION_VIDEOS_PER_PAGE) {
          return;
        }
        
        const pagination = document.createElement('div');
        pagination.className = 'pagination';
        
        const info = document.createElement('div');
        info.className = 'pagination-info';

        const DISPLAY_VIDEOS_PER_PAGE = 84;

        let startItem, endItem;

        startItem = (currentPage - 1) * DISPLAY_VIDEOS_PER_PAGE + 1;
        endItem = Math.min(startItem + DISPLAY_VIDEOS_PER_PAGE - 1, totalItems);
        const videosText = typeof i18n !== 'undefined' ? i18n.t('main.videosCount', '–≤–∏–¥–µ–æ') : '–≤–∏–¥–µ–æ';
        const pageText = typeof i18n !== 'undefined' ? i18n.t('main.page', '—Å—Ç—Ä.') : '—Å—Ç—Ä.';
        const ofText = typeof i18n !== 'undefined' ? i18n.t('main.of', '–∏–∑') : '–∏–∑';
        info.textContent = `${startItem}-${endItem} ${ofText} ${totalItems} ${videosText} (${pageText} ${currentPage} ${ofText} ${totalPages})`;

        debug.log(`Pagination: ${startItem}-${endItem} –∏–∑ ${totalItems} –≤–∏–¥–µ–æ, —Å—Ç—Ä–∞–Ω–∏—Ü–∞ ${currentPage} –∏–∑ ${totalPages}`);
        pagination.appendChild(info);
        
        if (currentPage > 1) {
          const prevBtn = createPageButton('‚Äπ –ù–∞–∑–∞–¥', currentPage - 1);
          pagination.appendChild(prevBtn);
        }
        
        const maxVisible = 5;
        let startPage = Math.max(1, currentPage - Math.floor(maxVisible / 2));
        let endPage = Math.min(totalPages, startPage + maxVisible - 1);
        
        if (endPage - startPage + 1 < maxVisible) {
          startPage = Math.max(1, endPage - maxVisible + 1);
        }
        
        if (startPage > 1) {
          pagination.appendChild(createPageButton('1', 1));
          if (startPage > 2) {
            const dots = document.createElement('span');
            dots.textContent = '...';
            dots.style.margin = '0 5px';
            dots.style.color = '#999';
            pagination.appendChild(dots);
          }
        }
        
        for (let i = startPage; i <= endPage; i++) {
          const btn = createPageButton(i.toString(), i);
          if (i === currentPage) {
            btn.classList.add('active');
          }
          pagination.appendChild(btn);
        }
        
        if (endPage < totalPages) {
          if (endPage < totalPages - 1) {
            const dots = document.createElement('span');
            dots.textContent = '...';
            dots.style.margin = '0 5px';
            dots.style.color = '#999';
            pagination.appendChild(dots);
          }
          pagination.appendChild(createPageButton(totalPages.toString(), totalPages));
        }
        
        if (currentPage < totalPages) {
          const nextText = typeof i18n !== 'undefined' ? i18n.t('pagination.next', '–í–ø–µ—Ä–µ–¥') : '–í–ø–µ—Ä–µ–¥';
          const nextBtn = createPageButton(nextText + ' ‚Ä∫', currentPage + 1);
          pagination.appendChild(nextBtn);
        }

        const latestSection = document.querySelector('.latest-section');
        if (latestSection) {

          const existingPagination = latestSection.querySelector('.pagination');
          if (existingPagination) {
            existingPagination.remove();
          }
          latestSection.appendChild(pagination);
        }
      }
      
      function createPageButton(text, page) {
        const btn = document.createElement('button');
        btn.className = 'btn pagination-btn';
        btn.textContent = text;
        btn.addEventListener('click', () => {
          currentPage = page;
          updateUrlParameter('page', page > 1 ? page : null);
          renderPlaylists();
          renderLatestVideos();
          updatePageTitle();

          window.scrollTo(0, 0);
        });
        return btn;
      }

      function attachCarouselEventListeners() {
        document.querySelectorAll('.video-carousel-wrapper').forEach(wrapper => {
          const carousel = wrapper.querySelector('.video-carousel');
          const prevBtn = wrapper.querySelector('.prev-btn');
          const nextBtn = wrapper.querySelector('.next-btn');
          const playlistId = prevBtn ? prevBtn.dataset.playlistId : (nextBtn ? nextBtn.dataset.playlistId : null);
          const playlist = allPlaylists.find(pl => String(pl.id) === playlistId);

          if (!carousel || !prevBtn || !nextBtn || !playlist) return;

          const updateArrowVisibility = () => {
            const currentVideoPage = carouselVideoPages.get(playlist.id) || 1;
            const totalVideoPages = Math.ceil((playlist.videos ? playlist.videos.length : 0) / videosPerPage);
            prevBtn.style.display = currentVideoPage > 1 ? 'flex' : 'none';
            nextBtn.style.display = currentVideoPage < totalVideoPages ? 'flex' : 'none';
          };

          prevBtn.addEventListener('click', () => {
            let currentVideoPage = carouselVideoPages.get(playlist.id) || 1;
            if (currentVideoPage > 1) {
              currentVideoPage--;
              carouselVideoPages.set(playlist.id, currentVideoPage);
              renderSinglePlaylistCarousel(playlist);
            }
          });

          nextBtn.addEventListener('click', () => {
            let currentVideoPage = carouselVideoPages.get(playlist.id) || 1;
            const totalVideoPages = Math.ceil((playlist.videos ? playlist.videos.length : 0) / videosPerPage);
            if (currentVideoPage < totalVideoPages) {
              currentVideoPage++;
              carouselVideoPages.set(playlist.id, currentVideoPage);
              renderSinglePlaylistCarousel(playlist);
            }
          });
        });
      }

      class LazyVideoLoader {
        constructor() {
          this.observer = null;
          this.pendingVideos = new Map();
          this.initObserver();
        }
        
        initObserver() {
          if ('IntersectionObserver' in window) {
            this.observer = new IntersectionObserver((entries) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  const videoName = entry.target.dataset.videoName;
                  const videoData = this.pendingVideos.get(videoName);
                  if (videoData) {
                    this.loadVideoPreview(videoData.video, videoData.thumbnailElement, videoData.priority);
                    this.pendingVideos.delete(videoName);
                    this.observer.unobserve(entry.target);
                  }
                }
              });
            }, {
              rootMargin: '50px',
              threshold: 0.1
            });
          }
        }
        
        addVideo(video, thumbnailElement, priority = 0) {
          if (!this.observer) {

            this.loadVideoPreview(video, thumbnailElement, priority);
            return;
          }

          thumbnailElement.dataset.videoName = video.name;

          this.pendingVideos.set(video.name, { video, thumbnailElement, priority });

          this.observer.observe(thumbnailElement);
        }
        
        async loadVideoPreview(video, thumbnailElement, priority = 0) {
          const task = async () => {
            try {
              debug.log(`Loading preview for video: ${video.name}`, {
                hasFile: !!video.file,
                hasHandle: !!video.handle,
                hasDirHandle: !!video.dirHandle
              });
              
              const { preview, duration } = await getPreviewAndDuration(video);
              if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
                try {
                  thumbnailElement.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';">`;
                  debug.log(`Successfully loaded preview for: ${video.name}`);
                } catch (imgError) {
                  debug.warn(`Failed to set preview image for ${video.name}:`, imgError);
                }
              } else {
                debug.warn(`Invalid preview data for ${video.name}:`, { 
                  hasPreview: !!preview, 
                  previewLength: preview ? preview.length : 0,
                  isBlob: preview ? preview.includes('blob:null/') : false
                });
              }
              const newDurationElement = document.createElement('div');
              newDurationElement.className = 'video-duration';
              newDurationElement.textContent = duration;
              thumbnailElement.appendChild(newDurationElement);
            } catch (e) {
              debug.error('Error loading preview for', video.name, e);
              thumbnailElement.innerHTML = `
                <div class="video-duration">0:00</div>
                <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                  ${escapeHtml(getFileNameWithoutExtension(video.name))}
                </div>`;
            }
          };

          taskQueue.add(task, priority);
        }

        forceLoadAll() {
          this.pendingVideos.forEach((videoData, videoName) => {
            this.loadVideoPreview(videoData.video, videoData.thumbnailElement, videoData.priority);
            this.observer.unobserve(videoData.thumbnailElement);
          });
          this.pendingVideos.clear();
        }
        
        getStats() {
          return {
            pending: this.pendingVideos.size,
            observerActive: !!this.observer
          };
        }
      }

      const lazyLoader = new LazyVideoLoader();

      async function loadVideoPreviewImmediately(video, thumbnailElement) {

        if (!thumbnailElement || !thumbnailElement.isConnected) {
          debug.log(`Thumbnail element no longer in DOM for: ${video.name}`);
          return;
        }

        const currentState = previewLoadingState.get(video.name);
        if (currentState === 'loaded') {

          const existingImg = thumbnailElement.querySelector('img');
          if (existingImg && existingImg.src && existingImg.src.startsWith('data:')) {
            debug.log(`Preview already loaded for: ${video.name}`);
            return;
          }
        }

        const existingImg = thumbnailElement.querySelector('img');
        if (existingImg && existingImg.src && existingImg.src.startsWith('data:')) {
          debug.log(`Preview already loaded for: ${video.name}`);
          previewLoadingState.set(video.name, 'loaded');
          return;
        }

        try {
          debug.log(`Immediately loading preview for: ${video.name}`);

          if (!video.views && !video.created && !video.tags) {
            const foundVideo = allVideos.find(av => av.name === video.name);
            if (foundVideo) {

              Object.assign(video, {
                views: foundVideo.views || 0,
                created: foundVideo.created || foundVideo.modified || 0,
                tags: foundVideo.tags || [],
                quality: foundVideo.quality || getVideoQuality(video),
                preview: foundVideo.preview || video.preview,
                duration: foundVideo.duration || video.duration
              });
            }
          }

          let preview = video.preview || video._cachedPreview;
          let duration = video.duration || video._cachedDuration;

          if (!preview || preview.length < 50) {
            const result = await getPreviewAndDuration(video);
            preview = result.preview;
            duration = result.duration;
          } else {
            debug.log(`‚úÖ Using pre-cached preview for: ${video.name}`);
          }

          if (!thumbnailElement.isConnected) {
            debug.log(`Thumbnail removed from DOM during preview load: ${video.name}`);
            return;
          }

          thumbnailElement.innerHTML = '';

          const isLatestVideo = thumbnailElement.classList.contains('latest-thumb');
          const durationClass = isLatestVideo ? 'latest-duration' : 'video-duration';
          
          const durationElement = document.createElement('div');
          durationElement.className = durationClass;
          durationElement.textContent = duration || '0:00';
          thumbnailElement.appendChild(durationElement);

          if (video.quality) {
            const qualityElement = document.createElement('div');
            qualityElement.className = 'video-quality';
            qualityElement.setAttribute('data-quality', video.quality);
            qualityElement.textContent = video.quality;
            qualityElement.style.cssText = 'position:absolute;top:5px;left:5px;padding:2px 4px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;';
            thumbnailElement.appendChild(qualityElement);
          } else if (video.file && video.size) {

            const estimatedQuality = getVideoQuality(video);
            if (estimatedQuality && estimatedQuality !== 'SD') {
              const qualityElement = document.createElement('div');
              qualityElement.className = 'video-quality';
              qualityElement.setAttribute('data-quality', estimatedQuality);
              qualityElement.textContent = estimatedQuality;
              qualityElement.style.cssText = 'position:absolute;top:5px;left:5px;padding:2px 4px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;';
              thumbnailElement.appendChild(qualityElement);
            }
          }

          const newBadgeText = typeof i18n !== 'undefined' ? i18n.t('video.newBadge', '–ù–æ–≤–∏–Ω–∫–∞') : '–ù–æ–≤–∏–Ω–∫–∞';
          if (video.created && (Date.now() - video.created) < 24 * 60 * 60 * 1000) {
            const newElement = document.createElement('div');
            newElement.className = 'video-new';
            newElement.textContent = newBadgeText;
            newElement.style.cssText = 'position:absolute;top:5px;right:5px;background:#ff4444;padding:2px 6px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;text-transform:uppercase;';
            thumbnailElement.appendChild(newElement);
          } else if (video.modified && (Date.now() - video.modified) < 24 * 60 * 60 * 1000) {

            const newElement = document.createElement('div');
            newElement.className = 'video-new';
            newElement.textContent = newBadgeText;
            newElement.style.cssText = 'position:absolute;top:5px;right:5px;background:#ff4444;padding:2px 6px;border-radius:2px;font-size:10px;color:#fff;z-index:3;font-weight:bold;text-transform:uppercase;';
            thumbnailElement.appendChild(newElement);
          }
          
          if (preview && preview !== null && preview.length > 50 && !preview.includes('blob:null/')) {
            try {

              const img = document.createElement('img');
              img.src = preview;
              img.style.cssText = 'width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0;z-index:1;';
              img.onerror = () => {
                debug.warn(`Preview image failed to load for ${video.name}`);
                img.style.display = 'none';

                thumbnailElement.dataset.previewLoaded = 'false';
              };
              thumbnailElement.appendChild(img);

              durationElement.style.cssText = 'position:absolute;bottom:5px;right:5px;background:rgba(0,0,0,0.8);padding:2px 4px;border-radius:2px;font-size:11px;color:#fff;z-index:2;';

              thumbnailElement.dataset.previewLoaded = 'true';
              previewLoadingState.set(video.name, 'loaded');
              
              debug.log(`Successfully loaded preview for: ${video.name}`);
            } catch (imgError) {
              debug.warn(`Failed to create preview image for ${video.name}:`, imgError);

              thumbnailElement.dataset.previewLoaded = 'false';
            }
          } else {

            const fallbackDiv = document.createElement('div');
            fallbackDiv.style.cssText = 'width:100%;height:100%;background:#eee;display:flex;align-items:center;justify-content:center;color:#111;font-size:10px;text-align:center;padding:5px;position:absolute;top:0;left:0;z-index:1;';
            fallbackDiv.textContent = escapeHtml(getFileNameWithoutExtension(video.name));
            thumbnailElement.appendChild(fallbackDiv);

            if (!video.file) {
              thumbnailElement.dataset.previewLoaded = 'false';
              debug.log(`No preview available for ${video.name}, marked for retry`);
            } else {

              thumbnailElement.dataset.previewLoaded = 'true';
            }
          }
          
        } catch (e) {
          debug.error('Error loading preview for', video.name, e);

          const isLatestVideo = thumbnailElement.classList.contains('latest-thumb');
          const durationClass = isLatestVideo ? 'latest-duration' : 'video-duration';
          
          thumbnailElement.innerHTML = `
            <div class="${durationClass}" style="position:absolute;bottom:5px;right:5px;background:rgba(0,0,0,0.8);padding:2px 4px;border-radius:2px;font-size:11px;color:#fff;z-index:2;">0:00</div>
            <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;position:absolute;top:0;left:0;z-index:1;">
              ${escapeHtml(getFileNameWithoutExtension(video.name))}
            </div>`;
        }
      }

      function createVideoCardPreviewTask(video, thumbnailElement) {
        return async () => {
          try {
            const { preview, duration } = await getPreviewAndDuration(video);
            if (preview) {
              thumbnailElement.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;">`;
            }
            const newDurationElement = document.createElement('div');
            newDurationElement.className = 'video-duration';
            newDurationElement.textContent = duration;
            thumbnailElement.appendChild(newDurationElement);
          } catch (e) {
            debug.error('Error loading preview for', video.name, e);
            thumbnailElement.innerHTML = `
              <div class="video-duration">0:00</div>
              <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                ${escapeHtml(getFileNameWithoutExtension(video.name))}
              </div>`;
          }
        };
      }

      async function renderSinglePlaylistCarousel(playlist) {

        clearAllHoverPreviews();
        
        const videoCarousel = document.getElementById(`carousel-${playlist.id}`);
        if (!videoCarousel) return;

        videoCarousel.innerHTML = '';

        const currentVideoPage = carouselVideoPages.get(playlist.id) || 1;
        const totalVideoPages = Math.ceil((playlist.videos ? playlist.videos.length : 0) / videosPerPage);
        const videoStart = (currentVideoPage - 1) * videosPerPage;
        const videoEnd = Math.min(videoStart + videosPerPage, playlist.videos ? playlist.videos.length : 0);

        const actualVideosPerPage = 6;

        const videosToRender = (playlist.videos || []).slice(videoStart, Math.min(videoStart + actualVideosPerPage, playlist.videos.length));
        if (videosToRender.length > 0) {
          for (const video of videosToRender) {
            const videoCard = document.createElement('div');
            videoCard.className = 'video-card';

            const thumbLink = document.createElement('a');
            thumbLink.className = 'video-thumbnail';
            thumbLink.dataset.videoName = video.name;
            const videoUrl = window.VideoID 
                ? window.VideoID.buildVideoUrl(video.name, playlist.id)
                : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlist.id || '')}`;
            thumbLink.href = videoUrl;
            thumbLink.innerHTML = `
              <div class="video-duration">...</div>
              <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                ${escapeHtml(getFileNameWithoutExtension(video.name))}
              </div>`;

            const foundVideo = allVideos.find(av => av.name === video.name);
            if (foundVideo) {
              if (!video.file || !video.handle) {
                Object.assign(video, foundVideo);
              } else {

                video.views = video.views || foundVideo.views || 0;
                video.created = video.created || foundVideo.created || foundVideo.modified || 0;
                video.tags = video.tags || foundVideo.tags || [];
              }
            }

            const infoElement = document.createElement('div');
            infoElement.className = 'video-info';

            const channelTags = (video.tags || []).filter(t => t.includes('(–∫–∞)'));
            let channelName = '';
            let channelDisplay = '';
            
            if (channelTags.length > 0) {
              channelName = channelTags[0].replace(' (–∫–∞)', '');
              const channelLinks = channelTags.map(t => {
                const cn = t.replace(' (–∫–∞)', '');
                return `<a href="youvi_ch_view.html?channel=${encodeURIComponent(cn)}" class="playlist-channel-link">${escapeHtml(cn)}</a>`;
              }).join(', ');
              channelDisplay = channelLinks;
            } else if (playlist.channelName) {
              channelName = playlist.channelName;
              channelDisplay = `<a href="youvi_ch_view.html?channel=${encodeURIComponent(playlist.channelName)}" class="playlist-channel-link">${escapeHtml(playlist.channelName)}</a>`;
            } else {
              channelDisplay = `<span>${typeof i18n !== 'undefined' ? i18n.t('video.noChannel', 'No channel') : 'No channel'}</span>`;
            }
            
            const channelInitial = channelName ? channelName.charAt(0).toUpperCase() : '?';
            const avatarId = `plAvatar_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
            
            const createdDateObj = video.created ? new Date(video.created) : (video.modified ? new Date(video.modified) : null);
            const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
            const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
            const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
            const danmakuCount = video.danmakuCount || 0;
            
            const zoom = window.devicePixelRatio || 1;
            
            const statsLine = `<div class="video-stats">${viewsSvg} ${(video.views||0).toLocaleString()} ‚Ä¢ ${danmakuSvg} ${danmakuCount}</div>`;
            const dateLine = dateStr ? `<div class="video-date">${dateStr}</div>` : '';
            
            infoElement.innerHTML = `
              <div class="video-card-title"><a href="${videoUrl}" class="video-title-link" style="color:inherit;text-decoration:none;" title="${escapeHtml(getFileNameWithoutExtension(video.name))}">${escapeHtml(getFileNameWithoutExtension(video.name))}</a></div>
              ${statsLine}
              <div class="video-card-meta-row">
                <a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" class="video-card-avatar-link" onclick="event.stopPropagation()">
                  <div class="video-card-avatar" id="${avatarId}">${channelInitial}</div>
                </a>
                <div class="video-card-text">
                  <div class="video-playlist">${channelDisplay}</div>
                  ${dateLine}
                </div>
              </div>
            `;

            if (channelName) {
              avatarLoadManager.load(channelName, avatarId);
            }

            videoCard.appendChild(thumbLink);
            videoCard.appendChild(infoElement);
            videoCarousel.appendChild(videoCard);

            if ((video.file && video.handle) || allVideos.find(av => av.name === video.name && av.file && av.handle)) {
              const videoData = video.file && video.handle ? video : allVideos.find(av => av.name === video.name && av.file && av.handle);
              addHoverPreview(thumbLink, videoData);
            }

            if (video.file && video.handle) {
              loadVideoPreviewImmediately(video, thumbLink);
            } else {

              const foundVideo = allVideos.find(av => av.name === video.name);
              if (foundVideo && foundVideo.file && foundVideo.handle) {
                loadVideoPreviewImmediately(foundVideo, thumbLink);
              } else {


                loadVideoPreviewImmediately(video, thumbLink);
              }
            }

            videoCard.addEventListener('click', () => {
              window.open(videoUrl, '_blank');
            });
          }

          attachTagClickListeners();

          requestAnimationFrame(() => {
            if (avatarLoadManager.pending.size > 0) {
              debug.log(`üé® Processing ${avatarLoadManager.pending.size} avatar requests for playlist carousel`);
              avatarLoadManager.processBatch();
            }
          });
        } else {
          const emptyMsg = typeof i18n !== 'undefined' ? i18n.t('main.noVideosInPlaylist', '–í —ç—Ç–æ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ –Ω–µ—Ç –≤–∏–¥–µ–æ.') : '–í —ç—Ç–æ–º –ø–ª–µ–π–ª–∏—Å—Ç–µ –Ω–µ—Ç –≤–∏–¥–µ–æ.';
          videoCarousel.innerHTML = `<div class="empty-state" style="padding: 20px; font-size: 14px;">${emptyMsg}</div>`;
        }

        const playlistSection = videoCarousel.closest('.playlist-section-carousel');
        const prevBtn = playlistSection.querySelector(`.prev-btn[data-playlist-id="${playlist.id}"]`);
        const nextBtn = playlistSection.querySelector(`.next-btn[data-playlist-id="${playlist.id}"]`);
        if (prevBtn) prevBtn.style.display = currentVideoPage > 1 ? 'flex' : 'none';
        if (nextBtn) nextBtn.style.display = currentVideoPage < totalVideoPages ? 'flex' : 'none';
      }

      function attachTagClickListeners() {
        document.querySelectorAll('.video-tag-link').forEach(tagLink => {
          tagLink.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const tag = e.target.dataset.tag;
            if (tag) {

              currentFilter = tag;
              currentPage = 1;
              updateUrlParameter('tag', tag);

              document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
              document.getElementById('allPlaylistsLink').classList.remove('active');

              const sidebarTag = document.querySelector(`[data-category="${category}"]`);
              if (sidebarTag) {
                sidebarTag.classList.add('active');
              }

              const latestSection = document.querySelector('.latest-section');
              if (latestSection) {
                const existingPagination = latestSection.querySelector('.pagination');
                if (existingPagination) {
                  existingPagination.remove();
                }
              }
              
              applyFiltersAndRender();
              updatePageTitle();

              window.scrollTo({ top: 0, behavior: 'smooth' });
            }
          });
        });

        document.querySelectorAll('.video-category-link').forEach(categoryLink => {
          categoryLink.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const category = e.target.dataset.category;
            if (category) {

              currentFilter = category;
              currentPage = 1;
              updateUrlParameter('tag', category);

              document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
              document.getElementById('allPlaylistsLink').classList.remove('active');

              const sidebarCategory = document.querySelector(`[data-category="${category}"]`);
              if (sidebarCategory) {
                sidebarCategory.classList.add('active');
              }

              const latestSection = document.querySelector('.latest-section');
              if (latestSection) {
                const existingPagination = latestSection.querySelector('.pagination');
                if (existingPagination) {
                  existingPagination.remove();
                }
              }
              
              applyFiltersAndRender();
              updatePageTitle();

              window.scrollTo({ top: 0, behavior: 'smooth' });
            }
          });
        });
      }

      function createPaginationButton(text, page){
        const btn = document.createElement('button');
        btn.className = 'btn pagination-btn';
        btn.textContent = text;
        btn.addEventListener('click', ()=>{
          currentPage = page;
          updateUrlParameter('page', page > 1 ? page : null);
          renderPlaylists();
          updatePageTitle();

          window.scrollTo(0, 0);
        });
        return btn;
      }

      function renderPagination(totalPages){
        const container = document.getElementById('paginationContainer');
        if (totalPages <= 1){ container.innerHTML = ''; return; }

        const pag = document.createElement('div');
        pag.className = 'pagination';
        container.style.textAlign = 'center';

        const info = document.createElement('div');
        info.className = 'pagination-info';
        const startItem = (currentPage - 1) * itemsPerPage + 1;
        const endItem = Math.min(currentPage * itemsPerPage, filteredPlaylists.length);
        const ofTxt = typeof i18n !== 'undefined' ? i18n.t('main.of', '–∏–∑') : '–∏–∑';
        const pageTxt = typeof i18n !== 'undefined' ? i18n.t('main.page', '—Å—Ç—Ä.') : '—Å—Ç—Ä.';
        info.textContent = `${startItem}-${endItem} ${ofTxt} ${filteredPlaylists.length} (${pageTxt} ${currentPage} ${ofTxt} ${totalPages})`;
        pag.appendChild(info);

        if (currentPage > 1) pag.appendChild(createPaginationButton('‚Äπ –ù–∞–∑–∞–¥', currentPage - 1));

        const maxVisible = 5;
        let s = Math.max(1, currentPage - Math.floor(maxVisible/2));
        let e = Math.min(totalPages, s + maxVisible - 1);
        if (e - s + 1 < maxVisible) s = Math.max(1, e - maxVisible + 1);

        if (s > 1){
          pag.appendChild(createPaginationButton('1', 1));
          if (s > 2) pag.appendChild(document.createTextNode(' ... '));
        }
        for (let i=s;i<=e;i++){
          const b = createPaginationButton(String(i), i);
          if (i === currentPage) b.classList.add('active');
          pag.appendChild(b);
        }
        if (e < totalPages){
          if (e < totalPages - 1) pag.appendChild(document.createTextNode(' ... '));
          pag.appendChild(createPaginationButton(String(totalPages), totalPages));
        }

        if (currentPage < totalPages) {
          const nextTxt = typeof i18n !== 'undefined' ? i18n.t('pagination.next', '–í–ø–µ—Ä–µ–¥') : '–í–ø–µ—Ä–µ–¥';
          pag.appendChild(createPaginationButton(nextTxt + ' ‚Ä∫', currentPage + 1));
        }

        container.innerHTML = '';
        container.appendChild(pag);
      }

      function getFileNameWithoutExtension(name){ return name.replace(/\.[^/.]+$/,''); }
      function formatFileSize(b){ if (b<1024) return b+' B'; if (b<1048576) return (b/1024).toFixed(1)+' KB'; return (b/1048576).toFixed(1)+' MB'; }
      function formatDuration(sec){
        if (!isFinite(sec)||isNaN(sec)||sec<=0) return '0:00';
        const s = Math.round(sec);
        const h = Math.floor(s/3600);
        const m = Math.floor((s%3600)/60);
        const ss = String(s%60).padStart(2,'0');
        return h > 0 ? `${h}:${String(m).padStart(2,'0')}:${ss}` : `${m}:${ss}`;
      }
      function getViewsText(count){
        const n = Math.abs(Number(count)||0) % 100; const n1 = n % 10;

        const lang = typeof i18n !== 'undefined' ? i18n.getCurrentLanguage() : 'ru';
        if (lang === 'en') {
          return count === 1 ? 'view' : 'views';
        } else if (lang === 'uk') {
          if (n>10 && n<20) return '–ø–µ—Ä–µ–≥–ª—è–¥—ñ–≤';
          if (n1===1) return '–ø–µ—Ä–µ–≥–ª—è–¥';
          if (n1>=2 && n1<=4) return '–ø–µ—Ä–µ–≥–ª—è–¥–∏';
          return '–ø–µ—Ä–µ–≥–ª—è–¥—ñ–≤';
        } else {

          if (n>10 && n<20) return '–ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤';
          if (n1===1) return '–ø—Ä–æ—Å–º–æ—Ç—Ä';
          if (n1>=2 && n1<=4) return '–ø—Ä–æ—Å–º–æ—Ç—Ä–∞';
          return '–ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤';
        }
      }
      
      function naturalSortByName(arr) {
        return [...arr].sort((a, b) => {
          const an = getFileNameWithoutExtension(a.name) || '';
          const bn = getFileNameWithoutExtension(b.name) || '';
          return an.localeCompare(bn, undefined, { numeric: true, sensitivity: 'base' });
        });
      }
      
      function escapeHtml(text){ const d=document.createElement('div'); d.textContent = text ?? ''; return d.innerHTML; }

      async function loadRandomBanner(bannerElement) {
        try {
          const banners = [
            'images/banners/youvi_banner_1.png',
            'images/banners/youvi_banner_2.png'
          ];

          const randomBanner = banners[Math.floor(Math.random() * banners.length)];

          bannerElement.style.backgroundImage = `url('${randomBanner}')`;
          
          debug.log('Loaded random banner:', randomBanner);
        } catch (e) {
          debug.error('Error loading random banner:', e);

          bannerElement.style.backgroundImage = "url('images/banners/8site_banner.png')";
        }
      }

      function getVideoQuality(video) {

        if (video.quality) {
          return video.quality;
        }

        const name = video.name.toLowerCase();
        if (name.includes('4k') || name.includes('2160p') || name.includes('uhd')) {
          return '4K';
        } else if (name.includes('1080p') || name.includes('fhd')) {
          return '1080p';
        } else if (name.includes('720p') || name.includes('hd')) {
          return '720p';
        } else if (name.includes('480p') || name.includes('sd')) {
          return '480p';
        }

        const sizeInMB = video.size / (1024 * 1024);
        if (sizeInMB > 1000) return '4K';
        if (sizeInMB > 500) return '1080p';
        if (sizeInMB > 200) return '720p';
        if (sizeInMB > 50) return '480p';
        
        return 'SD';
      }

      function naturalSort(a, b) {
          const normalize = (s) => s.replace(/–µ/g, 'e');
          
          const chunkify = (s) => {
              const match = s.match(/\D+|\d+/g);
              return match ? match.map(c => isNaN(c) ? c.toLowerCase() : parseInt(c, 10)) : [];
          };

          const aChunks = chunkify(normalize(String(a)));
          const bChunks = chunkify(normalize(String(b)));

          for (let i = 0; i < Math.min(aChunks.length, bChunks.length); i++) {
              const aChunk = aChunks[i];
              const bChunk = bChunks[i];

              if (typeof aChunk === 'number' && typeof bChunk === 'number') {
                  if (aChunk < bChunk) return -1;
                  if (aChunk > bChunk) return 1;
              } else if (typeof aChunk === 'string' && typeof bChunk === 'string') {
                  const cmp = aChunk.localeCompare(bChunk, 'ru', { numeric: false, caseFirst: 'lower' });
                  if (cmp !== 0) return cmp;
              } else if (typeof aChunk === 'number') {
                  return -1;
              } else {
                  return 1;
              }
          }

          return aChunks.length - bChunks.length;
      }



function sortVideos(videos) {
    debug.log('sortVideos called with currentSort:', currentSort, 'videos count:', videos.length);
    const sorted = videos.slice();
    
    switch (currentSort) {
        case 'alphabetical':
            return sorted.sort((a, b) => naturalSort(
                getFileNameWithoutExtension(a.name || ''), 
                getFileNameWithoutExtension(b.name || '')
            ));
            
        case 'new':
            return sorted.sort((a, b) => {
                const dateA = a.created || a.modified || 0;
                const dateB = b.created || b.modified || 0;

                if (dateA !== dateB) {
                    return dateB - dateA;
                }

                return naturalSort(
                    getFileNameWithoutExtension(a.name || ''), 
                    getFileNameWithoutExtension(b.name || '')
                );
            });
            
        case 'old':
            return sorted.sort((a, b) => {
                const dateA = a.created || a.modified || 0;
                const dateB = b.created || b.modified || 0;

                if (dateA !== dateB) {
                    return dateA - dateB;
                }

                return naturalSort(
                    getFileNameWithoutExtension(a.name || ''), 
                    getFileNameWithoutExtension(b.name || '')
                );
            });
            
        case 'popular':
            return sorted.sort((a, b) => {
                const viewsA = a.views || 0;
                const viewsB = b.views || 0;
                
                if (viewsA === viewsB) {
                    return naturalSort(
                        getFileNameWithoutExtension(a.name || ''), 
                        getFileNameWithoutExtension(b.name || '')
                    );
                }
                return viewsB - viewsA;
            });
            
        case 'random':
            return sorted.sort(() => Math.random() - 0.5);
            
        case 'danmaku':
            return sorted.sort((a, b) => {
                const danmakuA = a.danmakuCount || 0;
                const danmakuB = b.danmakuCount || 0;
                
                if (danmakuA === danmakuB) {
                    return naturalSort(
                        getFileNameWithoutExtension(a.name || ''), 
                        getFileNameWithoutExtension(b.name || '')
                    );
                }
                return danmakuB - danmakuA;
            });
            
        default:

            return sorted.sort((a, b) => {
                const dateA = a.created || a.modified || 0;
                const dateB = b.created || b.modified || 0;

                if (dateA !== dateB) {
                    return dateB - dateA;
                }

                return naturalSort(
                    getFileNameWithoutExtension(a.name || ''), 
                    getFileNameWithoutExtension(b.name || '')
                );
            });
    }
}

      function sortPlaylists(playlists) {
          switch (currentSort) {
              case 'new':
                  return playlists.slice().sort((a, b) => (b.created||0)-(a.created||0));
              case 'popular':
                  return playlists.slice().sort((a, b) => (b.views||0)-(a.views||0));
              case 'old':
                  return playlists.slice().sort((a, b) => (a.created||0)-(b.created||0));
              case 'alphabetical':
                  return playlists.slice().sort((a, b) => naturalSort(a.title || '', b.title || ''));
              case 'random':
                  return playlists.slice().sort(() => Math.random() - 0.5);
              default:
                  return playlists.slice().sort((a, b) => (b.created||0)-(a.created||0));
          }
      }

      function getSortDisplayName(sortType) {
          switch (sortType) {
              case 'new':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortNew', '–°–≤–µ–∂–∏–µ') : '–°–≤–µ–∂–∏–µ';
              case 'popular':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortPopular', '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ') : '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ';
              case 'old':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortOld', '–°—Ç–∞—Ä—ã–µ') : '–°—Ç–∞—Ä—ã–µ';
              case 'alphabetical':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortAlphabetical', '–ü–æ –∞–ª—Ñ–∞–≤–∏—Ç—É') : '–ü–æ –∞–ª—Ñ–∞–≤–∏—Ç—É';
              case 'random':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortRandom', '–°–ª—É—á–∞–π–Ω—ã–µ') : '–°–ª—É—á–∞–π–Ω—ã–µ';
              case 'danmaku':
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortDanmaku', '–ü–æ –¥–∞–Ω–º–∞–∫—É') : '–ü–æ –¥–∞–Ω–º–∞–∫—É';
              default:
                  return typeof i18n !== 'undefined' ? i18n.t('sidebar.sortNew', '–°–≤–µ–∂–∏–µ') : '–°–≤–µ–∂–∏–µ';
          }
      }

      function updateSectionTitle() {
          const titleElement = document.getElementById('latestTitle');
          if (!titleElement) return;
          
          let title = '';

          if (currentFilter && currentFilter !== 'all') {
              title += `${currentFilter} - `;
          }

          const t = (key, def) => typeof i18n !== 'undefined' ? i18n.t(key, def) : def;
          const videosWord = t('main.videos', '–≤–∏–¥–µ–æ');
          switch (currentSort) {
              case 'new':
                  title += t('main.latestVideos', '–°–≤–µ–∂–∏–µ –≤–∏–¥–µ–æ');
                  break;
              case 'popular':
                  title += t('main.popularVideos', '–ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –≤–∏–¥–µ–æ');
                  break;
              case 'old':
                  title += t('main.oldVideos', '–°—Ç–∞—Ä—ã–µ –≤–∏–¥–µ–æ');
                  break;
              case 'alphabetical':
                  title += t('main.alphabeticalVideos', '–í–∏–¥–µ–æ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É');
                  break;
              case 'random':
                  title += t('main.randomVideos', '–°–ª—É—á–∞–π–Ω—ã–µ –≤–∏–¥–µ–æ');
                  break;
              case 'danmaku':
                  title += t('main.danmakuVideos', '–ü–æ –¥–∞–Ω–º–∞–∫—É');
                  break;
              default:
                  title += t('main.latestVideos', '–°–≤–µ–∂–∏–µ –≤–∏–¥–µ–æ');
          }
          
          titleElement.textContent = title;
      }

      function renderSidebarCategories() {
        const categoriesContainer = document.getElementById('sidebarTagsContainer');
        if (!categoriesContainer) return;
        categoriesContainer.innerHTML = '';

        const tagTypeConfig = {
          'ct': { limit: 3, color: '#67c5d6', label: '–ö–∞—Ç–µ–≥–æ—Ä–∏–∏' },
          'gt': { limit: 15, color: '#6b7280', label: '–û–±—â–∏–µ' },
          'au': { limit: 3, color: '#ef6c7d', label: '–ê–≤—Ç–æ—Ä—ã' },
          'st': { limit: 3, color: '#f28b8b', label: '–°—Ç—É–¥–∏–∏' },
          'yr': { limit: 4, color: '#eab676', label: '–ì–æ–¥—ã' },
          'at': { limit: 3, color: '#a78bdb', label: '–ê–Ω–∏–º–µ' },
          'ser': { limit: 1, color: '#8db8d6', label: '–°–µ—Ä–∏–∞–ª—ã' },
          'mt': { limit: 1, color: '#d4a373', label: '–§–∏–ª—å–º—ã' },
          'nat': { limit: 1, color: '#9dd6a8', label: '–ê–Ω–∏–º–∞—Ü–∏—è' },
          'ra': { limit: 3, color: '#f5a3c7', label: '–†–µ–π—Ç–∏–Ω–≥' },
          'ge': { limit: 0, color: '#6b9bd1', label: '–ñ–∞–Ω—Ä—ã' },
          'tp': { limit: 0, color: '#f59e6c', label: '–¢–∏–ø—ã' },
          'ch': { limit: 0, color: '#6b9e4d', label: '–ü–µ—Ä—Å–æ–Ω–∞–∂–∏' }
        };

        function parseTagType(tagString) {
          if (!tagString) return null;
          const match = tagString.trim().match(/\(([a-z–∞-—è]{2,3})\)$/iu);
          return match ? match[1].toLowerCase() : null;
        }

        function parseTagContent(tagString) {
          if (!tagString) return tagString;
          const match = tagString.trim().match(/^(.+?)\s*\([a-z–∞-—è]{2,3}\)$/iu);
          return match ? match[1].trim() : tagString;
        }

        const tagsByType = {};
        for (const typeCode in tagTypeConfig) {
          tagsByType[typeCode] = new Map();
        }

        for (const video of allVideos) {
          if (video.tags && video.tags.length > 0) {
            for (const tag of video.tags) {
              const typeCode = parseTagType(tag);

              if (typeCode && typeCode !== '–∫–∞' && tagsByType[typeCode]) {
                const fullTag = tag;
                tagsByType[typeCode].set(fullTag, (tagsByType[typeCode].get(fullTag) || 0) + 1);
              }
            }
          }
        }

        let totalRendered = 0;
        for (const typeCode in tagTypeConfig) {
          const config = tagTypeConfig[typeCode];
          if (config.limit === 0) continue;
          
          const tagsOfType = tagsByType[typeCode];
          if (tagsOfType.size === 0) continue;

          const sortedTags = Array.from(tagsOfType.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, config.limit);

          sortedTags.forEach(([tag, count]) => {
            const tagItem = document.createElement('a');
            tagItem.href = '#';
            tagItem.className = 'sidebar-item';
            tagItem.style.display = 'flex';
            tagItem.style.justifyContent = 'space-between';
            tagItem.style.alignItems = 'center';
            
            const content = parseTagContent(tag);
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = content;
            nameSpan.style.color = config.color;
            
            const countSpan = document.createElement('span');
            countSpan.textContent = count;
            countSpan.style.color = '#999';
            countSpan.style.marginLeft = '8px';
            countSpan.style.marginRight = '12px';
            countSpan.style.flexShrink = '0';
            
            tagItem.appendChild(nameSpan);
            tagItem.appendChild(countSpan);
            tagItem.dataset.category = tag;
            
            tagItem.addEventListener('click', (e) => {
              e.preventDefault();
              filterPlaylistsByCategory(tag);
            });
            categoriesContainer.appendChild(tagItem);
            totalRendered++;
          });
        }

        if (totalRendered === 0) {
          categoriesContainer.innerHTML = '<span class="sidebar-item">–ù–µ—Ç —Ç–µ–≥–æ–≤</span>';
          return;
        }

        document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        const allLinkEl = document.getElementById('allPlaylistsLink');
        if (allLinkEl) allLinkEl.classList.remove('active');

        if (currentFilter === 'all') {
          if (allLinkEl) allLinkEl.classList.add('active');
        } else {
          const activeTagElement = document.querySelector(`[data-category="${CSS.escape(currentFilter)}"]`);
          if (activeTagElement) {
            activeTagElement.classList.add('active');
          }
        }
      }

      function filterPlaylistsByCategory(category) {
        document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        document.getElementById('allPlaylistsLink').classList.remove('active');

        if (category === currentFilter) {
          currentFilter = 'all';
          document.getElementById('allPlaylistsLink').classList.add('active');
        } else {
          currentFilter = category;

          const clickedTagElement = document.querySelector(`[data-category="${category}"]`);
          if (clickedTagElement) {
            clickedTagElement.classList.add('active');
          }
        }

        updateUrlParameter('tag', currentFilter === 'all' ? null : currentFilter);

        currentPage = 1; 

        const latestSection = document.querySelector('.latest-section');
        if (latestSection) {
          const existingPagination = latestSection.querySelector('.pagination');
          if (existingPagination) {
            existingPagination.remove();
          }
        }
        
        applyFiltersAndRender();
        updatePageTitle();
        updateSectionTitle();

        window.scrollTo({ top: 0, behavior: 'smooth' });
      }


      let applyFiltersTimeout = null;
      function applyFiltersAndRender() {

        if (applyFiltersTimeout) {
          clearTimeout(applyFiltersTimeout);
        }

        const now = Date.now();
        if (now - lastRenderTime < RENDER_DEBOUNCE_MS) {
          debug.log('‚ö° Debouncing render call');
        }
        
        applyFiltersTimeout = setTimeout(() => {
          lastRenderTime = Date.now();
          applyFiltersAndRenderImmediate();
        }, RENDER_DEBOUNCE_MS);
      }
      
      function applyFiltersAndRenderImmediate() {

        previewLoadingState.clear();

        taskQueue.clear();


        filteredPlaylists = allPlaylists;

        renderPlaylists();

        renderLatestVideos();

        updatePageTitle();
        updateSectionTitle();

        document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        const activeSortElement = document.getElementById(`sort${currentSort.charAt(0).toUpperCase() + currentSort.slice(1)}`);
        if (activeSortElement) {
            activeSortElement.classList.add('active');
        }

        document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        if (currentFilter === 'all') {
            document.getElementById('allPlaylistsLink').classList.add('active');
        } else {
            const activeTagElement = document.querySelector(`[data-category="${currentFilter}"]`);
            if (activeTagElement) {
                activeTagElement.classList.add('active');
            }
        }
      }

      document.addEventListener('DOMContentLoaded', async ()=>{

        const langSwitcher = document.getElementById('langSwitcher');
        if (langSwitcher && typeof i18n !== 'undefined') {

          langSwitcher.value = i18n.getCurrentLanguage();

          langSwitcher.addEventListener('change', async (e) => {
            await i18n.setLanguage(e.target.value);

            if (typeof applyFiltersAndRender === 'function') {
              applyFiltersAndRender();
            }
            updatePageTitle();
          });
        }
        
        if (!supportsFS){
          const container = document.getElementById('playlistsContainer');
          if (container) {
            const fsError = typeof i18n !== 'undefined' ? i18n.t('errors.fsNotSupported', 'File System API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome/Edge.') : 'File System API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Chrome/Edge.';
            container.innerHTML = `<div class="empty-state" style="color:red"><strong>${fsError}</strong></div>`;
          }
          return;
        }

        const loadingMsg = typeof i18n !== 'undefined' ? i18n.t('main.loadingVideos', '–ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ...') : '–ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ...';
        showLoadingIndicator(loadingMsg);

        showSkeletonLoading();

        reservePlaylistSpace();

        let initialLoadComplete = false;
        
        try{
          db = await openDB();
          const savedHandle = await getFromDB(db, 'videoDirectoryHandle');
          if (savedHandle){
            const perm = await savedHandle.queryPermission();
            if (perm === 'granted' || (perm === 'prompt' && await savedHandle.requestPermission() === 'granted')){
              videoDirectoryHandle = savedHandle;

              const currentHandle = await getFromDB(db, 'currentFolderPath');
              if (currentHandle !== savedHandle.name) {
                debug.log('New folder detected, clearing cache...');
                await clearCache();
                await saveToDB(db, 'currentFolderPath', savedHandle.name);
              }
              
              updateLoadingProgress(20);

              await loadAllVideosProgressive(); 
              updateLoadingProgress(60);

              await loadAllPlaylists(); 
              updateLoadingProgress(80);
              
              currentFilter = currentFilter;
              applyFiltersAndRender(); 
              updatePageTitle();
              
              updateLoadingProgress(100);
              hideLoadingIndicator();

              // Load danmaku counts in background after page is ready
              requestIdleCallback(() => loadAllDanmakuCounts(), { timeout: 2000 });

              renderSubscribedChannelsList();

              const searchInput = document.getElementById('globalSearch');
              debug.log('[Autocomplete Init] searchInput:', searchInput);
              debug.log('[Autocomplete Init] AutocompleteIntegration available:', typeof AutocompleteIntegration);
              debug.log('[Autocomplete Init] Data available:', {
                videoDirectoryHandle: !!videoDirectoryHandle,
                videosCount: allVideos.length,
                playlistsCount: allPlaylists.length
              });
              
              if (searchInput) {
                try {



                  const playlistsForAutocomplete = allPlaylistsComplete.length > 0 ? allPlaylistsComplete : allPlaylists;
                  
                  debug.log('[Autocomplete Init] Using main page data:', {
                    videos: allVideos.length,
                    playlists: playlistsForAutocomplete.length,
                    playlistsFiltered: allPlaylists.length
                  });

                  const cacheValid = await window.autocompleteCache.isCacheValid(
                    allVideos.length,
                    playlistsForAutocomplete.length
                  );

                  const autocompleteIntegration = new AutocompleteIntegration();
                  await autocompleteIntegration.init(searchInput, {
                    videoDirectoryHandle: videoDirectoryHandle,
                    allVideos: cacheValid ? [] : allVideos,
                    allPlaylists: cacheValid ? [] : playlistsForAutocomplete,
                    
                    onTagSelect: (tagName) => {
                      searchByTag(tagName);
                    },
                    
                    onVideoSelect: (videoName) => {
                      window.location.href = `youvi_video.html?v=${encodeURIComponent(videoName)}`;
                    },
                    
                    onPlaylistSelect: (playlistId) => {
                      window.location.href = `youvi_playlists_view.html?id=${playlistId}`;
                    },
                    
                    onChannelSelect: (channelName) => {
                      filterByChannel(channelName, null);
                    }
                  });
                  debug.log('[Autocomplete Init] ‚úÖ Successfully initialized with main page data!');
                } catch (error) {
                  debug.error('[Autocomplete Init] Failed to initialize:', error);
                }
              } else {
                debug.warn('[Autocomplete Init] Search input not found!');
              }


            if (currentFilter && currentFilter !== 'all') {
                const activeTagItem = document.querySelector(`[data-category="${currentFilter}"]`);
                if (activeTagItem) {
                    activeTagItem.classList.add('active');
                }
            } else {
                document.getElementById('allPlaylistsLink').classList.add('active');
            }

            }else{
              const container = document.getElementById('playlistsContainer');
              if (container) {
                container.innerHTML = '<div class="empty-state"><strong>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–µ —Å –≤–∏–¥–µ–æ</strong></div>';
              }
            }
          }else{
            const container = document.getElementById('playlistsContainer');
            if (container) {
              container.innerHTML = '<div class="empty-state"><strong>–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É —Å –≤–∏–¥–µ–æ –Ω–∞ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ</strong></div>';
            }
          }

          const playlistSearchInput = document.getElementById('globalSearch');
          const playlistSearchBtn = document.getElementById('doSearch');

          if (playlistSearchInput && playlistSearchBtn) {

            const goToSearch = () => {
              const q = (playlistSearchInput.value || '').trim();
              const params = new URLSearchParams();
              if (q) params.set('q', q);
              window.location.href = `youvi_search.html${params.toString() ? '?' + params.toString() : ''}`;
            };

            playlistSearchBtn.addEventListener('click', (e) => {
              e.preventDefault();
              goToSearch();
            });

            playlistSearchInput.addEventListener('keypress', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                goToSearch();
              }
            });
          }

          const initialSortElement = document.getElementById(`sort${currentSort.charAt(0).toUpperCase() + currentSort.slice(1)}`);
          if (initialSortElement) {
            initialSortElement.classList.add('active');
          }

          document.getElementById('sortNew').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'new';
            localStorage.setItem('playlistSort', 'new');
            updateUrlParameter('sort', 'new');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });

          document.getElementById('sortPopular').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'popular';
            localStorage.setItem('playlistSort', 'popular');
            updateUrlParameter('sort', 'popular');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });

          document.getElementById('sortOld').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'old';
            localStorage.setItem('playlistSort', 'old');
            updateUrlParameter('sort', 'old');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });

          document.getElementById('sortRandom').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'random';
            localStorage.setItem('playlistSort', 'random');
            updateUrlParameter('sort', 'random');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });

          document.getElementById('sortAlphabetical').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'alphabetical';
            localStorage.setItem('playlistSort', 'alphabetical');
            updateUrlParameter('sort', 'alphabetical');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });

          document.getElementById('sortDanmaku').addEventListener('click', (e) => {
            e.preventDefault();
            currentSort = 'danmaku';
            localStorage.setItem('playlistSort', 'danmaku');
            updateUrlParameter('sort', 'danmaku');
            currentPage = 1;
            applyFiltersAndRender();

            document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
          });
          
        }catch(e){
          debug.error('FS access error', e);
          const container = document.getElementById('playlistsContainer');
          if (container) {
            container.innerHTML = '<div class="empty-state" style="color:red"><strong>–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ</strong></div>';
          }
        }

            const allPlaylistsLink = document.getElementById('allPlaylistsLink');
            if (allPlaylistsLink) {
                allPlaylistsLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    currentFilter = 'all';
                    currentPage = 1;
                    currentSearchQuery = '';
                    const searchInput = document.getElementById('headerSearchInput');
                    if (searchInput) searchInput.value = '';
                    updateUrlParameter('tag', null);
                    updateUrlParameter('page', null);
                    applyFiltersAndRender();

                    document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
                    allPlaylistsLink.classList.add('active');

                    document.querySelectorAll('#sortOptionsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
                    const activeSortElement = document.getElementById(`sort${currentSort.charAt(0).toUpperCase() + currentSort.slice(1)}`);
                    if (activeSortElement) {
                        activeSortElement.classList.add('active');
                    }
                });

                const settingsButton = document.getElementById('badgesToggle');
                if (settingsButton) {
                    settingsButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        toggleVideoBadges();
                    });
                }

                initializeBadgesState();

            }

            const forceRefreshBtn = document.getElementById('forceRefreshBtn');
            if (forceRefreshBtn) {
              forceRefreshBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                if (confirm('–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à –∏ –ø–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –≤–∏–¥–µ–æ? –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.')) {

                  forceRefreshCache();
                  location.reload();
                }
              });
            }
        });

      window.addEventListener('adaptiveGridChanged', (e) => {
        debug.log('[youvi_main] Adaptive grid changed:', e.detail);





        if (typeof renderMixedContent === 'function') {
          renderMixedContent();
        }

        requestAnimationFrame(() => {
          avatarLoadManager.reapplyAllCached();
        });
      });

      function updateUrlParameter(param, value) {
        const url = new URL(window.location.href);
        if (value && value !== 'new') {
          url.searchParams.set(param, value);
        } else {
          url.searchParams.delete(param);
        }
        window.history.replaceState({}, '', url.toString());
      }

      function updatePageTitle() {
        let titleParts = [];
        const baseTitle = 'Youvi';
        const t = (key, def) => typeof i18n !== 'undefined' ? i18n.t(key, def) : def;

        if (currentFilter && currentFilter !== 'all') {
          titleParts.push(currentFilter);
        }

        if (currentSearchQuery) {
          titleParts.push(`"${currentSearchQuery}"`);
        }

        if (currentPage > 1) {
          titleParts.push(`${t('main.pageLabel', '–°—Ç—Ä–∞–Ω–∏—Ü–∞')} ${currentPage}`);
        }

        if (titleParts.length > 0) {
          document.title = `${titleParts.join(' | ')} | ${baseTitle}`;
        } else {
          document.title = `${t('sidebar.home', '–ì–ª–∞–≤–Ω–∞—è')} | ${baseTitle}`;
        }
      }

      function searchByTag(tag) {
        currentFilter = tag;
        currentPage = 1;
        currentSearchQuery = '';

        const searchInput = document.getElementById('headerSearchInput');
        if (searchInput) {
          searchInput.value = '';
        }

        updateUrlParameter('tag', tag);
        updateUrlParameter('search', null);
        updateUrlParameter('page', null);

        document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        document.getElementById('allPlaylistsLink').classList.remove('active');

        const sidebarTag = document.querySelector(`[data-category="${tag}"]`);
        if (sidebarTag) {
          sidebarTag.classList.add('active');
        }

        const latestSection = document.querySelector('.latest-section');
        if (latestSection) {
          const existingPagination = latestSection.querySelector('.pagination');
          existingPagination.remove();
        }

        applyFiltersAndRender();
        updatePageTitle();
        updateSectionTitle();

        window.scrollTo({ top: 0, behavior: 'smooth' });
      }

      function toggleVideoBadges() {
        const body = document.body;
        const isHidden = body.classList.contains('badges-hidden');

        if (isHidden) {

          body.classList.remove('badges-hidden');
          localStorage.setItem('videoBadgesHidden', 'false');
        } else {

          body.classList.add('badges-hidden');
          localStorage.setItem('videoBadgesHidden', 'true');
        }
      }

      function initializeBadgesState() {
        const badgesHidden = localStorage.getItem('videoBadgesHidden');
        if (badgesHidden === 'true') {
          document.body.classList.add('badges-hidden');
        }
      }

      async function loadSubscriptionsFromFile() {
        try {

          const localSubscriptions = localStorage.getItem('8site_subscriptions');
          if (localSubscriptions) {
            return JSON.parse(localSubscriptions);
          }

          if (!videoDirectoryHandle) return null;

          const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
          const file = await subscriptionsFile.getFile();
          const text = await file.text();
          const fileSubscriptions = JSON.parse(text);

          localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
          return fileSubscriptions;
        } catch (e) {
          debug.log('No subscriptions found, using default');
          return null;
        }
      }

      async function renderSubscribedChannelsList() {
        const sidebarContainer = document.getElementById('subscribedChannelsContainer');
        if (!sidebarContainer) return;

        try {
          const savedSubscriptions = await loadSubscriptionsFromFile();
          const subscribedChannels = Array.isArray(savedSubscriptions) ? savedSubscriptions : [];

          sidebarContainer.innerHTML = '';

          if (subscribedChannels.length === 0) {
            const noSubs = document.createElement('div');
            noSubs.className = 'sidebar-item';
            noSubs.textContent = '–ù–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫';
            noSubs.style.fontStyle = 'italic';
            noSubs.style.color = '#999';
            sidebarContainer.appendChild(noSubs);
            return;
          }

          subscribedChannels.forEach((channelName, index) => {
            const link = document.createElement('a');
            link.href = '#';
            link.className = 'sidebar-item';
            link.dataset.channel = channelName;
            link.id = `sidebar_channel_${index}`;
            link.style.display = 'flex';
            link.style.alignItems = 'center';
            link.style.gap = '8px';

            const avatarId = `sidebarAvatar_${index}`;
            const avatar = document.createElement('div');
            avatar.id = avatarId;
            avatar.style.cssText = `
              width: 20px;
              height: 20px;
              border-radius: 0;
              background: #ff69b4;
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-weight: bold;
              font-size: 10px;
              flex-shrink: 0;
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              cursor: pointer;
            `;
            avatar.textContent = channelName.charAt(0).toUpperCase();
            avatar.title = '–ü–µ—Ä–µ–π—Ç–∏ –∫ –∫–∞–Ω–∞–ª—É';

            const textSpan = document.createElement('span');
            textSpan.textContent = channelName;
            textSpan.style.overflow = 'hidden';
            textSpan.style.textOverflow = 'ellipsis';
            textSpan.style.whiteSpace = 'nowrap';
            textSpan.style.flex = '1';

            link.appendChild(avatar);
            link.appendChild(textSpan);

            avatar.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
            });

            textSpan.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
            });

            loadChannelAvatar(channelName, videoDirectoryHandle).then(avatarUrl => {
              if (avatarUrl) {
                avatar.style.backgroundImage = `url(${avatarUrl})`;
                avatar.textContent = '';
              }
            }).catch(() => {

            });

            sidebarContainer.appendChild(link);
          });
        } catch (e) {
          debug.error('Error loading subscriptions:', e);
          sidebarContainer.innerHTML = '<div class="sidebar-item" style="font-style: italic; color: #999;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</div>';
        }
      }




      async function readJSONFile(dirHandle, name, defaultValue = null) {
        try {
          const fileHandle = await dirHandle.getFileHandle(name);
          const file = await fileHandle.getFile();
          const text = await file.text();
          return JSON.parse(text);
        } catch (e) {
          return defaultValue;
        }
      }

      async function loadImageFile(dirHandle, name) {
        try {
          const fileHandle = await dirHandle.getFileHandle(name);
          const file = await fileHandle.getFile();
          return URL.createObjectURL(file);
        } catch (e) {
          return null;
        }
      }

      function filterByChannel(channelName, linkId) {

        currentFilter = channelName;
        currentPage = 1;

        updateUrlParameter('tag', channelName);

        document.querySelectorAll('#sidebarTagsContainer .sidebar-item').forEach(item => item.classList.remove('active'));
        document.getElementById('allPlaylistsLink').classList.remove('active');

        const sidebarChannel = document.getElementById(linkId);
        if (sidebarChannel) {
          sidebarChannel.classList.add('active');
        }

        const latestSection = document.querySelector('.latest-section');
        if (latestSection) {
          const existingPagination = latestSection.querySelector('.pagination');
          if (existingPagination) {
            existingPagination.remove();
          }
        }

        applyFiltersAndRender();
        updatePageTitle();
        updateSectionTitle();

        window.scrollTo({ top: 0, behavior: 'smooth' });
      }


    </script>
    
    <!-- Mobile Bottom Navigation (5 Buttons) -->
    <nav class="mobile-bottom-nav">
        <a href="youvi_main.html" class="mobile-nav-item active">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                <polyline points="9,22 9,12 15,12 15,22"/>
            </svg>
            <span>–ì–ª–∞–≤–Ω–∞—è</span>
        </a>
        
        <a href="youvi_feed_all.html" class="mobile-nav-item">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <path d="M4 11a9 9 0 0 1 9 9"/>
                <path d="M4 4a16 16 0 0 1 16 16"/>
                <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
            </svg>
            <span>Feed</span>
        </a>

        <!-- Central Action / Upload Button -->
        <a href="#" class="mobile-nav-item upload-btn">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="16"/>
                <line x1="8" y1="12" x2="16" y2="12"/>
            </svg>
            <span>–°–æ–∑–¥–∞—Ç—å</span>
        </a>

        <a href="youvi_subscriptions.html" class="mobile-nav-item">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect>
                <polyline points="17 2 12 7 7 2"></polyline>
            </svg>
            <span>–ü–æ–¥–ø–∏—Å–∫–∏</span>
        </a>

        <!-- Menu / Library Button -->
        <a href="#" class="mobile-nav-item" id="mobileMenuBtn">
            <svg viewBox="0 0 24 24" stroke-width="1.5">
                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
            </svg>
            <span>–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞</span>
        </a>
    </nav>
</body>
</html>