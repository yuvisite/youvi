<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n-title="channelFeed.pageTitle">Лента канала | Youvi</title>
    <script>
        (function() {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            
            var htmlClasses = [];
            if (theme === 'dark') htmlClasses.push('dark-theme');
            else if (theme === 'skeuo') htmlClasses.push('skeuo-theme');
            if (sidebar === 'true') htmlClasses.push('sidebar-collapsed');
            if (htmlClasses.length) document.documentElement.className = htmlClasses.join(' ');
        })();
    </script>
    <link rel="stylesheet" href="youvi/header/youvi-header.css">
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/header/youvi-header.js"></script>
    
    <!-- i18n System -->
    <script src="youvi/i18n/ru.js"></script>
    <script src="youvi/i18n/en.js"></script>
    <script src="youvi/i18n/uk.js"></script>
    <script src="youvi/i18n/i18n.js"></script>
    
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi_video_comments_feed_legacy.css">
    
    <!-- Theme System -->
    <link rel="stylesheet" href="youvi/themes/dark-theme.css?v=7">
    <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    
    <style>
        
        .comment-image {
            transition: all 0.3s ease;
            opacity: 1 !important;
            filter: none !important;
        }
        
        .comment-image.loaded {
            opacity: 1 !important;
            filter: none !important;
        }
        
        .image-container {
            position: relative;
            display: inline-block;
        }
        
        .comment-text img,
        .reply-text img,
        .nested-reply-text img {
            opacity: 1 !important;
            filter: none !important;
            background: none !important;
        }

        .loading {
            text-align: center;
            padding: 30px;
            color: #7a3c55;
        }

        .loading-spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #7a3c55;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comment-container.highlighted {
            background-color: #ffe7f4 !important;
            border-color: #ff69b4 !important;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .comment-actions .reply-btn { display: inline-block !important; }
        
        .reply-nick-input,
        input.reply-nick-input,
        input[id^="replyNick_"],
        input[id*="replyNick"],
        input[id^="nestedReplyNick_"],
        input[id*="nestedReplyNick"] {
            background: #fff;
            border: 1px solid #ddd;
            color: #333;
        }
        
        .reply-nick-input::placeholder,
        input[id^="replyNick_"]::placeholder,
        input[id*="replyNick"]::placeholder,
        input[id^="nestedReplyNick_"]::placeholder,
        input[id*="nestedReplyNick"]::placeholder {
            color: #999;
        }
   
                body.dark-theme input.search-input {
  background: #4a3a34 !important;
  color: #fff !important;
  border-color: #555 !important;
}
   </style>
</head>
<link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">
<body>
    <link rel="stylesheet" href="youvi/channel/youvi_ch_feed.css">
    <!-- Sidebar modules AFTER page-specific CSS -->
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    <link rel="stylesheet" href="youvi/sticky-video.css">
    <style>

        
        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
        }
        
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1500px;
            }
        }
        
        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1600px;
            }
        }
        
        .main-content {
            flex: 1;
            width: 100%;
            background: #fff;
        }
        
        .header-content-wrapper,
        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
        }
        
        .comment-actions .reply-btn { display: inline-block !important; }
        .tabs { margin-bottom: 10px; }
        .tab-content { background: #fff; }
        
        .lang-switcher {
            margin-left: auto;
        }
        
        .lang-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }
        
        .lang-select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .lang-select option {
            background: #d94b88;
            color: #fff;
        }
    </style>
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
      <a href="youvi_main.html" data-i18n="nav.video">Видео</a>
      <a href="index.html" data-i18n="nav.management">Управление</a>
      <a href="youvi_ch_list.html" data-i18n="nav.channels">Каналы</a>
      <a href="youvi_playlists_list.html" data-i18n="nav.playlists">Плейлисты</a>
      <a href="youvi_feed_all.html" class="active" data-i18n="nav.feed">Feed</a> 
      <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
      <div class="lang-switcher">
        <select id="langSwitcher" class="lang-select">
          <option value="ru">🇷🇺 RU</option>
          <option value="en">🇬🇧 EN</option>
          <option value="uk">🇺🇦 UK</option>
        </select>
      </div>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content-wrapper">
            <div class="header-left">
                <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle sidebar">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </button>
                
                <div class="logo">
                    <a href="youvi_main.html">
                        <img src="images/logo_youvi_ind.png" alt="Youvi logo">
                    </a>
                </div>
            </div>
            
            <div class="header-center">
                <div class="search-area autocomplete-wrapper">
                    <input type="text" id="globalSearch" placeholder="Поиск видео..." class="search-input" data-i18n-placeholder="search.placeholder">
                    <button id="doSearch" class="search-btn" data-i18n="search.button">Найти</button>
                </div>
            </div>
            
            <div class="header-right">
                <div class="user-actions">
                    <div class="settings-container">
                        <a href="#" class="settings-btn">⚙</a>
                        <div class="theme-dropdown">
                            <button class="theme-dropdown-item" data-theme="light" data-i18n="theme.light">Белая</button>
                            <button class="theme-dropdown-item" data-theme="dark" data-i18n="theme.dark">Черная</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation">Навигация</div>
                <a href="youvi_main.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9,22 9,12 15,12 15,22"/>
                    </svg>
                    <span data-i18n="sidebar.home">Главная</span>
                </a>
                <a href="youvi_feed_all.html" class="sidebar-item nav-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 11a9 9 0 0 1 9 9"/>
                        <path d="M4 4a16 16 0 0 1 16 16"/>
                        <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                    </svg>
                    <span data-i18n="sidebar.feed">Feed</span>
                </a>
                <a href="youvi_tags.html" class="sidebar-item nav-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                     <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                  <line x1="7" y1="7" x2="7.01" y2="7"/>
                 </svg>
                    <span data-i18n="sidebar.allTags">Все теги</span>
                </a>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library">Библиотека</div>
                <a href="youvi_history.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.history">История</span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <span data-i18n="sidebar.favorites">Избранное</span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="8" y1="8" x2="16" y2="8"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="16" x2="16" y2="16"/>
                        <circle cx="6" cy="8" r="1"/>
                        <circle cx="6" cy="12" r="1"/>
                        <circle cx="6" cy="16" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.playlists">Плейлисты</span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span data-i18n="sidebar.channels">Каналы</span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
                        <polyline points="17,2 12,7 7,2"/>
                    </svg>
                    <span data-i18n="sidebar.subscriptions">Подписки</span>
                </a>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle">Подписки</div>
                <div id="subscribedChannelsContainer"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.sorting">Сортировка</div>
                <a href="#" class="sidebar-item library-item" id="sortNew">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.sortNew">Новые</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortBest">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                    </svg>
                    <span data-i18n="feed.sortBest">Лучшие</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortWorst">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 22 8.91 15.74 2 14.73 7 9.86 5.82 2.98 12 6.23 18.18 2.98 17 9.86 22 14.73 15.09 15.74 12 22"/>
                    </svg>
                    <span data-i18n="feed.sortWorst">Худшие</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortOld">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    <span data-i18n="sidebar.sortOld">Старые</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortRandom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="3" ry="3"/>
                        <circle cx="8" cy="8" r="1"/>
                        <circle cx="16" cy="8" r="1"/>
                        <circle cx="8" cy="16" r="1"/>
                        <circle cx="16" cy="16" r="1"/>
                        <circle cx="12" cy="12" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.sortRandom">Случайные</span>
                </a>
            </div>

        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Channel Header -->
            <div class="channel-header" id="channelHeader">
                <div class="channel-info">
                    <div class="channel-avatar" id="channelAvatar">?</div>
                    <div class="channel-details">
                        <h1 class="channel-name" id="channelName" data-i18n="channelFeed.channelName">Название канала</h1>
                        <div class="channel-stats" id="channelStats" data-i18n="channelFeed.loading">Загрузка...</div>
                    </div>
                </div>
                <div class="channel-controls">
                    <button class="subscribe-btn" id="subscribeBtn" data-i18n="channels.subscribe">Подписаться</button>
                    
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab" data-tab="home" data-i18n="channelFeed.tabHome">Главная</button>
                <button class="tab" data-tab="videos" data-i18n="channelFeed.tabVideos">Видео</button>
                <button class="tab" data-tab="analytics" data-i18n="channelFeed.tabAnalytics">Аналитика</button>
                <button class="tab active" data-tab="feed" data-i18n="channelFeed.tabFeed">Лента</button>
                <button class="tab" data-tab="playlists" data-i18n="channelFeed.tabPlaylists">Плейлисты</button>
                <button class="tab" data-tab="description" data-i18n="channelFeed.tabDescription">Описание</button>
            </div>

            <!-- Feed Tab Content -->
            <div id="feedTab" class="tab-content active">
                <div class="feed-form">
                    <div class="compact-editor-toolbar">
                        <button data-cmd="bold" title="${boldTitle}" data-i18n-title="channelFeed.editorBold"><b>B</b></button>
                        <button data-cmd="italic" title="${italicTitle}" data-i18n-title="channelFeed.editorItalic"><i>I</i></button>
                        <button data-cmd="underline" title="${underlineTitle}" data-i18n-title="channelFeed.editorUnderline"><u>U</u></button>
                        <button data-cmd="formatBlock" data-value="h4" title="Заголовок" data-i18n-title="channelFeed.editorHeading">H</button>
                        <button id="createLinkBtnFeed" title="Ссылка" data-i18n-title="channelFeed.editorLink">🔗</button>
                        <button id="insertImageBtnFeed" title="Картинка" data-i18n-title="channelFeed.editorImage">img</button>
                        <button id="centerImageBtnFeed" title="Выровнять по центру" data-i18n-title="channelFeed.editorCenter">⌘</button>
                        <input type="file" id="imageFileInputFeed" accept="image/*" style="display:none" multiple>
                    </div>
                    <div id="feedInput" class="compact-editor" contenteditable="true" placeholder="Что нового на канале?" data-i18n-placeholder="channelFeed.newPostPlaceholder"></div>
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:6px;margin-top:6px;">
                        <input type="text" id="feedNick" placeholder="${yourNickPlaceholder}" data-i18n-placeholder="channelFeed.yourNick" style="flex:1;max-width:100px;padding:3px 5px;border:1px solid #ddd;border-radius:3px;font-size:11px;background:#fff;">
                        <div style="display:flex;gap:6px;">
                            <button id="authorPostBtn" type="button" class="btn primary" style="padding:6px 12px;font-size:11px;font-weight:600;" title="Опубликовать от имени канала" data-i18n="feed.author" data-i18n-title="channelFeed.publishAsChannel">
                                Автор
                            </button>
                            <button id="postFeed" type="button" class="btn primary" style="padding:6px 12px;font-size:11px;" title="Опубликовать (Ctrl+Enter)" data-i18n="channelFeed.publish" data-i18n-title="channelFeed.publishHint">Опубликовать</button>
                        </div>
                    </div>
                </div>
                
                <div id="feedSection" style="background:#fff;margin:0 20px;">
                    <!-- Feed items will be loaded here -->
                </div>
                
                <div style="padding:10px 20px;">
                    <button id="loadMoreFeedBtn" class="load-more-btn" style="display:none;">Показать еще 30 постов</button>
                </div>
            </div>

            <!-- Other Tab Contents -->
            <div id="homeTab" class="tab-content">

            </div>

            <div id="videosTab" class="tab-content">
                
            </div>

            <div id="analyticsTab" class="tab-content">
              
            </div>

            <div id="playlistsTab" class="tab-content">
               
            </div>

            <div id="descriptionTab" class="tab-content">
                
            </div>
        </main>
        </div><!-- /content-wrapper -->
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <img src="images/logo_youvi_ind_ex.png" alt="Youvi" loading="lazy">
                    <p data-i18n="footer.description">Платформа для просмотра видео контента. Сохраняйте, категоризируйте и смотрите видео.</p>
                </div>
                <div class="footer-sections">
                    <div class="footer-section">
                        <h3 data-i18n="footer.sections">Разделы</h3>
            <ul>
              <li><a href="youvi_main.html" data-i18n="footer.video">Видео</a></li>
              <li><a href="youvi_tags.html" data-i18n="sidebar.tags">Теги</a></li>
              <li><a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a></li>
              <li><a href="index.html" data-i18n="nav.management">Управление</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="sidebar.library">Библиотека</h3>
            <ul>
              <li><a href="youvi_ch_list.html" data-i18n="sidebar.channels">Каналы</a></li>
              <li><a href="youvi_playlists_list.html" data-i18n="sidebar.playlists">Плейлисты</a></li>
              <li><a href="youvi_subscriptions.html" data-i18n="sidebar.subscriptions">Подписки</a></li>
              <li><a href="youvi_fav.html" data-i18n="sidebar.favorites">Избранное</a></li>
              <li><a href="youvi_history.html" data-i18n="sidebar.history">История</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="nav.wiki">Wiki</h3>
            <ul>
              <li><a href="wiki/index.html" data-i18n="sidebar.home">Главная</a></li>
              <li><a href="wiki/player.html" data-i18n="footer.wiki.player">Плеер</a></li>
              <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku">Данмаку</a></li>
              <li><a href="wiki/tags/general.html" data-i18n="sidebar.tags">Теги</a></li>
              <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules">Правила тегирования</a></li>
              <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search">Поиск</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.pgc">PGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
              <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
              <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
              <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
              <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.ugc">UGC</h3>
            <ul>
              <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
              <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
              <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
              <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
              <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
              <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
              <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="footer.about">О сайте</h3>
            <ul>
              <li><a href="wiki/about.html" data-i18n="footer.aboutSite">Про сайт</a></li>
               <li><a href="wiki/docs.html" data-i18n="footer.docs">Документация</a></li>
              <li><a href="wiki/tech.html" data-i18n="footer.tech">Технологии</a></li>
            </ul>
                    </div>
                </div>
            </div>
            <div class="footer-right">
                <div class="footer-mascot">
                    <img src="images/mascot1.png" alt="Yuvi" loading="lazy">
                </div>
            </div>
        </div>

    </footer>

    <script>
    (function(){
        try{
            const input = document.getElementById('headerSearchInput');
            const btn = document.getElementById('headerSearchBtn');
            const go = () => {
                const q = (input?.value||'').trim();
                const params = new URLSearchParams();
                if (q) params.set('q', q);
                params.set('type','channels');
                window.location.href = `youvi_search.html?${params.toString()}`;
            };
            if (btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); go(); });
            if (input) input.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); go(); } });
        }catch(_){ }
    })();
    </script>

    <script>
        const DEBUG_MODE = false;
        
        let currentChannelName = '';
        let channelData = {
            feed: [],
            avatar: null,
            header: null,
            stats: { videos: 0, views: 0 }
        };
        let videoDirectoryHandle = null;
        let allFeedPosts = [];
        let feedPage = 0;
        const feedPageSize = 30;
        const avatarCache = new Map();
        let singlePostId = null;
        let singleReplyId = null;

        const channelDataCache = new Map();
        const postsCache = new Map();
        const imageLoadCache = new Map();
        let lastChannelDataLoad = 0;
        const CACHE_DURATION = 30000;

        let loadedFeedChunks = [];
        let totalFeedCount = 0;
        let isLoadingChunk = false;

        let virtualScrollTop = 0;
        let itemHeight = 120;
        let visibleItems = 10;
        
        function getMainContainerScrollTop() {
            const container = document.querySelector('.main-content');
            return container ? container.scrollTop : (window.scrollY || 0);
        }
        function setMainContainerScrollTop(scrollTop) {
            const container = document.querySelector('.main-content');
            if (container) {
                container.scrollTop = scrollTop;
            } else {
                window.scrollTo(0, scrollTop);
            }
        }
        
        const imageOptimizationCache = new Map();
        const MAX_CACHE_SIZE = 100;
        
        function createDataURL(file) {
            return new Promise((resolve, reject) => {
                try {
                    if (!file || !(file instanceof File || file instanceof Blob)) {
                        if (DEBUG_MODE) console.error('Invalid file object for data URL creation');
                        reject(new Error('Invalid file object'));
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        if (DEBUG_MODE) console.log('Created data URL for file:', file.name);
                        resolve(e.target.result);
                    };
                    reader.onerror = function(e) {
                        if (DEBUG_MODE) console.error('Failed to read file:', e);
                        reject(e);
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    if (DEBUG_MODE) console.error('Failed to create data URL:', error);
                    reject(error);
                }
            });
        }
        
        function createFileURL(filePath) {
            try {
                const fileUrl = `file:///${filePath.replace(/\\/g, '/')}`;
                if (DEBUG_MODE) console.log('Created file URL:', fileUrl);
                return fileUrl;
            } catch (error) {
                if (DEBUG_MODE) console.error('Failed to create file URL:', error);
                return null;
            }
        }
        
        window.addEventListener('error', function(event) {
            if (event.message && event.message.includes('Not allowed to load local resource')) {
                if (DEBUG_MODE) console.error('Local resource error detected:', event.message);
                if (DEBUG_MODE) console.log('This is expected for local file access without a server');
            }
        });
        
        async function clearAllBlobURLs() {
            try {
                clearImageCache();
                
                avatarCache.clear();
                
                if (window.indexedDB) {
                    const request = indexedDB.deleteDatabase('YouviDB');
                    request.onsuccess = () => {
                        if (DEBUG_MODE) console.log('IndexedDB cleared successfully');
                    };
                    request.onerror = () => {
                        if (DEBUG_MODE) console.log('IndexedDB clear failed or database does not exist');
                    };
                }
                
                if (DEBUG_MODE) console.log('All blob URLs and caches cleared');
            } catch (error) {
                if (DEBUG_MODE) console.error('Error clearing caches:', error);
            }
        }
        
        window.addEventListener('load', function() {
            clearAllBlobURLs();
        });

        function getChannelIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const channel = urlParams.get('channel');
            const id = urlParams.get('id');
            const result = channel || id || '';
            if (DEBUG_MODE) console.log(`getChannelIdFromUrl() = ${result} (channel: ${channel}, id: ${id})`);
            return result;
        }

        function getUrlParam(param) {
            const value = new URLSearchParams(window.location.search).get(param);
            if (DEBUG_MODE) console.log(`getUrlParam('${param}') =`, value);
            return value;
        }

        async function scrollToPost(postId) {
            if (DEBUG_MODE) console.log('Looking for post with ID:', postId);
            
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
                const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                if (postElement) {
                    if (DEBUG_MODE) console.log('Found post element, scrolling to it');
                    
                    postElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    highlightPost(postElement);
                    
                    return true;
                }
                
                if (allFeedPosts.length > 50) {
                    const targetPost = allFeedPosts.find(post => post.id === postId);
                    if (targetPost) {
                        const targetIndex = allFeedPosts.findIndex(post => post.id === postId);
                        if (DEBUG_MODE) console.log('Found target post at index:', targetIndex);
                        
                        const container = document.querySelector('.main-content');
                        if (container) {
                            const targetScrollTop = targetIndex * itemHeight;
                            if (DEBUG_MODE) console.log('Scrolling to position:', targetScrollTop);
                            
                            virtualScrollTop = targetScrollTop;
                            container.scrollTop = targetScrollTop;
                            
                            await renderFeedPageVirtual();
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                            if (postElement) {
                                highlightPost(postElement);
                                return true;
                            }
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (DEBUG_MODE) console.log('Post not found after', attempts, 'attempts');
            return false;
        }

        async function loadMorePostsIfNeeded(targetPostId) {
            const targetPost = allFeedPosts.find(post => post.id === targetPostId);
            if (!targetPost) {
                if (DEBUG_MODE) console.log('Target post not in allFeedPosts, trying to load more');
                return;
            }
            
            const targetIndex = allFeedPosts.findIndex(post => post.id === targetPostId);
            if (targetIndex === -1) return;
            
            const currentLoadedCount = document.querySelectorAll('[data-post-id]').length;
            const postsNeeded = targetIndex - currentLoadedCount + 10;
            
            if (postsNeeded > 0) {
                if (DEBUG_MODE) console.log(`Need to load ${postsNeeded} more posts to reach target`);
            }
        }

        function highlightPost(postElement) {
            if (DEBUG_MODE) console.log('Highlighting post');
            
            postElement.classList.add('highlighted');
            
            setTimeout(() => {
                postElement.classList.remove('highlighted');
                if (DEBUG_MODE) console.log('Removed highlight from post');
            }, 2000);
        }

        async function openDB() {
            return new Promise((resolve, reject) => {
                if (DEBUG_MODE) console.log('Opening IndexedDB: 8SiteDB, version 1');
                const request = indexedDB.open('8SiteDB', 1);
                
                request.onupgradeneeded = () => {
                    if (DEBUG_MODE) console.log('IndexedDB upgrade needed');
                    const db = request.result;
                    if (!db.objectStoreNames.contains('handles')) {
                        if (DEBUG_MODE) console.log('Creating handles store');
                        db.createObjectStore('handles');
                    }
                    if (!db.objectStoreNames.contains('subscriptions')) {
                        if (DEBUG_MODE) console.log('Creating subscriptions store');
                        db.createObjectStore('subscriptions');
                    }
                };
                
                request.onsuccess = () => {
                    if (DEBUG_MODE) console.log('IndexedDB opened successfully');
                    resolve(request.result);
                };
                
                request.onerror = () => {
                    if (DEBUG_MODE) console.error('IndexedDB open error:', request.error);
                    reject(request.error);
                };
            });
        }

        async function getFromDB(db, key) {
            if (DEBUG_MODE) console.log(`Getting from DB: ${key}`);
            const storeName = key === 'subscriptions' ? 'subscriptions' : 'handles';
            if (DEBUG_MODE) console.log('Using store:', storeName);
            
            if (!db.objectStoreNames.contains(storeName)) {
                if (DEBUG_MODE) console.log('Store not found:', storeName);
                return null;
            }
            
            const tx = db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            if (DEBUG_MODE) console.log('Transaction and store created');
            
            return new Promise((resolve) => {
                const request = store.get(key);
                request.onsuccess = () => {
                    if (DEBUG_MODE) console.log(`DB get success for ${key}:`, request.result);
                    resolve(request.result);
                };
                request.onerror = () => {
                    if (DEBUG_MODE) console.log(`DB get error for ${key}:`, request.error);
                    resolve(null);
                };
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function loadAvatarForChannelName(channelName) {
            try {
                if (!videoDirectoryHandle || !channelName) return null;
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                const chDir = await channelsDir.getDirectoryHandle(channelName, { create: true });
                const chData = await readJSONFile(chDir, 'channel.json', {});
                if (chData && chData.avatar) {
                    return await loadImageFile(chDir, chData.avatar);
                }
            } catch (e) {
                if (DEBUG_MODE) console.error('Error loading avatar for channel', channelName, e);
            }
            return null;
        }
        
        function getNickColor(nick) {
            if (!nick || typeof nick !== 'string') {
                return '#888888';
            }
            const colors = ['#4a90e2', '#7b68ee', '#20b2aa', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            let hash = 0;
            for (let i = 0; i < nick.length; i++) {
                hash = nick.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }
        
        function processContentWithImages(content) {
            if (!content || typeof content !== 'string') return '';
            
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const images = tempDiv.querySelectorAll('img');
                
                images.forEach(img => {
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        img.style.maxWidth = '120px';
                        img.style.maxHeight = '80px';
                        img.style.cursor = 'pointer';
                        img.style.border = '1px solid #ddd';
                        img.style.borderRadius = '4px';
                        img.style.objectFit = 'cover';
                        img.style.display = 'block';
                        img.style.opacity = '1';
                        img.className = 'loaded';
                        
                    img.onclick = () => {
                        const fileName = img.getAttribute('data-filename');
                        const postId = img.getAttribute('data-post-id');
                        if (fileName && postId) {
                            openImageModal(img.src, fileName, postId, currentChannelName);
                        } else {
                            openImageModal(img.src);
                        }
                    };
                    }
                });
                
                return tempDiv.innerHTML;
            } catch (e) {
                if (DEBUG_MODE) console.error('Error processing content with images:', e);
            return content;
            }
        }

        function processImagesInPostContent(postElement) {
            const images = postElement.querySelectorAll('.comment-text img, .reply-text img, .nested-reply-text img');
            
            if (images.length > 0) {
                if (DEBUG_MODE) console.log('Processing', images.length, 'images in post/reply');
            }
            
            images.forEach(img => {
                if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                    img.setAttribute('data-expanded', 'false');
                    img.style.cursor = 'pointer';
                    img.style.transition = 'all 0.3s ease';
                            img.style.maxWidth = '120px';
                            img.style.maxHeight = '80px';
                    img.style.objectFit = 'cover';
                            img.style.border = '1px solid #ddd';
                            img.style.borderRadius = '4px';
                            img.style.margin = '4px 0';
                    img.style.display = 'block';
                    img.style.opacity = '1';
                    
                    img.classList.remove('lazy');
                    img.classList.add('loaded');
                    
                    img.onclick = (e) => {
                        e.stopPropagation();
                        toggleImageSize(img);
                        
                        const postContainer = img.closest('.feed-comment');
                        if (postContainer) {
                            const postId = postContainer.querySelector('[data-post-id]')?.getAttribute('data-post-id');
                            if (postId) {
                                const button = document.querySelector(`.image-toggle-btn[data-post-id="${postId}"]`);
                                const images = postContainer.querySelectorAll('.comment-text img');
                                let allExpanded = true;
                                images.forEach(img => {
                                    if (img.getAttribute('data-expanded') !== 'true') {
                                        allExpanded = false;
                                    }
                                });
                                if (button) {
                                    button.textContent = allExpanded ? `▼ ${i18n.t('feed.close', 'Закрыть')}` : `▼ ${i18n.t('feed.open', 'Открыть')}`;
                                    button.title = allExpanded ? i18n.t('feed.closeImages', 'Закрыть изображения') : i18n.t('feed.openImages', 'Открыть изображения');
                                }
                            }
                        }
                    };
                }
            });
        }

        async function processImagesInContent(content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const images = tempDiv.querySelectorAll('img');
            
            if (images.length > 0) {
                if (DEBUG_MODE) console.log('Processing reply with', images.length, 'images');
                for (const img of images) {
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        if (!img.style.maxWidth) img.style.maxWidth = '120px';
                        if (!img.style.maxHeight) img.style.maxHeight = '80px';
                        if (!img.style.cursor) img.style.cursor = 'pointer';
                        if (!img.style.border) img.style.border = '1px solid #ddd';
                        if (!img.style.borderRadius) img.style.borderRadius = '4px';
                        if (!img.style.objectFit) img.style.objectFit = 'cover';
                        if (!img.style.display) img.style.display = 'block';
                        if (!img.style.opacity) img.style.opacity = '1';
                        
                        if (!img.className.includes('loaded')) {
                            img.className = (img.className + ' loaded').trim();
                        }
                        
                        if (!img.getAttribute('data-fullsrc')) {
                            img.setAttribute('data-fullsrc', img.src);
                        }
                        if (!img.getAttribute('data-expanded')) {
                            img.setAttribute('data-expanded', 'false');
                        }
                        
                        img.setAttribute('data-thumbnail', 'true');
                    }
                }
                return tempDiv.innerHTML;
            }
            
            return content;
        }

        async function downscaleImageFile(file, maxW, maxH, quality = 0.8) {
            const cacheKey = `${file.name}_${file.size}_${file.lastModified}_${maxW}x${maxH}_${quality}`;
            
            if (imageOptimizationCache.has(cacheKey)) {
                return imageOptimizationCache.get(cacheKey);
            }
            
            return new Promise((resolve) => {
                createDataURL(file).then(dataUrl => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width, h = img.height;
                        
                        let scale = Math.min(maxW / w, maxH / h, 1);
                        if (scale < 1) {
                            w = Math.round(w * scale);
                            h = Math.round(h * scale);
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        
                        ctx.drawImage(img, 0, 0, w, h);
                        
                        const optimizedDataUrl = canvas.toDataURL(file.type || 'image/jpeg', quality);
                        
                        if (imageOptimizationCache.size >= MAX_CACHE_SIZE) {
                            const firstKey = imageOptimizationCache.keys().next().value;
                            imageOptimizationCache.delete(firstKey);
                        }
                        imageOptimizationCache.set(cacheKey, optimizedDataUrl);
                        
                        resolve(optimizedDataUrl);
                    };
                    img.onerror = () => {
                        imageOptimizationCache.set(cacheKey, dataUrl);
                        resolve(dataUrl);
                    };
                    
                    img.src = dataUrl;
                }).catch(error => {
                    if (DEBUG_MODE) console.error('Failed to downscale image:', error);
                    resolve(null);
                });
            });
        }

        async function processImagesInPost(item, post) {
            return;
        }

        async function writeJSONFile(dirHandle, fileName, data) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();
            } catch (e) {
                if (DEBUG_MODE) console.error('Error writing file:', e);
            }
        }

        async function createImagesDirectory() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) return null;
                
                const channelDir = await getChannelDirectory();
                try {
                    await channelDir.getDirectoryHandle('images', { create: true });
                    if (DEBUG_MODE) console.log('Images directory created/accessed');
                } catch (e) {
                    if (DEBUG_MODE) console.error('Error creating images directory:', e);
                }
                return channelDir;
            } catch (e) {
                if (DEBUG_MODE) console.error('Error accessing channel directory for images:', e);
                return null;
            }
        }

        async function saveOriginalImageFile(file, postId, replyId = null) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, using data URL fallback');
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts', { create: true });
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`, { create: true });
                const imagesDir = await postDir.getDirectoryHandle('images', { create: true });
                
                const timestamp = Date.now();
                const fileExtension = file.name.split('.').pop() || 'jpg';
                const fileName = replyId 
                    ? `image_${timestamp}_${postId}_${replyId}.${fileExtension}`
                    : `image_${timestamp}_${postId}.${fileExtension}`;

                const fileHandle = await imagesDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(file);
                await writable.close();

                if (DEBUG_MODE) console.log('Saved original image file to post images directory:', fileName);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve) => {
                    img.onload = () => {
                        const maxWidth = 200;
                        const maxHeight = 150;
                        let { width, height } = img;
                        
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const thumbnailDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        
                        const imageInfo = {
                            fileName: fileName,
                            originalSize: file.size,
                            thumbnailDataUrl: thumbnailDataUrl,
                            timestamp: timestamp
                        };
                        
                        saveImageInfo(imageInfo, postId, replyId);
                        
                        resolve(thumbnailDataUrl);
                    };
                    img.src = URL.createObjectURL(file);
                });
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error saving original image file:', e);
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            }
        }

        async function saveImageInfo(imageInfo, postId, replyId = null) {
            try {
                const channelDir = await getChannelDirectory();
                const imagesFile = 'images.json';
                
                let imagesData = {};
                try {
                    const existingFile = await channelDir.getFileHandle(imagesFile);
                    const file = await existingFile.getFile();
                    const content = await file.text();
                    imagesData = JSON.parse(content);
                } catch (e) {
                }
                
                const key = replyId ? `${postId}_${replyId}_${imageInfo.timestamp}` : `${postId}_${imageInfo.timestamp}`;
                imagesData[key] = imageInfo;
                
                await writeJSONFile(channelDir, imagesFile, imagesData);
                if (DEBUG_MODE) console.log('Saved image info to images.json');
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error saving image info:', e);
            }
        }

        async function loadFullImage(fileName, postId, channelName = null) {
            try {
                if (!videoDirectoryHandle) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load full image');
                    return null;
                }

                if (DEBUG_MODE) console.log('Loading full image:', { fileName, postId, channelName });

                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                
                if (channelName) {
                    try {
                        const channelHandle = await channelsDir.getDirectoryHandle(channelName);
                        const postsDir = await channelHandle.getDirectoryHandle('posts');
                        const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                        const imagesDir = await postDir.getDirectoryHandle('images');
                        const fileHandle = await imagesDir.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        
                        if (DEBUG_MODE) console.log('Found image in specified channel:', channelName);
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                    } catch (e) {
                        if (DEBUG_MODE) console.log('Post not found in specified channel:', channelName, e);
                    }
                }
                
                for await (const [channelName, channelHandle] of channelsDir.entries()) {
                    if (channelHandle.kind === 'directory') {
                        try {
                            const postsDir = await channelHandle.getDirectoryHandle('posts');
                            const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                            const imagesDir = await postDir.getDirectoryHandle('images');
                            const fileHandle = await imagesDir.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            
                            if (DEBUG_MODE) console.log('Found image in channel:', channelName);
                            return new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                if (DEBUG_MODE) console.log('Post not found in any channel');
                return null;
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error loading full image:', e);
                return null;
            }
        }

        async function saveReplies() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save replies');
                    return;
                }

                const channelDir = await getChannelDirectory();
                
                const allReplies = {};
                if (channelData.feed) {
                    channelData.feed.forEach(post => {
                        if (post.replies && post.replies.length > 0) {
                            allReplies[post.id] = post.replies;
                        }
                    });
                }
                
                await writeJSONFile(channelDir, 'replies.json', allReplies);
                if (DEBUG_MODE) console.log('Saved replies to replies.json');
                
                if (channelData.feed) {
                    channelData.feed.forEach(post => {
                        if (post.replies) {
                            delete post.replies;
                        }
                    });
                }
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error saving replies:', e);
            }
        }

        async function loadReplies() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load replies');
                    return;
                }

                const channelDir = await getChannelDirectory();
                const repliesData = await readJSONFile(channelDir, 'replies.json', {});
                
                if (channelData.feed && repliesData) {
                    channelData.feed.forEach(post => {
                        if (repliesData[post.id]) {
                            post.replies = repliesData[post.id];
                        }
                    });
                }
                
                if (DEBUG_MODE) console.log('Loaded replies from replies.json');
                
            } catch (e) {
                console.error('Error loading replies:', e);
            }
        }

        async function createPostDirectory(postId) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot create post directory');
                    return null;
                }

                if (!postId || postId === 'feed' || typeof postId !== 'string') {
                    if (DEBUG_MODE) console.error('Invalid postId:', postId);
                    return null;
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts', { create: true });
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`, { create: true });
                const imagesDir = await postDir.getDirectoryHandle('images', { create: true });
                
                if (DEBUG_MODE) console.log('Created post directory structure for:', postId);
                return { postDir, imagesDir };
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error creating post directory:', e);
                return null;
            }
        }

        async function savePostToDirectory(post) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save post');
                    return;
                }

                const { postDir, imagesDir } = await createPostDirectory(post.id);
                if (!postDir) return;

                const postData = {
                    id: post.id,
                    author: post.author,
                    content: post.content,
                    timestamp: post.timestamp,
                    likes: post.likes || 0,
                    dislikes: post.dislikes || 0,
                    edited: post.edited || false,
                    editedAt: post.editedAt || null,
                    isAuthorPost: post.isAuthorPost || false,
                    hasImages: post.hasImages || false
                };

                await writeJSONFile(postDir, 'post.json', postData);
                if (DEBUG_MODE) console.log('Saved post data to post.json');

                if (post.replies && post.replies.length > 0) {
                    await writeJSONFile(postDir, 'replies.json', post.replies);
                    if (DEBUG_MODE) console.log('Saved replies to replies.json');
                }

                if (post.content && post.content.includes('<img')) {
                    await processAndSavePostImages(post, imagesDir);
                }

            } catch (e) {
                console.error('Error saving post to directory:', e);
            }
        }

        async function saveRepliesToFile(postId, replies) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save replies');
                    return;
                }

                const { postDir } = await createPostDirectory(postId);
                if (!postDir) return;

                if (replies && replies.length > 0) {
                    await writeJSONFile(postDir, 'replies.json', replies);
                    if (DEBUG_MODE) console.log('Saved replies to replies.json for post:', postId);
                } else {
                    await writeJSONFile(postDir, 'replies.json', []);
                    if (DEBUG_MODE) console.log('Saved empty replies array for post:', postId);
                }

            } catch (e) {
                console.error('Error saving replies to file:', e);
            }
        }

        async function processAndSavePostImages(post, imagesDir) {
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = post.content;
                const images = tempDiv.querySelectorAll('img');
                
                if (images.length === 0) return;

                if (DEBUG_MODE) console.log(`Processing ${images.length} images for post ${post.id}`);

                for (let i = 0; i < images.length; i++) {
                    const img = images[i];
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        if (img.getAttribute('data-original-file') === 'true') {
                            const response = await fetch(img.src);
                            const blob = await response.blob();
                            const file = new File([blob], `image_${i + 1}.jpg`, { type: blob.type });
                            
                            const fileName = `image_${Date.now()}_${i + 1}.jpg`;
                            const fileHandle = await imagesDir.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(file);
                            await writable.close();

                            img.setAttribute('data-filename', fileName);
                            img.setAttribute('data-post-id', post.id);
                            img.removeAttribute('data-original-file');
                            
                            if (DEBUG_MODE) console.log('Saved post image:', fileName);
                        } else {
                            img.setAttribute('data-post-id', post.id);
                        }
                    }
                }

                post.content = tempDiv.innerHTML;

            } catch (e) {
                console.error('Error processing post images:', e);
            }
        }

        async function loadPostFromDirectory(postId) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load post');
                    return null;
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts');
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);

                const postData = await readJSONFile(postDir, 'post.json');
                if (!postData || !postData.id) {
                    console.error('Invalid post data for post:', postId);
                    return null;
                }
                
                if (postData.deleted) {
                    if (DEBUG_MODE) console.log(`Skipping deleted post: ${postId}`);
                    return null;
                }

                const replies = await readJSONFile(postDir, 'replies.json', []);
                postData.replies = replies || [];

                try {
                    const imagesDir = await postDir.getDirectoryHandle('images');
                    await loadPostImages(postData, imagesDir);
                } catch (e) {
                    if (DEBUG_MODE) console.log('No images directory for post:', postId);
                }

                if (DEBUG_MODE) console.log('Loaded post from directory:', postId);
                return postData;

            } catch (e) {
                if (DEBUG_MODE) console.error('Error loading post from directory:', e);
                return null;
            }
        }

        async function loadPostImages(post, imagesDir) {
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = post.content;
                const images = tempDiv.querySelectorAll('img[data-filename]');

                for (const img of images) {
                    const fileName = img.getAttribute('data-filename');
                    if (fileName) {
                        try {
                            const fileHandle = await imagesDir.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            const dataUrl = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                            img.src = dataUrl;
                            img.setAttribute('data-post-id', post.id);
                        } catch (e) {
                            console.error('Error loading post image:', fileName, e);
                        }
                    }
                }

                post.content = tempDiv.innerHTML;

            } catch (e) {
                console.error('Error loading post images:', e);
            }
        }

        async function readJSONFile(dirHandle, fileName, defaultValue = null) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return defaultValue;
            }
        }

        async function loadImageFile(dirHandle, fileName) {
            const cacheKey = `${dirHandle.name}_${fileName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
            }
            
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const url = URL.createObjectURL(file);
                
                avatarCache.set(cacheKey, {
                    url,
                    timestamp: Date.now()
                });
                
                return url;
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    console.error('Error loading image file:', e);
                }
                return null;
            }
        }

        async function loadImageFromFileSystem(dirHandle, fileName) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                
                if (!file.type.startsWith('image/')) {
                    console.warn('File is not an image:', fileName);
                    return null;
                }
                
                const dataUrl = await createDataURL(file);
                if (dataUrl) {
                    if (DEBUG_MODE) console.log('Image loaded from file system:', fileName);
                    return dataUrl;
                } else {
                    console.error('Failed to create data URL for:', fileName);
                    return null;
                }
            } catch (e) {
                console.error('Error loading image from file system:', e);
                return null;
            }
        }

        async function loadImageFileFromFileSystem(dirHandle, fileName) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                if (DEBUG_MODE) console.log('Image file loaded from file system:', fileName, file.size, 'bytes');
                return file;
            } catch (e) {
                console.error('Error loading image file from file system:', e);
                return null;
            }
        }

        async function loadLazyImageFile(dirHandle, fileName, imgElement, className = '') {
            const url = await loadImageFile(dirHandle, fileName);
            if (url && imgElement) {
                if (imgElement.tagName === 'IMG') {
                    if (imgElement.dataset.src) {
                        imgElement.dataset.src = url;
                    } else {
                        imgElement.dataset.src = url;
                        imgElement.className = (imgElement.className + ' ' + className + ' lazy').trim();
                        imgElement.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiNGM0Y0RjYiLz4KPC9zdmc+Cg==';
                    }
                } else {
                    imgElement.dataset.src = url;
                    imgElement.className = (imgElement.className + ' ' + className + ' lazy-avatar').trim();
                }
            }
            return url;
        }

        let cachedChannelDir = null;
        let cachedChannelDirName = null;

        async function getChannelDirectory() {
            if (cachedChannelDir && cachedChannelDirName === currentChannelName) {
                return cachedChannelDir;
            }
            
            const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
            const channelDir = await channelsDir.getDirectoryHandle(currentChannelName, { create: true });
            
            cachedChannelDir = channelDir;
            cachedChannelDirName = currentChannelName;
            
            return channelDir;
        }

        async function loadChannelVideos() {
            if (!videoDirectoryHandle || !currentChannelName) return;
            
            const videos = [];
            const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];
            
            try {
                async function scanDirectory(dirHandle, playlistName = '') {
                    try {
                        for await (const [name, handle] of dirHandle.entries()) {
                            if (handle.kind === 'file') {
                                const isVideo = videoExtensions.some(ext => name.toLowerCase().endsWith(ext));
                                if (isVideo) {
                                    const metadata = await getVideoMetadata(dirHandle, name);
                                    const hasChannelTag = (metadata.tags || []).some(tag => 
                                        tag === `${currentChannelName} (ка)`
                                    );
                                    
                                    if (hasChannelTag) {
                                        const file = await handle.getFile();
                                        videos.push({
                                            name,
                                            handle,
                                            file,
                                            size: file.size,
                                            modified: file.lastModified,
                                            ...metadata,
                                            playlist: playlistName
                                        });
                                    }
                                }
                            } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                                await scanDirectory(handle, name);
                            }
                        }
                    } catch (e) {
                        console.error('Error scanning directory:', e);
                    }
                }
                
                await scanDirectory(videoDirectoryHandle);

                const totalViews = videos.reduce((sum, v) => sum + (v.views || 0), 0);
                const statsEl = document.getElementById('channelStats');
                if (statsEl) {
                    if (videos.length > 0) {
                        statsEl.textContent = i18n.t('channelFeed.stats', '{videos} видео • {views} просмотров').replace('{videos}', videos.length).replace('{views}', totalViews.toLocaleString());
                    } else {
                        statsEl.textContent = i18n.t('channelFeed.noVideos', '' + i18n.t('channelFeed.noVideos', 'Нет видео') + '');
                    }
                }
                
                if (channelData) {
                    channelData.stats = {
                        videos: videos.length,
                        views: totalViews
                    };
                }
                
            } catch (e) {
                console.error('Error loading channel videos:', e);
            }
        }

        async function getVideoMetadata(dirHandle, fileName) {
            try {
                const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                const metaFileName = fileName + '.meta.json';
                const fileHandle = await metaDir.getFileHandle(metaFileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return {
                    views: 0,
                    likes: 0,
                    dislikes: 0,
                    tags: [],
                    created: Date.now()
                };
            }
        }

        async function loadChannelData() {
            if (!currentChannelName) return;
            
            if (DEBUG_MODE) console.log('Loading channel data for:', currentChannelName);
            const startTime = performance.now();
            
            const cacheKey = `channel_${currentChannelName}`;
            const now = Date.now();
            if (channelDataCache.has(cacheKey) && (now - lastChannelDataLoad) < CACHE_DURATION) {
                if (DEBUG_MODE) console.log('Using cached channel data');
                channelData = channelDataCache.get(cacheKey);
                const loadTime = performance.now() - startTime;
                if (DEBUG_MODE) console.log(`Channel data loaded from cache in ${loadTime.toFixed(2)}ms`);
                return;
            }
            
            try {
                const channelDir = await getChannelDirectory();
                if (DEBUG_MODE) console.log('Channel directory obtained:', channelDir);
                
                const defaultData = {
                    name: currentChannelName,
                    description: '',
                    avatar: null,
                    header: null,
                    background: null,
                    textColor: 'white',
                    theme: 'default',
                    feed: [],
                    playlists: [],
                    stats: { videos: 0, views: 0 },
                    created: Date.now()
                };
                
                const channelJsonPromise = readJSONFile(channelDir, 'channel.json', defaultData);
                const timeoutPromise = new Promise(resolve => setTimeout(() => resolve(defaultData), 5000));
                
                channelData = await Promise.race([channelJsonPromise, timeoutPromise]);
                if (DEBUG_MODE) console.log('Channel data loaded from file system');
                
                setTimeout(() => {
                    const channelId = getChannelIdFromUrl();
                    const storedData = localStorage.getItem(`channel_${channelId}`);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            channelData = { 
                                ...channelData, 
                                ...parsedData,
                                name: channelData.name || parsedData.name,
                                created: channelData.created || parsedData.created
                            };
                            
                            channelDataCache.set(cacheKey, channelData);
                            if (DEBUG_MODE) console.log('Channel data merged with localStorage');
                        } catch (e) {
                            if (DEBUG_MODE) console.error('Error parsing stored data:', e);
                        }
                    }
                }, 0);
                
                channelDataCache.set(cacheKey, channelData);
                lastChannelDataLoad = now;
                
                const loadTime = performance.now() - startTime;
                if (DEBUG_MODE) console.log(`Channel data loaded in ${loadTime.toFixed(2)}ms`);
                
                setTimeout(() => loadPostsFromDirectories(), 0);
                
            } catch (e) {
                console.error('Error loading channel data:', e);
                const channelId = getChannelIdFromUrl();
                const storedData = localStorage.getItem(`channel_${channelId}`);
                if (storedData) {
                    try {
                        channelData = JSON.parse(storedData);
                        channelDataCache.set(cacheKey, channelData);
                        if (DEBUG_MODE) console.log('Fallback: Using localStorage data');
                    } catch (e) {
                        console.error('Error parsing stored data:', e);
                    }
                }
                
                setTimeout(() => loadPostsFromDirectories(), 0);
            }
        }

        async function loadPostsFromDirectories() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load posts from directories');
                    return;
                }

                const channelDir = await getChannelDirectory();
                
                try {
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    
                    let postsIndex = null;
                    try {
                        postsIndex = await readJSONFile(postsDir, 'index.json', null);
                    } catch (e) {
                    }
                    
                    let loadedPosts = [];
                    
                    if (postsIndex && Array.isArray(postsIndex.posts)) {
                        if (DEBUG_MODE) console.log('Using posts index for fast loading');
                        loadedPosts = postsIndex.posts.filter(p => p && p.id && !p.deleted);
                        await loadRepliesForPosts(loadedPosts, postsDir);
                    } else {
                        if (DEBUG_MODE) console.log('Posts directory found, loading individual posts');
                        
                        const postDirs = [];
                        for await (const [name, handle] of postsDir.entries()) {
                            if (handle.kind === 'directory' && name.startsWith('post_')) {
                                postDirs.push([name, handle]);
                            }
                        }
                        
                        if (DEBUG_MODE) console.log(`Found ${postDirs.length} post directories`);
                        
                        const POST_BATCH_SIZE = 10;
                        
                        for (let i = 0; i < postDirs.length; i += POST_BATCH_SIZE) {
                            const batch = postDirs.slice(i, i + POST_BATCH_SIZE);
                            
                            const batchPromises = batch.map(async ([postDirName, postDirHandle]) => {
                                const postId = postDirName.replace('post_', '');
                                
                                try {
                                    const postData = await readJSONFile(postDirHandle, 'post.json');
                                    if (postData && postData.id && !postData.deleted) {
                                        return {
                                            ...postData,
                                            author: postData.author || 'Аноним',
                                            content: postData.content || '',
                                            timestamp: postData.timestamp || Date.now(),
                                            replies: postData.replies || [],
                                            likes: postData.likes || 0,
                                            dislikes: postData.dislikes || 0,
                                            isAuthorPost: postData.isAuthorPost || false,
                                            hasImages: postData.hasImages || false
                                        };
                                    }
                                } catch (e) {
                                }
                                return null;
                            });
                            
                            const batchResults = await Promise.all(batchPromises);
                            loadedPosts.push(...batchResults.filter(post => post !== null));
                        }
                        
                        await loadRepliesForPosts(loadedPosts, postsDir);
                    }
                    
                    loadedPosts.sort((a, b) => b.timestamp - a.timestamp);
                    
                    channelData.feed = loadedPosts;
                    allFeedPosts = loadedPosts;
                    if (DEBUG_MODE) console.log(`Loaded ${loadedPosts.length} posts`);
                    
                } catch (e) {
                    if (DEBUG_MODE) console.log('No posts directory found, using existing feed data');
                }
                
            } catch (e) {
                if (DEBUG_MODE) console.error('Error loading posts from directories:', e);
            }
        }
        
        async function loadRepliesForPosts(posts, postsDir) {
            if (!posts || posts.length === 0 || !postsDir) return;
            
            const startTime = performance.now();
            
            const promises = posts.map(async (post) => {
                try {
                    const postDir = await postsDir.getDirectoryHandle(`post_${post.id}`);
                    const replies = await readJSONFile(postDir, 'replies.json', null);
                    if (replies && Array.isArray(replies) && replies.length > 0) {
                        post.replies = replies;
                    }
                } catch (e) {
                }
            });
            
            await Promise.all(promises);
            if (DEBUG_MODE) console.log(`Loaded replies in ${(performance.now() - startTime).toFixed(2)}ms`);
        }

        async function loadChannelDataIncremental(startIndex = 0, chunkSize = 50) {
            if (isLoadingChunk) return;
            isLoadingChunk = true;

            try {
                const channelDir = await getChannelDirectory();
                const channelData = await readJSONFile(channelDir, 'channel.json', {});

                if (!channelData.feed) {
                    channelData.feed = [];
                }

                totalFeedCount = channelData.feed.length;
                const endIndex = Math.min(startIndex + chunkSize, totalFeedCount);
                const chunk = channelData.feed.slice(startIndex, endIndex);

                loadedFeedChunks.push(...chunk);

                allFeedPosts = [...loadedFeedChunks].sort((a, b) => b.timestamp - a.timestamp);

                isLoadingChunk = false;
                return endIndex < totalFeedCount;
            } catch (e) {
                console.error('Error loading channel data chunk:', e);
                isLoadingChunk = false;
                return false;
            }
        }

        async function createFeedItem(post) {
            if (!post || !post.id) {
                console.error('Invalid post data:', post);
                return null;
            }

            const item = document.createElement('div');
            item.className = 'feed-comment';
            item.setAttribute('data-post-id', post.id);

            const timestamp = post.timestamp || post.created || Date.now();
            const date = new Date(timestamp).toLocaleString(i18n.getCurrentLanguage() === 'en' ? 'en-US' : (i18n.getCurrentLanguage() === 'uk' ? 'uk-UA' : 'ru-RU'), {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            const isAuthorPost = post.isAuthorPost || false;
            const author = post.author || post.nick || i18n.t('channelFeed.anonymous', 'Аноним');
            const isChannelNick = /\((ка|ka)\)\s*$/i.test(author);
            const channelNameFromNick = isChannelNick ? author.replace(/\((ка|ka)\)\s*$/i,'').trim() : null;
            const nickColor = (isAuthorPost || isChannelNick) ? '#d94b88' : getNickColor(channelNameFromNick || author);
            
            const likeTitle = i18n.t('feed.like', 'Лайк');
            const dislikeTitle = i18n.t('feed.dislike', 'Дизлайк');
            const reportText = i18n.t('channelFeed.report', 'Пожаловаться');
            const openText = i18n.t('feed.open', 'Открыть');
            const authorBadge = i18n.t('feed.author', 'Автор');
            const boldTitle = i18n.t('channelFeed.editorBold', 'Жирный');
            const italicTitle = i18n.t('channelFeed.editorItalic', 'Курсив');
            const underlineTitle = i18n.t('channelFeed.editorUnderline', 'Подчеркнутый');
            const listTitle = i18n.t('channelFeed.editorList', 'Список');
            const numberedListTitle = i18n.t('channelFeed.editorNumberedList', 'Нумерованный список');
            const linkTitle = i18n.t('channelFeed.editorLink', 'Ссылка');
            const imageTitle = i18n.t('channelFeed.editorImage', 'Картинка');
            const centerTitle = i18n.t('channelFeed.editorCenter', 'Выровнять по центру');
            const closeTitle = i18n.t('channelFeed.close', 'Закрыть');
            const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', 'Ответить...');
            const yourNickPlaceholder = i18n.t('channelFeed.yourNick', 'Ваш ник');
            const replyBtnText = i18n.t('channelFeed.reply', 'Ответить');
            const collapseTitle = i18n.t('feed.collapseReplies', 'Свернуть ответы');

            item.innerHTML = `
                <div class="comment-container">
                    <div class="comment-avatar" id="postAvatar_${post.id}" style="background-color: ${nickColor}">
                        ${isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(author).charAt(0).toUpperCase()}
                    </div>
                    <div class="comment-bubble">
                        <div class="comment-header">
                            <span class="comment-nick ${(isAuthorPost || isChannelNick) ? 'channel-nick' : ''}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(isAuthorPost ? currentChannelName : (channelNameFromNick || author))}')">${escapeHtml(isAuthorPost ? currentChannelName : (channelNameFromNick || author))}</span>
                            ${isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                            <span class="comment-date">${date}</span>
                        </div>
                        <div class="comment-text" data-post-id="${post.id}">${processContentWithImages(post.content || post.text)}</div>
                        <div class="comment-actions">
                            <button onclick="toggleLike('${post.id}')" class="like-btn" title="${likeTitle}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                </svg>
                                <span class="like-count">${post.likes || 0}</span>
                            </button>
                            <button onclick="toggleDislike('${post.id}')" class="dislike-btn" title="${dislikeTitle}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                </svg>
                                <span class="dislike-count">${post.dislikes || 0}</span>
                            </button>
                            <button onclick="toggleReplyForm('${post.id}')" class="reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                            ${post.replies && post.replies.length > 0 ? `<button onclick="toggleRepliesVisibility('${post.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${post.id}">▼ ${i18n.t('feed.collapse', 'Свернуть')} (${post.replies.length})</button>` : ''}
                            ${post.hasImages ? `<button onclick="togglePostImage('${post.id}')" class="delete-btn image-toggle-btn" title="${openText}" data-post-id="${post.id}">▼ ${openText}</button>` : ''}
                            <button onclick="deleteFeedPost('${post.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                        </div>
                        <div class="reply-form" id="replyForm_${post.id}" style="display:none;margin-top:8px;padding-left:16px;">
                            <div class="compact-editor-toolbar" id="replyToolbar_${post.id}">
                                <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>

                                <button class="create-link-btn" data-post-id="${post.id}" title="${linkTitle}">🔗</button>
                                <button class="insert-image-btn" data-post-id="${post.id}" title="${imageTitle}">img</button>
                                <button class="center-image-btn" data-post-id="${post.id}" title="${centerTitle}">⌘</button>
                                <button class="close-reply-btn" data-post-id="${post.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                <input type="file" class="image-file-input" data-post-id="${post.id}" accept="image/*" style="display:none" multiple>
                            </div>
                            <div id="replyInput_${post.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                            <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                <input type="text" class="reply-nick-input" id="replyNick_${post.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                <div style="display:flex;gap:6px;">
                                    <button onclick="postAuthorReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                    <button onclick="postReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                </div>
                            </div>
                        </div>
                                             ${post.replies && post.replies.length > 0 ? `
                                 <div class="replies-container">
                                     ${(post.replies || []).slice().sort((a,b)=> (b.created||0)-(a.created||0)).map(reply => {
                                         const replyIsChannel = reply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(reply.nick);
                                         const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(reply.nick);
                                         return `
                                         <div class="reply-item">
                                             <div class="reply-avatar" data-reply-id="${reply.id}" style="background-color: ${replyNickColor}">
                                                 ${reply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(reply.nick).charAt(0).toUpperCase()}
                                             </div>
                                             <div class="reply-bubble">
                                                 <div class="reply-header">
                                                     <span class="reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(reply.nick)}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}')">${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                                                     ${reply.isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                                                     <span class="reply-date">${new Date(reply.created).toLocaleString(i18n.getCurrentLanguage() === 'en' ? 'en-US' : (i18n.getCurrentLanguage() === 'uk' ? 'uk-UA' : 'ru-RU'), {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                                                 </div>
                                                 <div class="reply-text">${processContentWithImages(reply.text)}</div>
                                                                             <div class="reply-actions">
                                <button onclick="toggleReplyLike('${post.id}', '${reply.id}')" class="like-btn" title="${likeTitle}">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${reply.likes || 0}</span>
                                </button>
                                <button onclick="toggleReplyDislike('${post.id}', '${reply.id}')" class="dislike-btn" title="${dislikeTitle}">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${reply.dislikes || 0}</span>
                                </button>
                                <button onclick="toggleReplyToReply('${post.id}', '${reply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                                ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `<button onclick="toggleNestedRepliesVisibility('${post.id}', '${reply.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${post.id}" data-reply-id="${reply.id}">▼ ${i18n.t('feed.collapse', 'Свернуть')} (${reply.nestedReplies.length})</button>` : ''}
                                <button onclick="deleteReply('${post.id}', '${reply.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                            </div>
                                                <div class="nested-reply-form" id="nestedReplyForm_${post.id}_${reply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                                    <div class="compact-editor-toolbar">
                                                        <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                                        <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                                        <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                                                        <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                                                        <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                                                        <button class="create-nested-link-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${linkTitle}">🔗</button>
                                                        <button class="insert-nested-image-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${imageTitle}">img</button>
                                                        <button class="close-nested-reply-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                                        <input type="file" class="nested-image-file-input" data-post-id="${post.id}" data-reply-id="${reply.id}" accept="image/*" style="display:none" multiple>
                                                    </div>
                                                    <div id="nestedReplyInput_${post.id}_${reply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                                    <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                                        <input type="text" class="reply-nick-input" id="nestedReplyNick_${post.id}_${reply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                                        <div style="display:flex;gap:6px;">
                                                            <button onclick="postAuthorNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                                            <button onclick="postNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                                                                                  ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `
                                                     <div class="nested-replies">
                                                         ${renderNestedReplies(reply.nestedReplies, post.id, reply.id, 1)}
                                                     </div>
                                                                                                  ` : ''}
                                        </div>
                                    `}).join('')}
                                </div>
                            ` : ''}
                    </div>
                </div>
            `;

            await processImagesInPost(item, post);

            const postAvatarEl = item.querySelector(`#postAvatar_${post.id}`);
            if (postAvatarEl && (isAuthorPost || isChannelNick)) {
                try {
                    if (isAuthorPost && channelData && channelData.avatar) {
                        const channelDir = await getChannelDirectory();
                        await loadLazyImageFile(channelDir, channelData.avatar, postAvatarEl, 'custom-avatar');
                        postAvatarEl.textContent = '';
                    } else if (channelNameFromNick) {
                        const url = await loadAvatarForChannelName(channelNameFromNick);
                        if (url) {
                            postAvatarEl.style.backgroundImage = `url(${url})`;
                            postAvatarEl.classList.add('custom-avatar');
                            postAvatarEl.textContent = '';
                        }
                    }
                } catch (e) {
                    console.error('Error setting channel avatar for nick', e);
                }
            }

            if (post.replies && post.replies.length > 0) {
                for (const reply of post.replies) {
                    if (reply.isAuthorPost && channelData && channelData.avatar) {
                        const channelDir = await getChannelDirectory();
                        const replyAvatarEl = item.querySelector(`[data-reply-id="${reply.id}"]`);
                        if (replyAvatarEl) {
                            await loadLazyImageFile(channelDir, channelData.avatar, replyAvatarEl, 'custom-avatar');
                            replyAvatarEl.textContent = '';
                        }
                    } else if (/\((ка|ka)\)\s*$/i.test(reply.nick)) {
                        const ch = reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim();
                        const url = await loadAvatarForChannelName(ch);
                        const replyAvatarEl = item.querySelector(`[data-reply-id="${reply.id}"]`);
                        if (url && replyAvatarEl) {
                            replyAvatarEl.style.backgroundImage = `url(${url})`;
                            replyAvatarEl.classList.add('custom-avatar');
                            replyAvatarEl.textContent = '';
                        }
                    }

                    if (reply.nestedReplies && reply.nestedReplies.length > 0) {
                        await loadNestedRepliesAvatars(reply.nestedReplies, post.id, reply.id, 1, item);
                    }
                }
            }

            return item;
        }

        async function renderFeedPageVirtual() {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;

            const totalItems = allFeedPosts.length;
            const startIndex = Math.max(0, Math.floor(virtualScrollTop / itemHeight) - visibleItems);
            const endIndex = Math.min(totalItems, startIndex + visibleItems * 2);

            const offset = startIndex * itemHeight;

            feedSection.style.transform = `translateY(${offset}px)`;
            feedSection.style.height = `${totalItems * itemHeight}px`;

            const postsToShow = allFeedPosts.slice(startIndex, endIndex);
            const fragment = document.createDocumentFragment();

            const renderItems = async () => {
            for (let i = 0; i < postsToShow.length; i++) {
                const post = postsToShow[i];
                const item = await createFeedItem(post);
                item.style.position = 'absolute';
                item.style.top = `${(startIndex + i) * itemHeight}px`;
                fragment.appendChild(item);
                    
                    if (i % 5 === 0) {
                        await new Promise(resolve => requestAnimationFrame(resolve));
            }
                }
            };

            await renderItems();
            feedSection.innerHTML = '';
            feedSection.appendChild(fragment);

            const allPosts = feedSection.querySelectorAll('.feed-comment');
            allPosts.forEach(post => processImagesInPostContent(post));
            
            const allReplies = feedSection.querySelectorAll('.reply-item');
            allReplies.forEach(reply => processImagesInPostContent(reply));
            
            const allNestedReplies = feedSection.querySelectorAll('.nested-reply-item');
            allNestedReplies.forEach(nestedReply => processImagesInPostContent(nestedReply));

            clearTimeout(window.virtualScrollTimeout);
            window.virtualScrollTimeout = setTimeout(() => {
                setupImageLazyLoading();
                setTimeout(() => forceLoadVisibleImages(), 1000);
            }, 100);
        }

        function setupVirtualScroll() {
            const container = document.querySelector('.main-content');
            if (container) {
                let scrollTimeout;
                container.addEventListener('scroll', (e) => {
                    virtualScrollTop = e.target.scrollTop;
                    
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                    renderFeedPageVirtual();
                    }, 16);
                });
            }
        }

        function forceLoadAllImages() {
            const images = document.querySelectorAll('img[data-src]');
            if (DEBUG_MODE) console.log('Force loading', images.length, 'images');
            images.forEach(img => {
                if (img.dataset.src) {
                    if (DEBUG_MODE) console.log('Force loading image:', img.dataset.src);
                    img.src = img.dataset.src;
                    img.classList.remove('lazy');
                    img.classList.add('loaded');
                }
            });
        }

        function forceLoadVisibleImages() {
            const lazyImages = document.querySelectorAll('img[data-src]');
            const loadedImages = document.querySelectorAll('img[src]:not([data-src])');
            const container = document.querySelector('.main-content');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            let loadedCount = 0;

            lazyImages.forEach(img => {
                const imgRect = img.getBoundingClientRect();
                if (imgRect.top < containerRect.bottom + 100 && 
                    imgRect.bottom > containerRect.top - 100) {
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.classList.remove('lazy');
                        img.classList.add('loaded');
                        loadedCount++;
                    }
                }
            });
            
            loadedImages.forEach(img => {
                const imgRect = img.getBoundingClientRect();
                if (imgRect.top < containerRect.bottom + 100 && 
                    imgRect.bottom > containerRect.top - 100) {
                    loadedCount++;
                }
            });
            
            if (DEBUG_MODE) console.log('Force loaded', loadedCount, 'visible images');
        }

        function clearImageCache() {
            imageOptimizationCache.clear();
            if (DEBUG_MODE) console.log('Image optimization cache cleared');
        }

        function setupImageLazyLoading() {
            const lazyImages = document.querySelectorAll('img[data-src]');
            const loadedImages = document.querySelectorAll('img[src]:not([data-src])');
            const totalImages = lazyImages.length + loadedImages.length;
            if (DEBUG_MODE) console.log('Setting up lazy loading for', totalImages, 'images (', lazyImages.length, 'lazy,', loadedImages.length, 'loaded)');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        const originalSrc = img.dataset.src;
                        if (DEBUG_MODE) console.log('Loading lazy image:', originalSrc);
                        
                        const testImg = new Image();
                        testImg.onload = function() {
                            if (DEBUG_MODE) console.log('Lazy image loaded successfully:', originalSrc);
                            img.src = originalSrc;
                            img.classList.remove('lazy');
                            img.classList.add('loaded');
                        };
                        testImg.onerror = function() {
                            if (DEBUG_MODE) console.log('Lazy image failed to load:', originalSrc);
                            img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTIwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZjBmMGYwIi8+Cjx0ZXh0IHg9IjYwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjY2NjIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+0J3QtdC+0LHRgNCw0LbQtdC90LjQtTwvdGV4dD4KPC9zdmc+Cg==';
                            img.classList.remove('lazy');
                            img.classList.add('error');
                        };
                        testImg.src = originalSrc;
                        
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '50px 0px',
                threshold: 0.01
            });
            lazyImages.forEach(img => {
                if (!img.dataset.observed) {
                    img.dataset.observed = 'true';
                    imageObserver.observe(img);
                    if (DEBUG_MODE) console.log('Observing image:', img.dataset.src);
                }
            });

            const bgImages = document.querySelectorAll('[data-src].lazy-avatar');
            const bgImageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const el = entry.target;
                        const originalSrc = el.dataset.src;
                        
                        const testImg = new Image();
                        testImg.onload = function() {
                            el.style.backgroundImage = `url(${originalSrc})`;
                            el.classList.remove('lazy-avatar');
                            el.classList.add('loaded');
                        };
                        testImg.onerror = function() {
                            el.classList.remove('lazy-avatar');
                            el.classList.add('error');
                        };
                        testImg.src = originalSrc;
                        
                        observer.unobserve(el);
                    }
                });
            }, {
                rootMargin: '50px 0px',
                threshold: 0.01
            });
            bgImages.forEach(el => bgImageObserver.observe(el));
        }

        async function createLazyImage(src, className = '') {
            const img = document.createElement('img');
            img.className = (className + ' loaded').trim();
            img.alt = 'Изображение';
            img.style.maxWidth = '120px';
            img.style.maxHeight = '80px';
            img.style.cursor = 'pointer';
            img.style.border = '1px solid #ddd';
            img.style.borderRadius = '4px';
            img.style.objectFit = 'cover';
            img.style.display = 'block';
            img.style.opacity = '1';
            
            img.setAttribute('data-fullsrc', src);
            img.setAttribute('data-expanded', 'false');
            img.onclick = (e) => {
                e.stopPropagation();
                toggleImageSize(img);
            };
            
            img.onerror = function() {
                this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTIwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZjBmMGYwIi8+Cjx0ZXh0IHg9IjYwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjY2NjIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+0J3QtdC+0LHRgNCw0LbQtdC90LjQtTwvdGV4dD4KPC9zdmc+Cg==';
                this.onerror = null;
            };
            
            img.src = src;
            
            return img;
        }


        async function openImageModal(src, fileName = null, postId = null, channelName = null) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;display:flex;align-items:center;justify-content:center;';
            
            modal.innerHTML = `
                <div style="color:white;text-align:center;">
                    <div style="margin-bottom:20px;">Загрузка изображения...</div>
                    <div style="width:50px;height:50px;border:3px solid #333;border-top:3px solid white;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto;"></div>
                </div>
                <style>
                    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
                </style>
            `;
            modal.onclick = () => modal.remove();
            document.body.appendChild(modal);
            
            let imageSrc = src;
            if (fileName && postId) {
                const fullImage = await loadFullImage(fileName, postId, channelName);
                if (fullImage) {
                    imageSrc = fullImage;
                    if (DEBUG_MODE) console.log('Loaded full resolution image from post directory');
                }
            }
            
            modal.innerHTML = `<img src="${imageSrc}" style="max-width:90%;max-height:90%;object-fit:contain;cursor:pointer;">`;
        }

        window.openImageModal = openImageModal;

        async function applyChannelAvatarsForReplies(container) {
            try {
                const replyItems = container.querySelectorAll('.reply-item');
                for (const el of replyItems) {
                    const nickEl = el.querySelector('.reply-nick');
                    const avatarEl = el.querySelector('.reply-avatar');
                    if (!nickEl || !avatarEl) continue;
                    const nickText = (nickEl.getAttribute('data-original-nick') || nickEl.textContent || '').trim();
                    if (/\((ка|ka)\)\s*$/i.test(nickText)) {
                        const ch = nickText.replace(/\((ка|ka)\)\s*$/i,'').trim();
                        const url = await loadAvatarForChannelName(ch);
                        if (url) {
                            avatarEl.style.backgroundImage = `url(${url})`;
                            avatarEl.classList.add('custom-avatar');
                            avatarEl.textContent = '';
                        }
                    }
                }
                const nestedItems = container.querySelectorAll('.nested-reply-item');
                for (const el of nestedItems) {
                    const nickEl = el.querySelector('.nested-reply-nick');
                    const avatarEl = el.querySelector('.nested-reply-avatar');
                    if (!nickEl || !avatarEl) continue;
                    const nickText = (nickEl.getAttribute('data-original-nick') || nickEl.textContent || '').trim();
                    if (/\((ка|ka)\)\s*$/i.test(nickText)) {
                        const ch = nickText.replace(/\((ка|ka)\)\s*$/i,'').trim();
                        const url = await loadAvatarForChannelName(ch);
                        if (url) {
                            avatarEl.style.backgroundImage = `url(${url})`;
                            avatarEl.classList.add('custom-avatar');
                            avatarEl.textContent = '';
                        }
                    }
                }
            } catch (e) {
                console.error('applyChannelAvatarsForReplies error', e);
            }
        }

        function toggleImageSize(imgElement) {
            const isExpanded = imgElement.getAttribute('data-expanded') === 'true';
            const fullSrc = imgElement.getAttribute('data-fullsrc');
            
            if (!isExpanded) {
                imgElement.style.maxWidth = '100%';
                imgElement.style.maxHeight = '400px';
                imgElement.style.width = 'auto';
                imgElement.style.height = 'auto';
                imgElement.style.objectFit = 'contain';
                imgElement.style.opacity = '1';
                imgElement.style.filter = 'none';
                imgElement.setAttribute('data-expanded', 'true');
                
                if (fullSrc && imgElement.src !== fullSrc) {
                    imgElement.src = fullSrc;
                }
            } else {
                imgElement.style.maxWidth = '120px';
                imgElement.style.maxHeight = '80px';
                imgElement.style.width = 'auto';
                imgElement.style.height = 'auto';
                imgElement.style.objectFit = 'cover';
                imgElement.style.opacity = '1';
                imgElement.style.filter = 'none';
                imgElement.setAttribute('data-expanded', 'false');
            }
        }

        function togglePostImage(postId) {
            const postContainer = document.querySelector(`[data-post-id="${postId}"]`)?.closest('.feed-comment');
            if (!postContainer) return;
            
            const images = postContainer.querySelectorAll('.comment-text img');
            if (images.length === 0) return;
            
            images.forEach(img => {
                toggleImageSize(img);
            });
            
            let allExpanded = true;
            images.forEach(img => {
                if (img.getAttribute('data-expanded') !== 'true') {
                    allExpanded = false;
                }
            });
            
            const button = document.querySelector(`.image-toggle-btn[data-post-id="${postId}"]`);
            if (button) {
                button.textContent = allExpanded ? `▼ ${i18n.t('feed.close', 'Закрыть')}` : `▼ ${i18n.t('feed.open', 'Открыть')}`;
                button.title = allExpanded ? i18n.t('feed.closeImages', 'Закрыть изображения') : i18n.t('feed.openImages', 'Открыть изображения');
            }
        }
        
        async function renderFeed() {
            if (DEBUG_MODE) console.log('RenderFeed: Starting render process');
            const savedPrevScrollTop = getMainContainerScrollTop();
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) {
                console.error('RenderFeed: feedSection not found');
                return;
            }

            feedSection.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>${i18n.t('feed.loadingPosts', 'Загрузка постов...')}</div>
                </div>
            `;

            try {
                if (!singlePostId) {
                    if (Array.isArray(channelData.feed) && channelData.feed.length === 1 && channelData.feed[0] && channelData.feed[0].id) {
                        singlePostId = channelData.feed[0].id;
                        if (DEBUG_MODE) console.log('Auto-enabled single post mode from channelData.feed with id:', singlePostId);
                    } else if (Array.isArray(allFeedPosts) && allFeedPosts.length === 1 && allFeedPosts[0] && allFeedPosts[0].id) {
                        singlePostId = allFeedPosts[0].id;
                        if (DEBUG_MODE) console.log('Auto-enabled single post mode from allFeedPosts with id:', singlePostId);
                    }
                }
            } catch (e) {
                console.warn('Auto single-post detection failed:', e);
            }

            if (singlePostId) {
                try {
                    const feedForm = document.querySelector('.feed-form');
                    if (feedForm) feedForm.style.display = 'none';
                    const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
                    if (loadMoreBtn) loadMoreBtn.style.display = 'none';

                    let post = null;
                    if (videoDirectoryHandle && currentChannelName) {
                        post = await loadPostFromDirectory(singlePostId);
                    }
                    if (!post && channelData && Array.isArray(channelData.feed)) {
                        post = channelData.feed.find(p => p && p.id === singlePostId) || null;
                    }

                    if (post && !post.deleted) {
                        if (singleReplyId && Array.isArray(post.replies)) {
                            const target = post.replies.find(r => r.id === singleReplyId);
                            if (target) {
                                post.replies = [target];
                            }
                        }
                        if (!Array.isArray(post.replies)) post.replies = [];
                        channelData.feed = [post];
                        allFeedPosts = [post];
                        feedSection.innerHTML = '';
                        const item = await createFeedItem(post);
                        if (item) {
                            feedSection.appendChild(item);
                            processImagesInPostContent(item);
                            setTimeout(() => {
                                setupImageLazyLoading();
                                setTimeout(() => forceLoadAllImages(), 1000);
                            }, 50);
                            await applyChannelAvatarsForReplies(item);
                        }
                    } else {
                        feedSection.innerHTML = '<div style="text-align:center;color:#7a3c55;padding:40px;font-size:14px;">Пост не найден</div>';
                    }
                } catch (e) {
                    console.error('Render single post error:', e);
                    feedSection.innerHTML = '<div style="text-align:center;color:#7a3c55;padding:40px;font-size:14px;">Ошибка загрузки поста</div>';
                }
                return;
            }

            loadedFeedChunks = [];
            totalFeedCount = 0;
            isLoadingChunk = false;

            if (!channelData.feed || channelData.feed.length === 0) {
                try {
                    await loadPostsFromDirectories();
                } catch (e) {
                    console.error('Error loading posts from directories:', e);
                }
            }
            
            allFeedPosts = (channelData.feed || []).slice().sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            if (DEBUG_MODE) console.log('RenderFeed: allFeedPosts length:', allFeedPosts.length);
            if (DEBUG_MODE) console.log('RenderFeed: channelData.feed length:', channelData.feed ? channelData.feed.length : 0);
            
            if (allFeedPosts && allFeedPosts.length > 0) {
                allFeedPosts = allFeedPosts.filter(post => {
                    if (!post || !post.id) {
                        console.warn('Invalid post found:', post);
                        return false;
                    }
                    return true;
                });
            }

            if (!allFeedPosts || allFeedPosts.length === 0) {
                if (DEBUG_MODE) console.log('RenderFeed: No posts found, showing empty message');
                feedSection.innerHTML = '<div style="text-align:center;color:#7a3c55;padding:40px;font-size:14px;">Лента пуста</div>';
                return;
            }

            if (allFeedPosts.length > 50) {
                virtualScrollTop = getMainContainerScrollTop();
                await renderFeedPageVirtual();

                const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
                if (loadMoreBtn) {
                    loadMoreBtn.style.display = 'none';
                }
            } else {
                feedPage = 0;
                await renderFeedPage();

                const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
                if (loadMoreBtn) {
                    const hasMorePosts = allFeedPosts.length > feedPageSize;
                    loadMoreBtn.style.display = hasMorePosts ? 'block' : 'none';
                    if (DEBUG_MODE) console.log('Load more button visibility:', hasMorePosts ? 'visible' : 'hidden', `(${allFeedPosts.length} posts, page size: ${feedPageSize})`);
                }
            }

            setTimeout(() => {
                setupImageLazyLoading();
                setTimeout(() => forceLoadAllImages(), 2000);
            }, 100);
            
            setMainContainerScrollTop(savedPrevScrollTop);
            virtualScrollTop = savedPrevScrollTop;
        }
        
        async function renderFeedPage() {
            const feedSection = document.getElementById('feedSection');
            const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
            if (!feedSection) return;
            
            const startIndex = feedPage * feedPageSize;
            const endIndex = startIndex + feedPageSize;
            const postsToShow = allFeedPosts.slice(startIndex, endIndex);
            
            if (feedPage === 0) {
                feedSection.innerHTML = '';
            }
            
            for (const post of postsToShow) {
                if (!post || !post.id) {
                    console.warn('Invalid post in renderFeedPage:', post);
                    continue;
                }

                const item = document.createElement('div');
                item.className = 'feed-comment';
                
                const timestamp = post.timestamp || post.created || Date.now();
                const date = new Date(timestamp).toLocaleString('ru-RU', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                const isAuthorPost = post.isAuthorPost || false;
                const author = post.author || post.nick || 'Аноним';
                const isChannelNick = /\((ка|ka)\)\s*$/i.test(author);
                const nickColor = (isAuthorPost || isChannelNick) ? '#d94b88' : getNickColor(author);
                
                item.innerHTML = `
                    <div class="comment-container">
                        <div class="comment-avatar" id="postAvatar_${post.id}" style="background-color: ${nickColor}">
                            ${isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(author).charAt(0).toUpperCase()}
                        </div>
                        <div class="comment-bubble">
                            <div class="comment-header">
                                <span class="comment-nick ${(isAuthorPost || isChannelNick) ? 'channel-nick' : ''}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(isAuthorPost ? currentChannelName : author)}')">${escapeHtml(isAuthorPost ? currentChannelName : author)}</span>
                                ${isAuthorPost ? '<span class="author-badge">Автор</span>' : ''}
                                <span class="comment-date">${date}</span>
                            </div>
                            <div class="comment-text">${processContentWithImages(post.content || post.text)}</div>
                            <div class="comment-actions">
                                <button onclick="toggleLike('${post.id}')" class="like-btn" title="Лайк">
                                    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${post.likes || 0}</span>
                                </button>
                                <button onclick="toggleDislike('${post.id}')" class="dislike-btn" title="Дизлайк">
                                    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${post.dislikes || 0}</span>
                                </button>
                                <button onclick="toggleReplyForm('${post.id}')" class="reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                                ${post.replies && post.replies.length > 0 ? `<button onclick="toggleRepliesVisibility('${post.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${post.id}">▼ ${i18n.t('feed.collapse', 'Свернуть')} (${post.replies.length})</button>` : ''}
                                ${post.hasImages ? `<button onclick="togglePostImage('${post.id}')" class="delete-btn image-toggle-btn" title="${openText}" data-post-id="${post.id}">▼ ${openText}</button>` : ''}
                                <button onclick="deleteFeedPost('${post.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                            </div>
                            <div class="reply-form" id="replyForm_${post.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                <div class="compact-editor-toolbar" id="replyToolbar_${post.id}">
                                    <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                    <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                    <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>

                                    <button class="create-link-btn" data-post-id="${post.id}" title="${linkTitle}">🔗</button>
                                    <button class="insert-image-btn" data-post-id="${post.id}" title="${imageTitle}">img</button>
                                    <button class="center-image-btn" data-post-id="${post.id}" title="${centerTitle}">⌘</button>
                                    <button class="close-reply-btn" data-post-id="${post.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                    <input type="file" class="image-file-input" data-post-id="${post.id}" accept="image/*" style="display:none" multiple>
                                </div>
                                <div id="replyInput_${post.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                    <input type="text" class="reply-nick-input" id="replyNick_${post.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                    <div style="display:flex;gap:6px;">
                                        <button onclick="postAuthorReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                        <button onclick="postReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                    </div>
                                </div>
                            </div>
                                                         ${post.replies && post.replies.length > 0 ? `
                                 <div class="replies-container">
                                     ${(post.replies || []).slice().sort((a,b)=> (b.created||0)-(a.created||0)).map(reply => {
                                         const replyIsChannel = reply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(reply.nick);
                                         const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(reply.nick);
                                         return `
                                         <div class="reply-item">
                                             <div class="reply-avatar" data-reply-id="${reply.id}" style="background-color: ${replyNickColor}">
                                                 ${reply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(reply.nick).charAt(0).toUpperCase()}
                                             </div>
                                             <div class="reply-bubble">
                                                 <div class="reply-header">
                                                     <span class="reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(reply.nick)}">${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                                                     ${reply.isAuthorPost ? '<span class="author-badge">Автор</span>' : ''}
                                                     <span class="reply-date">${new Date(reply.created).toLocaleString('ru-RU', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                                                 </div>
                                                 <div class="reply-text">${processContentWithImages(reply.text)}</div>
                                                                             <div class="reply-actions">
                                <button onclick="toggleReplyLike('${post.id}', '${reply.id}')" class="like-btn" title="Лайк">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${reply.likes || 0}</span>
                                </button>
                                <button onclick="toggleReplyDislike('${post.id}', '${reply.id}')" class="dislike-btn" title="Дизлайк">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${reply.dislikes || 0}</span>
                                </button>
                                <button onclick="toggleReplyToReply('${post.id}', '${reply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                                ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `<button onclick="toggleNestedRepliesVisibility('${post.id}', '${reply.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${post.id}" data-reply-id="${reply.id}">▼ ${i18n.t('feed.collapse', 'Свернуть')} (${reply.nestedReplies.length})</button>` : ''}
                                <button onclick="deleteReply('${post.id}', '${reply.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                            </div>
                                                <div class="nested-reply-form" id="nestedReplyForm_${post.id}_${reply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                                    <div class="compact-editor-toolbar">
                                                        <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                                        <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                                        <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                                                        <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                                                        <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                                                        <button class="create-nested-link-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${linkTitle}">🔗</button>
                                                        <button class="insert-nested-image-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${imageTitle}">img</button>
                                                        <button class="close-nested-reply-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                                        <input type="file" class="nested-image-file-input" data-post-id="${post.id}" data-reply-id="${reply.id}" accept="image/*" style="display:none" multiple>
                                                    </div>
                                                    <div id="nestedReplyInput_${post.id}_${reply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                                    <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                                        <input type="text" class="reply-nick-input" id="nestedReplyNick_${post.id}_${reply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                                        <div style="display:flex;gap:6px;">
                                                            <button onclick="postAuthorNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                                            <button onclick="postNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                                                                                  ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `
                                                     <div class="nested-replies">
                                                         ${renderNestedReplies(reply.nestedReplies, post.id, reply.id, 1)}
                                                     </div>
                                                                                                  ` : ''}
                                        </div>
                                    `}).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                feedSection.appendChild(item);
                
                processImagesInPostContent(item);

                await applyChannelAvatarsForReplies(item);
                
                if (isAuthorPost && channelData && channelData.avatar) {
                    const channelDir = await getChannelDirectory();
                    const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                    if (avatarUrl) {
                        const postAvatarEl = document.getElementById(`postAvatar_${post.id}`);
                        if (postAvatarEl) {
                            postAvatarEl.style.backgroundImage = `url(${avatarUrl})`;
                            postAvatarEl.classList.add('custom-avatar');
                            postAvatarEl.textContent = '';
                        }
                    }
                }
                
                if (post.replies && post.replies.length > 0) {
                    for (const reply of post.replies) {
                        if (reply.isAuthorPost && channelData && channelData.avatar) {
                            const channelDir = await getChannelDirectory();
                            const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                            if (avatarUrl) {
                                const replyAvatarEl = document.querySelector(`[data-reply-id="${reply.id}"]`);
                                if (replyAvatarEl) {
                                    replyAvatarEl.style.backgroundImage = `url(${avatarUrl})`;
                                    replyAvatarEl.classList.add('custom-avatar');
                                    replyAvatarEl.textContent = '';
                                }
                            }
                        }
                        
                        if (reply.nestedReplies && reply.nestedReplies.length > 0) {
                            await loadNestedRepliesAvatars(reply.nestedReplies, post.id, reply.id, 1, item);
                        }
                    }
                }
            };
            
            if (loadMoreBtn && allFeedPosts.length <= 50) {
                if (endIndex < allFeedPosts.length || loadedFeedChunks.length < totalFeedCount) {
                    loadMoreBtn.style.display = 'block';
                } else {
                    loadMoreBtn.style.display = 'none';
                }
            }

            setTimeout(() => {
                setupImageLazyLoading();
                setTimeout(() => forceLoadAllImages(), 2000);
            }, 50);
        }
        
        async function loadMoreFeedPosts() {
            if (allFeedPosts.length > 50) {
                return;
            }

            const currentEndIndex = (feedPage + 1) * feedPageSize;

            if (currentEndIndex >= loadedFeedChunks.length && loadedFeedChunks.length < totalFeedCount) {
                const startIndex = loadedFeedChunks.length;
                await loadChannelDataIncremental(startIndex, 50);
                allFeedPosts = [...loadedFeedChunks].sort((a, b) => b.timestamp - a.timestamp);
            }

            feedPage++;
            await renderFeedPage();
        }

        async function loadMorePostsFromServer() {
            const channelId = getChannelIdFromUrl();
            const storedData = localStorage.getItem(`channel_${channelId}`);
            
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    if (data.feed && data.feed.length > allFeedPosts.length) {
                        allFeedPosts = [...data.feed].sort((a, b) => b.timestamp - a.timestamp);
                        await renderFeedPage();
                    }
                } catch (e) {
                    console.error('Error loading more posts:', e);
                }
            }
        }
        
        function toggleReplyForm(postId) {
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = replyForm.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function toggleRepliesVisibility(postId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const feedComment = collapseBtn.closest('.feed-comment');
            if (!feedComment) return;
            
            const repliesContainer = feedComment.querySelector('.replies-container');
            if (!repliesContainer) return;
            
            const isCollapsed = repliesContainer.classList.contains('collapsed');
            const replyCount = repliesContainer.querySelectorAll('.reply-item').length;
            
            if (isCollapsed) {
                repliesContainer.classList.remove('collapsed');
                collapseBtn.innerHTML = `▼ Свернуть (${replyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                repliesContainer.classList.add('collapsed');
                collapseBtn.innerHTML = `▶ Развернуть (${replyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        function toggleReplyToReply(postId, replyId) {
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = nestedReplyForm.style.display === 'none' ? 'block' : 'none';
                if (nestedReplyForm.style.display === 'block') {
                    const input = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                    if (input) input.focus();
                }
            }
        }

        function toggleNestedRepliesVisibility(postId, replyId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"][data-reply-id="${replyId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const replyContainer = collapseBtn.closest('.reply-item');
            if (!replyContainer) return;
            
            const nestedReplies = replyContainer.querySelector('.nested-replies');
            if (!nestedReplies) return;
            
            const isCollapsed = nestedReplies.classList.contains('collapsed');
            const nestedReplyCount = nestedReplies.querySelectorAll('.nested-reply-item').length;
            
            if (isCollapsed) {
                nestedReplies.classList.remove('collapsed');
                collapseBtn.innerHTML = `▼ Свернуть (${nestedReplyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                nestedReplies.classList.add('collapsed');
                collapseBtn.innerHTML = `▶ Развернуть (${nestedReplyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        function toggleDeepNestedRepliesVisibility(postId, parentReplyId, replyId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"][data-parent-reply-id="${parentReplyId}"][data-reply-id="${replyId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const nestedReplyContainer = collapseBtn.closest('.nested-reply-item');
            if (!nestedReplyContainer) return;
            
            const nestedReplies = nestedReplyContainer.querySelector('.nested-replies');
            if (!nestedReplies) return;
            
            const isCollapsed = nestedReplies.classList.contains('collapsed');
            const nestedReplyCount = nestedReplies.querySelectorAll('.nested-reply-item').length;
            
            if (isCollapsed) {
                nestedReplies.classList.remove('collapsed');
                collapseBtn.innerHTML = `▼ Свернуть (${nestedReplyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                nestedReplies.classList.add('collapsed');
                collapseBtn.innerHTML = `▶ Развернуть (${nestedReplyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        function createReplyElement(reply, postId) {
            const replyIsChannel = reply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(reply.nick);
            const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(reply.nick);
            
            const likeTitle = i18n.t('feed.like', 'Лайк');
            const dislikeTitle = i18n.t('feed.dislike', 'Дизлайк');
            const replyBtnText = i18n.t('channelFeed.reply', 'Ответить');
            const reportText = i18n.t('channelFeed.report', 'Пожаловаться');
            const authorBadge = i18n.t('feed.author', 'Автор');
            const boldTitle = i18n.t('channelFeed.editorBold', 'Жирный');
            const italicTitle = i18n.t('channelFeed.editorItalic', 'Курсив');
            const underlineTitle = i18n.t('channelFeed.editorUnderline', 'Подчеркнутый');
            const listTitle = i18n.t('channelFeed.editorList', 'Список');
            const numberedListTitle = i18n.t('channelFeed.editorNumberedList', 'Нумерованный список');
            const linkTitle = i18n.t('channelFeed.editorLink', 'Ссылка');
            const imageTitle = i18n.t('channelFeed.editorImage', 'Картинка');
            const closeTitle = i18n.t('channelFeed.close', 'Закрыть');
            const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', 'Ответить...');
            const yourNickPlaceholder = i18n.t('channelFeed.yourNick', 'Ваш ник');
            const dateLocale = i18n.getCurrentLanguage() === 'en' ? 'en-US' : (i18n.getCurrentLanguage() === 'uk' ? 'uk-UA' : 'ru-RU');
            
            const replyEl = document.createElement('div');
            replyEl.className = 'reply-item';
            replyEl.innerHTML = `
                <div class="reply-avatar" data-reply-id="${reply.id}" style="background-color: ${replyNickColor}">
                    ${reply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(reply.nick).charAt(0).toUpperCase()}
                </div>
                <div class="reply-bubble">
                    <div class="reply-header">
                        <span class="reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(reply.nick)}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}')">${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                        ${reply.isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                        <span class="reply-date">${new Date(reply.created).toLocaleString(dateLocale, {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                    </div>
                    <div class="reply-text">${processContentWithImages(reply.text)}</div>
                    <div class="reply-actions">
                        <button onclick="toggleReplyLike('${postId}', '${reply.id}')" class="like-btn" title="${likeTitle}">
                            <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                            </svg>
                            <span class="like-count">${reply.likes || 0}</span>
                        </button>
                        <button onclick="toggleReplyDislike('${postId}', '${reply.id}')" class="dislike-btn" title="${dislikeTitle}">
                            <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                            </svg>
                            <span class="dislike-count">${reply.dislikes || 0}</span>
                        </button>
                        <button onclick="toggleReplyToReply('${postId}', '${reply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                        <button onclick="deleteReply('${postId}', '${reply.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                    </div>
                    <div class="nested-reply-form" id="nestedReplyForm_${postId}_${reply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                        <div class="compact-editor-toolbar">
                            <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                            <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                            <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                            <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                            <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                            <button class="create-nested-link-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${linkTitle}">🔗</button>
                            <button class="insert-nested-image-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${imageTitle}">img</button>
                            <button class="close-nested-reply-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                            <input type="file" class="nested-image-file-input" data-post-id="${postId}" data-reply-id="${reply.id}" accept="image/*" style="display:none" multiple>
                        </div>
                        <div id="nestedReplyInput_${postId}_${reply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                        <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                            <input type="text" class="reply-nick-input" id="nestedReplyNick_${postId}_${reply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                            <div style="display:flex;gap:6px;">
                                <button onclick="postAuthorNestedReply('${postId}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                <button onclick="postNestedReply('${postId}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            return replyEl;
        }

        function createNestedReplyElement(nestedReply, postId, parentReplyId, depth = 1) {
            const maxDepth = 10;
            const replyIsChannel = nestedReply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(nestedReply.nick);
            const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(nestedReply.nick);
            
            const likeTitle = i18n.t('feed.like', 'Лайк');
            const dislikeTitle = i18n.t('feed.dislike', 'Дизлайк');
            const replyBtnText = i18n.t('channelFeed.reply', 'Ответить');
            const reportText = i18n.t('channelFeed.report', 'Пожаловаться');
            const authorBadge = i18n.t('feed.author', 'Автор');
            const boldTitle = i18n.t('channelFeed.editorBold', 'Жирный');
            const italicTitle = i18n.t('channelFeed.editorItalic', 'Курсив');
            const underlineTitle = i18n.t('channelFeed.editorUnderline', 'Подчеркнутый');
            const listTitle = i18n.t('channelFeed.editorList', 'Список');
            const numberedListTitle = i18n.t('channelFeed.editorNumberedList', 'Нумерованный список');
            const linkTitle = i18n.t('channelFeed.editorLink', 'Ссылка');
            const imageTitle = i18n.t('channelFeed.editorImage', 'Картинка');
            const closeTitle = i18n.t('channelFeed.close', 'Закрыть');
            const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', 'Ответить...');
            const yourNickPlaceholder = i18n.t('channelFeed.yourNick', 'Ваш ник');
            const dateLocale = i18n.getCurrentLanguage() === 'en' ? 'en-US' : (i18n.getCurrentLanguage() === 'uk' ? 'uk-UA' : 'ru-RU');
            
            const nestedEl = document.createElement('div');
            nestedEl.className = 'nested-reply-item';
            nestedEl.innerHTML = `
                <div class="nested-reply-avatar" data-nested-reply-id="${nestedReply.id}" style="background-color: ${replyNickColor}">
                    ${nestedReply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(nestedReply.nick).charAt(0).toUpperCase()}
                </div>
                <div class="nested-reply-bubble">
                    <div class="nested-reply-header">
                        <span class="nested-reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(nestedReply.nick)}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(nestedReply.isAuthorPost ? currentChannelName : nestedReply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}')">${escapeHtml(nestedReply.isAuthorPost ? currentChannelName : nestedReply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                        ${nestedReply.isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                        <span class="nested-reply-date">${new Date(nestedReply.created).toLocaleString(dateLocale, {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                    </div>
                    <div class="nested-reply-text">${processContentWithImages(nestedReply.text)}</div>
                    <div class="nested-reply-actions">
                        <button onclick="toggleNestedReplyLike('${postId}', '${parentReplyId}', '${nestedReply.id}')" class="like-btn" title="${likeTitle}">
                            <svg width="12" height="12" viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                            </svg>
                            <span class="like-count">${nestedReply.likes || 0}</span>
                        </button>
                        <button onclick="toggleNestedReplyDislike('${postId}', '${parentReplyId}', '${nestedReply.id}')" class="dislike-btn" title="${dislikeTitle}">
                            <svg width="12" height="12" viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                            </svg>
                            <span class="dislike-count">${nestedReply.dislikes || 0}</span>
                        </button>
                        ${depth < maxDepth ? `<button onclick="toggleNestedReplyToReply('${postId}', '${parentReplyId}', '${nestedReply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>` : ''}
                        <button onclick="deleteNestedReply('${postId}', '${parentReplyId}', '${nestedReply.id}')" class="nested-delete-btn" title="${reportText}">${reportText}</button>
                    </div>
                    ${depth < maxDepth ? `
                        <div class="nested-reply-form" id="nestedReplyForm_${postId}_${nestedReply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                            <div class="compact-editor-toolbar">
                                <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                                <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                                <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                                <button class="create-nested-link-btn" data-post-id="${postId}" data-reply-id="${nestedReply.id}" title="${linkTitle}">🔗</button>
                                <button class="insert-nested-image-btn" data-post-id="${postId}" data-reply-id="${nestedReply.id}" title="${imageTitle}">img</button>
                                <button class="close-nested-reply-btn" data-post-id="${postId}" data-reply-id="${nestedReply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                <input type="file" class="nested-image-file-input" data-post-id="${postId}" data-reply-id="${nestedReply.id}" accept="image/*" style="display:none" multiple>
                            </div>
                            <div id="nestedReplyInput_${postId}_${nestedReply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                            <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                <input type="text" class="reply-nick-input" id="nestedReplyNick_${postId}_${nestedReply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                <div style="display:flex;gap:6px;">
                                    <button onclick="postAuthorNestedReply('${postId}', '${nestedReply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                    <button onclick="postNestedReply('${postId}', '${nestedReply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            return nestedEl;
        }

        async function loadReplyAvatar(replyEl, reply) {
            const avatarEl = replyEl.querySelector(`[data-reply-id="${reply.id}"]`);
            if (!avatarEl) return;
            
            if (reply.isAuthorPost && channelData && channelData.avatar) {
                const channelDir = await getChannelDirectory();
                await loadLazyImageFile(channelDir, channelData.avatar, avatarEl, 'custom-avatar');
                avatarEl.textContent = '';
            } else if (/\((ка|ka)\)\s*$/i.test(reply.nick)) {
                const ch = reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim();
                const url = await loadAvatarForChannelName(ch);
                if (url) {
                    avatarEl.style.backgroundImage = `url(${url})`;
                    avatarEl.classList.add('custom-avatar');
                    avatarEl.textContent = '';
                }
            }
        }

        async function loadNestedReplyAvatar(nestedEl, nestedReply) {
            const avatarEl = nestedEl.querySelector(`[data-nested-reply-id="${nestedReply.id}"]`);
            if (!avatarEl) return;
            
            if (nestedReply.isAuthorPost && channelData && channelData.avatar) {
                const channelDir = await getChannelDirectory();
                await loadLazyImageFile(channelDir, channelData.avatar, avatarEl, 'custom-avatar');
                avatarEl.textContent = '';
            } else if (/\((ка|ka)\)\s*$/i.test(nestedReply.nick)) {
                const ch = nestedReply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim();
                const url = await loadAvatarForChannelName(ch);
                if (url) {
                    avatarEl.style.backgroundImage = `url(${url})`;
                    avatarEl.classList.add('custom-avatar');
                    avatarEl.textContent = '';
                }
            }
        }

        async function postNestedReply(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const reply = findReplyRecursively(post.replies, replyId);
            if (!reply) return;
            
            const nestedReplyInput = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
            const nestedReplyNick = document.getElementById(`nestedReplyNick_${postId}_${replyId}`);
            
            if (!nestedReplyInput || !nestedReplyNick) return;
            
            const replyText = nestedReplyInput.innerHTML.trim();
            const nick = nestedReplyNick.value.trim();
            
            if (!replyText || !nick) return;
            
            const processedText = await processImagesInContent(replyText);
            
            const nestedReply = {
                id: Date.now().toString(),
                nick: nick,
                text: processedText,
                created: Date.now(),
                isAuthorPost: false
            };
            
            if (!reply.nestedReplies) reply.nestedReplies = [];
            reply.nestedReplies.push(nestedReply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            nestedReplyInput.innerHTML = '';
            nestedReplyNick.value = '';
            
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = 'none';
            }
            
            const parentReplyBubble = nestedReplyForm?.closest('.reply-bubble') || nestedReplyForm?.closest('.nested-reply-bubble');
            if (parentReplyBubble) {
                let nestedRepliesContainer = parentReplyBubble.querySelector(':scope > .nested-replies');
                if (!nestedRepliesContainer) {
                    nestedRepliesContainer = document.createElement('div');
                    nestedRepliesContainer.className = 'nested-replies';
                    parentReplyBubble.appendChild(nestedRepliesContainer);
                }
                
                let depth = 1;
                let parent = parentReplyBubble;
                while (parent) {
                    if (parent.classList.contains('nested-reply-bubble')) depth++;
                    parent = parent.parentElement?.closest('.nested-reply-bubble');
                }
                
                const nestedEl = createNestedReplyElement(nestedReply, postId, replyId, depth);
                nestedRepliesContainer.appendChild(nestedEl);
                
                await loadNestedReplyAvatar(nestedEl, nestedReply);
                
                processImagesInPostContent(nestedEl);
            }
        }

        function findReplyRecursively(replies, replyId) {
            if (!replies) return null;
            
            for (const reply of replies) {
                if (reply.id === replyId) {
                    return reply;
                }
                if (reply.nestedReplies) {
                    const found = findReplyRecursively(reply.nestedReplies, replyId);
                    if (found) return found;
                }
            }
            return null;
        }

        async function postAuthorNestedReply(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const reply = findReplyRecursively(post.replies, replyId);
            if (!reply) return;
            
            const nestedReplyInput = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
            
            if (!nestedReplyInput) return;
            
            const replyText = nestedReplyInput.innerHTML.trim();
            
            if (!replyText) return;
            
            const processedText = await processImagesInContent(replyText);
            
            const nestedReply = {
                id: Date.now().toString(),
                nick: channelData.name || currentChannelName,
                text: processedText,
                created: Date.now(),
                isAuthorPost: true
            };
            
            if (!reply.nestedReplies) reply.nestedReplies = [];
            reply.nestedReplies.push(nestedReply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            nestedReplyInput.innerHTML = '';
            
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = 'none';
            }
            
            const parentReplyBubble = nestedReplyForm?.closest('.reply-bubble') || nestedReplyForm?.closest('.nested-reply-bubble');
            if (parentReplyBubble) {
                let nestedRepliesContainer = parentReplyBubble.querySelector(':scope > .nested-replies');
                if (!nestedRepliesContainer) {
                    nestedRepliesContainer = document.createElement('div');
                    nestedRepliesContainer.className = 'nested-replies';
                    parentReplyBubble.appendChild(nestedRepliesContainer);
                }
                
                let depth = 1;
                let parent = parentReplyBubble;
                while (parent) {
                    if (parent.classList.contains('nested-reply-bubble')) depth++;
                    parent = parent.parentElement?.closest('.nested-reply-bubble');
                }
                
                const nestedEl = createNestedReplyElement(nestedReply, postId, replyId, depth);
                nestedRepliesContainer.appendChild(nestedEl);
                
                await loadNestedReplyAvatar(nestedEl, nestedReply);
                
                processImagesInPostContent(nestedEl);
            }
        }

        async function deleteNestedReply(postId, parentReplyId, nestedReplyId) {
            if (!confirm('Удалить этот ответ?')) return;
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const replies = await readJSONFile(postDir, 'replies.json', []);
                    
                    const updatedReplies = deleteNestedReplyFromArray(replies, parentReplyId, nestedReplyId);
                    
                    await writeJSONFile(postDir, 'replies.json', updatedReplies);
                    if (DEBUG_MODE) console.log('Updated nested replies in post directory');
                }
            } catch (e) {
                console.error('Error updating nested replies in post directory:', e);
            }
            
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const parentReply = findReplyRecursively(post.replies, parentReplyId);
            if (parentReply && parentReply.nestedReplies) {
                parentReply.nestedReplies = parentReply.nestedReplies.filter(nr => nr.id !== nestedReplyId);
                
                const allFeedPost = allFeedPosts.find(p => p.id === postId);
                if (allFeedPost) {
                    const allFeedParentReply = findReplyRecursively(allFeedPost.replies, parentReplyId);
                    if (allFeedParentReply && allFeedParentReply.nestedReplies) {
                        allFeedParentReply.nestedReplies = allFeedParentReply.nestedReplies.filter(nr => nr.id !== nestedReplyId);
                    }
                }
                
                await saveChannelData();
                
                const nestedReplyEl = document.querySelector(`[data-nested-reply-id="${nestedReplyId}"]`)?.closest('.nested-reply-item');
                if (nestedReplyEl) {
                    nestedReplyEl.remove();
                    
                    const parentReplyEl = document.querySelector(`[data-reply-id="${parentReplyId}"]`)?.closest('.reply-item') ||
                                          document.querySelector(`[data-nested-reply-id="${parentReplyId}"]`)?.closest('.nested-reply-item');
                    if (parentReplyEl) {
                        const collapseBtn = parentReplyEl.querySelector('.collapse-btn[data-reply-id="' + parentReplyId + '"]') ||
                                           parentReplyEl.querySelector('.collapse-btn[data-parent-reply-id="' + parentReplyId + '"]');
                        if (collapseBtn) {
                            if (parentReply.nestedReplies.length > 0) {
                                collapseBtn.textContent = `▼ Свернуть (${parentReply.nestedReplies.length})`;
                            } else {
                                collapseBtn.remove();
                            }
                        }
                    }
                }
            }
        }

        function deleteNestedReplyFromArray(replies, parentReplyId, nestedReplyId) {
            return replies.map(reply => {
                if (reply.id === parentReplyId && reply.nestedReplies) {
                    return {
                        ...reply,
                        nestedReplies: reply.nestedReplies.filter(nr => nr.id !== nestedReplyId)
                    };
                }
                if (reply.nestedReplies) {
                    return {
                        ...reply,
                        nestedReplies: deleteNestedReplyFromArray(reply.nestedReplies, parentReplyId, nestedReplyId)
                    };
                }
                return reply;
            });
        }

        function toggleNestedReplyToReply(postId, parentReplyId, replyId) {
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = nestedReplyForm.style.display === 'none' ? 'block' : 'none';
                if (nestedReplyForm.style.display === 'block') {
                    const input = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                    if (input) input.focus();
                }
            }
        }

        function renderNestedReplies(replies, postId, parentReplyId, depth = 1) {
            const maxDepth = 10;
            
            const likeTitle = i18n.t('feed.like', 'Лайк');
            const dislikeTitle = i18n.t('feed.dislike', 'Дизлайк');
            const replyBtnText = i18n.t('channelFeed.reply', 'Ответить');
            const reportText = i18n.t('channelFeed.report', 'Пожаловаться');
            const authorBadge = i18n.t('feed.author', 'Автор');
            const boldTitle = i18n.t('channelFeed.editorBold', 'Жирный');
            const italicTitle = i18n.t('channelFeed.editorItalic', 'Курсив');
            const underlineTitle = i18n.t('channelFeed.editorUnderline', 'Подчеркнутый');
            const listTitle = i18n.t('channelFeed.editorList', 'Список');
            const numberedListTitle = i18n.t('channelFeed.editorNumberedList', 'Нумерованный список');
            const linkTitle = i18n.t('channelFeed.editorLink', 'Ссылка');
            const imageTitle = i18n.t('channelFeed.editorImage', 'Картинка');
            const closeTitle = i18n.t('channelFeed.close', 'Закрыть');
            const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', 'Ответить...');
            const yourNickPlaceholder = i18n.t('channelFeed.yourNick', 'Ваш ник');
            const collapseTitle = i18n.t('feed.collapseReplies', 'Свернуть ответы');
            const maxDepthReachedText = i18n.t('channelFeed.maxDepthReached', 'Максимальная глубина вложенности достигнута');
            
            if (depth > maxDepth) {
                return `<div style="padding: 4px; font-size: 8px; color: #999; text-align: center; background: #f9f9f9; border-radius: 2px; margin: 2px 0;">
                    ${maxDepthReachedText}
                </div>`;
            }
            
            return replies.map(reply => {
                const replyIsChannel = reply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(reply.nick);
                const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(reply.nick);
                const replyHtml = `
                    <div class="nested-reply-item">
                        <div class="nested-reply-avatar" data-nested-reply-id="${reply.id}" style="background-color: ${replyNickColor}">
                            ${reply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(reply.nick).charAt(0).toUpperCase()}
                        </div>
                        <div class="nested-reply-bubble">
                            <div class="nested-reply-header">
                                <span class="nested-reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(reply.nick)}" style="cursor: pointer;" onclick="goToChannelFeed('${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}')">${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                                ${reply.isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                                <span class="nested-reply-date">${new Date(reply.created).toLocaleString('ru-RU', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                            </div>
                            <div class="nested-reply-text">${processContentWithImages(reply.text)}</div>
                            <div class="nested-reply-actions">
                                <button onclick="toggleNestedReplyLike('${postId}', '${parentReplyId}', '${reply.id}')" class="like-btn" title="${likeTitle}">
                                    <svg width="12" height="12" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${reply.likes || 0}</span>
                                </button>
                                <button onclick="toggleNestedReplyDislike('${postId}', '${parentReplyId}', '${reply.id}')" class="dislike-btn" title="${dislikeTitle}">
                                    <svg width="12" height="12" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${reply.dislikes || 0}</span>
                                </button>
                                ${depth < maxDepth ? `<button onclick="toggleNestedReplyToReply('${postId}', '${parentReplyId}', '${reply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>` : ''}
                                ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `<button onclick="toggleDeepNestedRepliesVisibility('${postId}', '${parentReplyId}', '${reply.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${postId}" data-parent-reply-id="${parentReplyId}" data-reply-id="${reply.id}">▼ ${collapseTitle} (${reply.nestedReplies.length})</button>` : ''}
                                <button onclick="deleteNestedReply('${postId}', '${parentReplyId}', '${reply.id}')" class="nested-delete-btn" title="${reportText}">${reportText}</button>
                            </div>
                            ${depth < maxDepth ? `
                                <div class="nested-reply-form" id="nestedReplyForm_${postId}_${reply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                    <div class="compact-editor-toolbar">
                                        <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                        <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                        <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                                        <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                                        <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                                        <button class="create-nested-link-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${linkTitle}">🔗</button>
                                        <button class="insert-nested-image-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${imageTitle}">img</button>
                                        <button class="close-nested-reply-btn" data-post-id="${postId}" data-reply-id="${reply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                        <input type="file" class="nested-image-file-input" data-post-id="${postId}" data-reply-id="${reply.id}" accept="image/*" style="display:none" multiple>
                                    </div>
                                    <div id="nestedReplyInput_${postId}_${reply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                    <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                        <input type="text" class="reply-nick-input" id="nestedReplyNick_${postId}_${reply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                        <div style="display:flex;gap:6px;">
                                            <button onclick="postAuthorNestedReply('${postId}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                            <button onclick="postNestedReply('${postId}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                        </div>
                                    </div>
                                </div>
                            ` : ''}
                            ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `
                                <div class="nested-replies">
                                    ${renderNestedReplies(reply.nestedReplies, postId, reply.id, depth + 1)}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                
                return replyHtml;
            }).join('');
        }
        
        async function loadNestedRepliesAvatars(replies, postId, parentReplyId, depth = 1, containerEl = document) {
            const maxDepth = 10;

            if (depth > maxDepth) return;

            for (const reply of replies) {
                if (reply.isAuthorPost && channelData && channelData.avatar) {
                    const channelDir = await getChannelDirectory();
                    const nestedReplyAvatarEl = containerEl.querySelector(`[data-nested-reply-id="${reply.id}"]`);
                    if (nestedReplyAvatarEl) {
                        await loadLazyImageFile(channelDir, channelData.avatar, nestedReplyAvatarEl, 'custom-avatar');
                        nestedReplyAvatarEl.textContent = '';
                    }
                } else if (/\((ка|ka)\)\s*$/i.test(reply.nick)) {
                    const ch = reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim();
                    const url = await loadAvatarForChannelName(ch);
                    const nestedReplyAvatarEl = containerEl.querySelector(`[data-nested-reply-id="${reply.id}"]`);
                    if (url && nestedReplyAvatarEl) {
                        nestedReplyAvatarEl.style.backgroundImage = `url(${url})`;
                        nestedReplyAvatarEl.classList.add('custom-avatar');
                        nestedReplyAvatarEl.textContent = '';
                    }
                }

                if (reply.nestedReplies && reply.nestedReplies.length > 0) {
                    await loadNestedRepliesAvatars(reply.nestedReplies, postId, reply.id, depth + 1, containerEl);
                }
            }
        }
        
        async function postReply(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const replyInput = document.getElementById(`replyInput_${postId}`);
            const replyNick = document.getElementById(`replyNick_${postId}`);
            
            if (!replyInput || !replyNick) return;
            
            const replyText = replyInput.innerHTML.trim();
            const nick = replyNick.value.trim();
            
            if (DEBUG_MODE) console.log('Reply text:', replyText);
            if (DEBUG_MODE) console.log('Nick:', nick);
            
            if (!replyText) {
                alert('Введите текст ответа');
                return;
            }
            
            if (!nick) {
                alert('Введите ваш ник');
                return;
            }
            
            const processedText = await processImagesInContent(replyText);
            if (DEBUG_MODE) console.log('Processed text:', processedText);
            
            const reply = {
                id: Date.now().toString(),
                nick: nick,
                text: processedText,
                created: Date.now(),
                isAuthorPost: false
            };
            
            if (!post.replies) post.replies = [];
            post.replies.push(reply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            replyInput.innerHTML = '';
            replyNick.value = '';
            
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = 'none';
            }
            
            const postEl = document.querySelector(`[data-post-id="${postId}"]`);
            if (postEl) {
                const commentBubble = postEl.querySelector('.comment-bubble');
                if (commentBubble) {
                    let repliesContainer = commentBubble.querySelector('.replies-container');
                    if (!repliesContainer) {
                        repliesContainer = document.createElement('div');
                        repliesContainer.className = 'replies-container';
                        commentBubble.appendChild(repliesContainer);
                    }
                    
                    const replyEl = createReplyElement(reply, postId);
                    repliesContainer.insertBefore(replyEl, repliesContainer.firstChild);
                    
                    await loadReplyAvatar(replyEl, reply);
                    
                    processImagesInPostContent(replyEl);
                    
                    const collapseBtn = postEl.querySelector('.collapse-btn[data-post-id="' + postId + '"]');
                    if (collapseBtn) {
                        collapseBtn.textContent = `▼ Свернуть (${post.replies.length})`;
                    } else {
                        const replyBtn = postEl.querySelector('.reply-btn');
                        if (replyBtn) {
                            const newCollapseBtn = document.createElement('button');
                            newCollapseBtn.className = 'collapse-btn';
                            newCollapseBtn.title = 'Свернуть ответы';
                            newCollapseBtn.setAttribute('data-post-id', postId);
                            newCollapseBtn.textContent = `▼ Свернуть (${post.replies.length})`;
                            newCollapseBtn.onclick = () => toggleRepliesVisibility(postId);
                            replyBtn.insertAdjacentElement('afterend', newCollapseBtn);
                        }
                    }
                }
            }
        }
        
        async function postAuthorReply(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const replyInput = document.getElementById(`replyInput_${postId}`);
            
            if (!replyInput) return;
            
            const replyText = replyInput.innerHTML.trim();
            
            if (!replyText) {
                alert('Введите текст ответа');
                return;
            }
            
            const processedText = await processImagesInContent(replyText);
            
            const reply = {
                id: Date.now().toString(),
                nick: channelData.name || currentChannelName,
                text: processedText,
                created: Date.now(),
                isAuthorPost: true
            };
            
            if (!post.replies) post.replies = [];
            post.replies.push(reply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            replyInput.innerHTML = '';
            
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = 'none';
            }
            
            const postEl = document.querySelector(`[data-post-id="${postId}"]`);
            if (postEl) {
                const commentBubble = postEl.querySelector('.comment-bubble');
                if (commentBubble) {
                    let repliesContainer = commentBubble.querySelector('.replies-container');
                    if (!repliesContainer) {
                        repliesContainer = document.createElement('div');
                        repliesContainer.className = 'replies-container';
                        commentBubble.appendChild(repliesContainer);
                    }
                    
                    const replyEl = createReplyElement(reply, postId);
                    repliesContainer.insertBefore(replyEl, repliesContainer.firstChild);
                    
                    await loadReplyAvatar(replyEl, reply);
                    
                    processImagesInPostContent(replyEl);
                    
                    const collapseBtn = postEl.querySelector('.collapse-btn[data-post-id="' + postId + '"]');
                    if (collapseBtn) {
                        collapseBtn.textContent = `▼ Свернуть (${post.replies.length})`;
                    } else {
                        const replyBtn = postEl.querySelector('.reply-btn');
                        if (replyBtn) {
                            const newCollapseBtn = document.createElement('button');
                            newCollapseBtn.className = 'collapse-btn';
                            newCollapseBtn.title = 'Свернуть ответы';
                            newCollapseBtn.setAttribute('data-post-id', postId);
                            newCollapseBtn.textContent = `▼ Свернуть (${post.replies.length})`;
                            newCollapseBtn.onclick = () => toggleRepliesVisibility(postId);
                            replyBtn.insertAdjacentElement('afterend', newCollapseBtn);
                        }
                    }
                }
            }
        }
        
                        async function deleteReply(postId, replyId) {
            if (!confirm('Удалить этот ответ?')) return;
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const replies = await readJSONFile(postDir, 'replies.json', []);
                    const updatedReplies = replies.filter(r => r.id !== replyId);
                    
                    await writeJSONFile(postDir, 'replies.json', updatedReplies);
                    if (DEBUG_MODE) console.log('Updated replies in post directory');
                }
            } catch (e) {
                console.error('Error updating replies in post directory:', e);
            }
            
            const post = channelData.feed.find(p => p.id === postId);
            if (post && post.replies) {
                post.replies = post.replies.filter(r => r.id !== replyId);
                
                const allFeedPost = allFeedPosts.find(p => p.id === postId);
                if (allFeedPost && allFeedPost.replies) {
                    allFeedPost.replies = allFeedPost.replies.filter(r => r.id !== replyId);
                }
                
                await saveChannelData();
                
                const replyEl = document.querySelector(`[data-reply-id="${replyId}"]`)?.closest('.reply-item');
                if (replyEl) {
                    replyEl.remove();
                    
                    const postEl = document.querySelector(`[data-post-id="${postId}"]`);
                    if (postEl) {
                        const collapseBtn = postEl.querySelector('.collapse-btn[data-post-id="' + postId + '"]');
                        if (collapseBtn) {
                            if (post.replies.length > 0) {
                                collapseBtn.textContent = `▼ Свернуть (${post.replies.length})`;
                            } else {
                                collapseBtn.remove();
                            }
                        }
                    }
                }
            }
        }
        
        async function deleteFeedPost(postId) {
            if (!confirm('Удалить это сообщение?')) {
                return;
            }
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    if (DEBUG_MODE) console.log('Post directory will be left in file system (not deletable via API)');
                }
            } catch (e) {
                console.error('Error deleting post directory:', e);
            }
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const postData = await readJSONFile(postDir, 'post.json', {});
                    
                    postData.deleted = true;
                    postData.deletedAt = Date.now();
                    
                    await writeJSONFile(postDir, 'post.json', postData);
                    if (DEBUG_MODE) console.log(`Marked post ${postId} as deleted in post.json`);
                }
            } catch (e) {
                console.error('Error marking post as deleted:', e);
            }
            
            const beforeCount = channelData.feed ? channelData.feed.length : 0;
            channelData.feed = channelData.feed.filter(post => post.id !== postId);
            const afterCount = channelData.feed ? channelData.feed.length : 0;
            if (DEBUG_MODE) console.log(`Deleted post ${postId}: ${beforeCount} -> ${afterCount} posts`);
            
            const beforeAllCount = allFeedPosts ? allFeedPosts.length : 0;
            allFeedPosts = allFeedPosts.filter(post => post.id !== postId);
            const afterAllCount = allFeedPosts ? allFeedPosts.length : 0;
            if (DEBUG_MODE) console.log(`Deleted from allFeedPosts: ${beforeAllCount} -> ${afterAllCount} posts`);
            
            await saveChannelMetadata();
            
            await renderFeed();
        }

        async function toggleLike(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            if (!post.likes) post.likes = 0;
            
            post.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleLike('${postId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = post.likes;
            }
            
            await savePostToDirectory(post);
        }
        
        async function toggleDislike(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            if (!post.dislikes) post.dislikes = 0;
            
            post.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleDislike('${postId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = post.dislikes;
            }
            
            await savePostToDirectory(post);
        }

        async function toggleReplyLike(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const reply = post.replies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.likes) reply.likes = 0;
            reply.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleReplyLike('${postId}', '${replyId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = reply.likes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function toggleReplyDislike(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const reply = post.replies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.dislikes) reply.dislikes = 0;
            reply.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleReplyDislike('${postId}', '${replyId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = reply.dislikes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }

        function findReplyAtAnyDepth(replies, replyId) {
            for (const reply of replies) {
                if (reply.id === replyId) {
                    return reply;
                }
                if (reply.nestedReplies && reply.nestedReplies.length > 0) {
                    const found = findReplyAtAnyDepth(reply.nestedReplies, replyId);
                    if (found) return found;
                }
            }
            return null;
        }

        async function toggleNestedReplyLike(postId, parentReplyId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const parentReply = findReplyAtAnyDepth(post.replies, parentReplyId);
            if (!parentReply || !parentReply.nestedReplies) return;
            
            const reply = parentReply.nestedReplies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.likes) reply.likes = 0;
            reply.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleNestedReplyLike('${postId}', '${parentReplyId}', '${replyId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = reply.likes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function toggleNestedReplyDislike(postId, parentReplyId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const parentReply = findReplyAtAnyDepth(post.replies, parentReplyId);
            if (!parentReply || !parentReply.nestedReplies) return;
            
            const reply = parentReply.nestedReplies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.dislikes) reply.dislikes = 0;
            reply.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleNestedReplyDislike('${postId}', '${parentReplyId}', '${replyId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = reply.dislikes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function createFeedPost(isAuthor = false) {
            const feedInput = document.getElementById('feedInput');
            const feedNick = document.getElementById('feedNick');
            
            if (!feedInput) return;
            
            const text = feedInput.innerHTML.trim();
            const nick = isAuthor ? currentChannelName : (feedNick ? feedNick.value.trim() : '');
            
            if (!text) {
                alert('Введите текст для публикации');
                return;
            }
            
            if (!isAuthor && !nick) {
                alert('Введите ваш ник');
                return;
            }
            
            const processedText = await processImagesInContent(text);
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            const images = tempDiv.querySelectorAll('img');
            const hasImages = images.length > 0;
            
            const post = {
                id: Date.now().toString(),
                author: nick,
                content: processedText,
                timestamp: Date.now(),
                likes: 0,
                dislikes: 0,
                replies: [],
                edited: false,
                editedAt: null,
                isAuthorPost: isAuthor,
                hasImages: hasImages
            };
            
            channelData.feed = channelData.feed || [];
            channelData.feed.push(post);
            
            channelData.feed.sort((a, b) => b.timestamp - a.timestamp);
            
            await savePostToDirectory(post);
            
            await saveChannelData();
            
            await renderFeed();
            
            feedInput.innerHTML = '';
            if (feedNick && !isAuthor) {
                feedNick.value = '';
            }
        }

        function clearOldLocalStorageData() {
            try {
                const keys = Object.keys(localStorage);
                const channelKeys = keys.filter(key => key.startsWith('channel_'));
                
                if (channelKeys.length > 10) {
                    console.log('Clearing old localStorage data...');
                    channelKeys.forEach(key => {
                        localStorage.removeItem(key);
                    });
                    console.log('Cleared', channelKeys.length, 'old channel entries');
                }
            } catch (e) {
                console.error('Error clearing localStorage:', e);
            }
        }

        async function saveChannelData() {
            const channelId = getChannelIdFromUrl();
            if (DEBUG_MODE) console.log('Saving channel data:', channelData);
            try {
                
                const minimalChannelData = {
                    name: channelData.name,
                    description: channelData.description,
                    avatar: channelData.avatar,
                    header: channelData.header,
                    background: channelData.background,
                    textColor: channelData.textColor,
                    theme: channelData.theme,
                    playlists: channelData.playlists || [],
                    stats: channelData.stats || { videos: 0, views: 0 },
                    created: channelData.created,
                    postIds: channelData.feed ? channelData.feed.map(post => post.id) : []
                };
                
                const dataString = JSON.stringify(minimalChannelData);
                const dataSize = new Blob([dataString]).size;
                if (DEBUG_MODE) console.log('Minimal channel data size:', dataSize, 'bytes');
                
                if (dataSize > 5 * 1024 * 1024) {
                    if (DEBUG_MODE) console.warn('Data too large for localStorage, saving only to file system');
                    clearOldLocalStorageData();
                } else {
                    localStorage.setItem(`channel_${channelId}`, dataString);
                    if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage');
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to file system');
                    } catch (e) {
                        console.error('Error saving to file system:', e);
                    }
                }
            } catch (e) {
                if (DEBUG_MODE) console.error('Error saving channel data:', e);
                if (e.name === 'QuotaExceededError') {
                    if (DEBUG_MODE) console.log('localStorage quota exceeded, clearing old data...');
                    clearOldLocalStorageData();
                    try {
                        localStorage.setItem(`channel_${channelId}`, JSON.stringify(minimalChannelData));
                        if (DEBUG_MODE) console.log('Saved to localStorage after clearing old data');
                    } catch (retryError) {
                        console.error('Still failed after clearing old data:', retryError);
                    }
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved to file system as fallback');
                    } catch (fileError) {
                        console.error('Error saving to file system as fallback:', fileError);
                    }
                }
            }
        }

        async function saveChannelMetadata() {
            const channelId = getChannelIdFromUrl();
            if (DEBUG_MODE) console.log('Saving channel metadata only');
            try {
                const minimalChannelData = {
                    name: channelData.name,
                    description: channelData.description,
                    avatar: channelData.avatar,
                    header: channelData.header,
                    background: channelData.background,
                    textColor: channelData.textColor,
                    theme: channelData.theme,
                    playlists: channelData.playlists || [],
                    stats: channelData.stats || { videos: 0, views: 0 },
                    created: channelData.created,
                    postIds: channelData.feed ? channelData.feed.map(post => post.id) : []
                };
                
                const dataString = JSON.stringify(minimalChannelData);
                const dataSize = new Blob([dataString]).size;
                if (DEBUG_MODE) console.log('Minimal channel data size:', dataSize, 'bytes');
                
                try {
                    localStorage.setItem(`channel_${channelId}`, dataString);
                    if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage');
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        if (DEBUG_MODE) console.log('localStorage quota exceeded, clearing old data');
                        await clearOldLocalStorageData();
                        localStorage.setItem(`channel_${channelId}`, dataString);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage after clearing');
                    } else {
                        throw e;
                    }
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to file system');
                    } catch (e) {
                        console.error('Error saving to file system:', e);
                    }
                }
            } catch (e) {
                console.error('Error saving channel metadata:', e);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            if (DEBUG_MODE) console.log('Channel page initialized');
            if (DEBUG_MODE) console.log('Current URL:', window.location.href);
            if (DEBUG_MODE) console.log('URL search params:', window.location.search);
            if (DEBUG_MODE) console.log('URL hash:', window.location.hash);

            if (DEBUG_MODE) console.log('Starting channel initialization...');
            await initializeChannelWithFileSystem();
            if (DEBUG_MODE) console.log('Channel initialization completed');

            setupTabs();

            setupChannelControls();

            setupEventListeners();

            setupEditorToolbars();

            setupEnterKeyHandling();

            setupVirtualScroll();

            setupImageLazyLoading();

            setupSorting();






            window.addEventListener('beforeunload', () => {
                clearImageCache();
            });

            setInterval(() => {
                if (imageOptimizationCache.size > MAX_CACHE_SIZE * 0.8) {
                    clearImageCache();
                }
            }, 300000);

        });
        
        function setupSorting() {
            setActiveSort('sortNew');

            const sortNew = document.getElementById('sortNew');
            const sortBest = document.getElementById('sortBest');
            const sortOld = document.getElementById('sortOld');
            const sortRandom = document.getElementById('sortRandom');
            const sortWorst = document.getElementById('sortWorst');

            if (sortNew) {
                sortNew.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortNew');
                    await sortFeed('new');
                });
            }

            if (sortBest) {
                sortBest.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortBest');
                    await sortFeed('best');
                });
            }

            if (sortOld) {
                sortOld.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortOld');
                    await sortFeed('old');
                });
            }

            if (sortRandom) {
                sortRandom.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortRandom');
                    await sortFeed('random');
                });
            }

            if (sortWorst) {
                sortWorst.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortWorst');
                    await sortFeed('worst');
                });
            }
            
        }

        function setActiveSort(activeId) {
            document.querySelectorAll('#sortNew, #sortBest, #sortOld, #sortRandom, #sortWorst').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.getElementById(activeId);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        async function sortFeed(sortType) {
            if (!channelData.feed) return;

            const isSinglePostView = !!singlePostId || (Array.isArray(channelData.feed) && channelData.feed.length === 1) || (Array.isArray(allFeedPosts) && allFeedPosts.length === 1);

            if (isSinglePostView) {
                const post = Array.isArray(channelData.feed) && channelData.feed.length > 0 ? channelData.feed[0] : null;
                if (post && Array.isArray(post.replies)) {
                    const replies = post.replies.slice();
                    switch (sortType) {
                        case 'new':
                            replies.sort((a, b) => (b.created || 0) - (a.created || 0));
                            break;
                        case 'old':
                            replies.sort((a, b) => (a.created || 0) - (b.created || 0));
                            break;
                        case 'best':
                            replies.sort((a, b) => (b.likes || 0) - (a.likes || 0));
                            break;
                        case 'worst':
                            replies.sort((a, b) => (b.dislikes || 0) - (a.dislikes || 0));
                            break;
                        case 'random':
                            replies.sort(() => Math.random() - 0.5);
                            break;
                        default:
                            replies.sort((a, b) => (b.created || 0) - (a.created || 0));
                    }
                    post.replies = replies;
                    await rerenderFirstLevelReplies(post);
                    return;
                }
            }

            let sortedPosts = [...channelData.feed];
            
            switch (sortType) {
                case 'new':
                    sortedPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    break;
                case 'old':
                    sortedPosts.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                    break;
                case 'best':
                    sortedPosts.sort((a, b) => {
                        const aLikes = a.likes || 0;
                        const bLikes = b.likes || 0;
                        return bLikes - aLikes;
                    });
                    break;
                case 'worst':
                    sortedPosts.sort((a, b) => {
                        const aDislikes = a.dislikes || 0;
                        const bDislikes = b.dislikes || 0;
                        return bDislikes - aDislikes;
                    });
                    break;
                case 'random':
                    sortedPosts.sort(() => Math.random() - 0.5);
                    break;
                case 'replies':
                    sortedPosts.sort((a, b) => {
                        const aCount = Array.isArray(a.replies) ? a.replies.length : 0;
                        const bCount = Array.isArray(b.replies) ? b.replies.length : 0;
                        if (bCount !== aCount) return bCount - aCount;
                        return (b.timestamp || 0) - (a.timestamp || 0);
                    });
                    break;
                default:
                    sortedPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            }
            
            await renderFeedWithPosts(sortedPosts);
        }

        async function renderFeedWithPosts(posts) {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;
            
            feedSection.innerHTML = '';
            
            if (posts.length === 0) {
                feedSection.innerHTML = '<div style="text-align:center;color:#666;padding:40px;">Нет постов для отображения</div>';
                return;
            }
            
            for (const post of posts) {
                const postElement = await createFeedItem(post);
                feedSection.appendChild(postElement);
                
                processImagesInPostContent(postElement);
                await applyChannelAvatarsForReplies(postElement);
            }
            
            setTimeout(() => {
                setupImageLazyLoading();
                setTimeout(() => forceLoadAllImages(), 2000);
            }, 100);
            
            setupEventListeners();
        }


        async function rerenderFirstLevelReplies(post) {
            try {
                const postElement = document.querySelector(`.feed-comment[data-post-id="${post.id}"]`);
                if (!postElement) return;
                const repliesContainer = postElement.querySelector('.replies-container');
                if (!repliesContainer) return;

                const repliesHtml = (post.replies || []).slice().map(reply => {
                    const replyIsChannel = reply.isAuthorPost || /\((ка|ka)\)\s*$/i.test(reply.nick);
                    const replyNickColor = replyIsChannel ? '#d94b88' : getNickColor(reply.nick);
                    return `
                    <div class="reply-item">
                        <div class="reply-avatar" data-reply-id="${reply.id}" style="background-color: ${replyNickColor}">
                            ${reply.isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(reply.nick).charAt(0).toUpperCase()}
                        </div>
                        <div class="reply-bubble">
                            <div class="reply-header">
                                <span class="reply-nick ${replyIsChannel ? 'channel-nick' : ''}" data-original-nick="${escapeHtml(reply.nick)}">${escapeHtml(reply.isAuthorPost ? currentChannelName : reply.nick.replace(/\((ка|ka)\)\s*$/i,'').trim())}</span>
                                ${reply.isAuthorPost ? '<span class="author-badge">Автор</span>' : ''}
                                <span class="reply-date">${new Date(reply.created).toLocaleString('ru-RU', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'})}</span>
                            </div>
                            <div class="reply-text">${processContentWithImages(reply.text)}</div>
                            <div class="reply-actions">
                                <button onclick="toggleReplyLike('${post.id}', '${reply.id}')" class="like-btn" title="Лайк">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${reply.likes || 0}</span>
                                </button>
                                <button onclick="toggleReplyDislike('${post.id}', '${reply.id}')" class="dislike-btn" title="Дизлайк">
                                    <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${reply.dislikes || 0}</span>
                                </button>
                                <button onclick="toggleReplyToReply('${post.id}', '${reply.id}')" class="reply-to-reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                                ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `<button onclick="toggleNestedRepliesVisibility('${post.id}', '${reply.id}')" class="collapse-btn" title="${collapseTitle}" data-post-id="${post.id}" data-reply-id="${reply.id}">▼ ${i18n.t('feed.collapse', 'Свернуть')} (${reply.nestedReplies.length})</button>` : ''}
                                <button onclick="deleteReply('${post.id}', '${reply.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                            </div>
                            <div class="nested-reply-form" id="nestedReplyForm_${post.id}_${reply.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                <div class="compact-editor-toolbar">
                                    <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                    <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                    <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>
                                    <button data-cmd="insertUnorderedList" title="${listTitle}">•</button>
                                    <button data-cmd="insertOrderedList" title="${numberedListTitle}">1.</button>
                                    <button class="create-nested-link-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${linkTitle}">🔗</button>
                                    <button class="insert-nested-image-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${imageTitle}">img</button>
                                    <button class="close-nested-reply-btn" data-post-id="${post.id}" data-reply-id="${reply.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                    <input type="file" class="nested-image-file-input" data-post-id="${post.id}" data-reply-id="${reply.id}" accept="image/*" style="display:none" multiple>
                                </div>
                                <div id="nestedReplyInput_${post.id}_${reply.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                    <input type="text" class="reply-nick-input" id="nestedReplyNick_${post.id}_${reply.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border-radius:4px;font-size:11px;height:26px;">
                                    <div style="display:flex;gap:6px;">
                                        <button onclick="postAuthorNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                        <button onclick="postNestedReply('${post.id}', '${reply.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                    </div>
                                </div>
                            </div>
                            ${reply.nestedReplies && reply.nestedReplies.length > 0 ? `
                                <div class="nested-replies">
                                    ${renderNestedReplies(reply.nestedReplies, post.id, reply.id, 1)}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `}).join('');

                repliesContainer.innerHTML = repliesHtml;

                repliesContainer.querySelectorAll('.reply-item').forEach(el => processImagesInPostContent(el));

                if (post.replies && post.replies.length > 0 && channelData && channelData.avatar) {
                    try {
                        const channelDir = await getChannelDirectory();
                        const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                        if (avatarUrl) {
                            for (const reply of post.replies) {
                                if (reply.isAuthorPost) {
                                    const replyAvatarEl = repliesContainer.querySelector(`[data-reply-id="${reply.id}"]`);
                                    if (replyAvatarEl) {
                                        replyAvatarEl.style.backgroundImage = `url(${avatarUrl})`;
                                        replyAvatarEl.classList.add('custom-avatar');
                                        replyAvatarEl.textContent = '';
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error reapplying author avatars after sort:', e);
                    }
                }

                await applyChannelAvatarsForReplies(repliesContainer);

                if (post.replies && post.replies.length > 0) {
                    for (const reply of post.replies) {
                        if (reply.nestedReplies && reply.nestedReplies.length > 0) {
                            await loadNestedRepliesAvatars(reply.nestedReplies, post.id, reply.id, 1);
                        }
                    }
                }

                setupImageLazyLoading();
                setTimeout(() => forceLoadVisibleImages(), 300);
            } catch (e) {
                console.error('Error re-rendering replies:', e);
            }
        }


        
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const targetContent = document.getElementById(targetTab + 'Tab');
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });
        }
        
        function setupChannelControls() {
            const controlBtns = document.querySelectorAll('.control-btn');
            controlBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.id;
                    console.log('Channel control clicked:', action);
                });
            });
        }

        async function setupSubscriptionButton() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (!subscribeBtn || !currentChannelName) return;

            try {
                let subscriptions = await loadSubscriptionsFromFile();
                let db = null;
                
                if (!subscriptions) {
                    db = await openDB();
                    subscriptions = await getFromDB(db, 'subscriptions') || [];
                }
                
                if (!Array.isArray(subscriptions)) {
                    subscriptions = [];
                }
                
                const isSubscribed = subscriptions.includes(currentChannelName);
                if (DEBUG_MODE) console.log('Current channel:', currentChannelName, 'Is subscribed:', isSubscribed);

                if (isSubscribed) {
                    subscribeBtn.textContent = i18n.t('channels.subscribed', 'Подписан');
                    subscribeBtn.classList.add('subscribed');
                } else {
                    subscribeBtn.textContent = i18n.t('channels.subscribe', 'Подписаться');
                    subscribeBtn.classList.remove('subscribed');
                }

                let currentSubscriptionState = isSubscribed;

                subscribeBtn.addEventListener('click', async () => {
                    try {
                        console.log('Subscription button clicked. Current state:', currentSubscriptionState);
                        
                        if (!db) {
                            console.log('Creating new database connection...');
                            db = await openDB();
                        }
                        
                        if (!subscriptions || !Array.isArray(subscriptions)) {
                            subscriptions = await loadSubscriptionsFromFile() || [];
                            if (!Array.isArray(subscriptions)) {
                                subscriptions = [];
                            }
                        }
                        
                        if (currentSubscriptionState) {
                            console.log('Unsubscribing from channel:', currentChannelName);
                            const index = subscriptions.indexOf(currentChannelName);
                            if (index > -1) {
                                subscriptions.splice(index, 1);
                                console.log('Updated subscriptions list after unsubscribe:', subscriptions);
                                
                                await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);
                                
                                subscribeBtn.textContent = i18n.t('channels.subscribe', 'Подписаться');
                                subscribeBtn.classList.remove('subscribed');
                                currentSubscriptionState = false;

                                await renderSubscribedChannelsList();

                                const verification = localStorage.getItem('8site_subscriptions');
                                console.log('Verification - localStorage after unsubscribe:', verification);
                            }
                        } else {
                            console.log('Subscribing to channel:', currentChannelName);
                            if (!subscriptions.includes(currentChannelName)) {
                                subscriptions.push(currentChannelName);
                            }
                            console.log('Updated subscriptions list after subscribe:', subscriptions);
                            
                            await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);
                            
                            subscribeBtn.textContent = i18n.t('channels.subscribed', 'Подписан');
                            subscribeBtn.classList.add('subscribed');
                            currentSubscriptionState = true;

                            await renderSubscribedChannelsList();

                            const verification = localStorage.getItem('8site_subscriptions');
                            console.log('Verification - localStorage after subscribe:', verification);
                        }
                    } catch (e) {
                        console.error('Error updating subscription:', e);
                    }
                });
            } catch (e) {
                console.error('Error setting up subscription button:', e);
                subscribeBtn.textContent = i18n.t('channels.subscribe', 'Подписаться');
                subscribeBtn.classList.remove('subscribed');
            }
        }
        
        function initializeChannel() {
            loadChannelData();
            
            document.getElementById('channelName').textContent = currentChannelName;
            document.getElementById('channelAvatar').textContent = currentChannelName.charAt(0).toUpperCase();
            
            const stats = channelData.stats || { videos: 0, views: 0 };
            document.getElementById('channelStats').textContent = i18n.t('channelFeed.stats', '{videos} видео • {views} просмотров').replace('{videos}', stats.videos).replace('{views}', stats.views.toLocaleString());
            
            document.title = `${currentChannelName} | Youvi`;
        }

        
        async function loadAllVideosAndPlaylistsForAutocomplete() {
          if (typeof AutocompleteDataLoader === 'undefined') {
            console.error('[Autocomplete] AutocompleteDataLoader module not loaded');
            return { videos: [], playlists: [] };
          }
          
          const result = await AutocompleteDataLoader.loadData();
          return { videos: result.videos || [], playlists: result.playlists || [] };
        }

        async function initializeChannelWithFileSystem() {
            currentChannelName = getUrlParam('channel');
            if (!currentChannelName) {
                const hash = window.location.hash.substring(1);
                if (hash) {
                    currentChannelName = hash;
                }
            }

            try {
                if (DEBUG_MODE) console.log('Opening IndexedDB...');
                const db = await openDB();
                if (DEBUG_MODE) console.log('IndexedDB opened:', db);
                
                const savedHandle = await getFromDB(db, 'videoDirectoryHandle');
                if (DEBUG_MODE) console.log('Saved video directory handle:', savedHandle);
                
                if (savedHandle) {
                    if (DEBUG_MODE) console.log('Checking permission for saved handle...');
                    const permission = await savedHandle.queryPermission();
                    if (DEBUG_MODE) console.log('Permission status:', permission);
                    
                                            if (permission === 'granted' || (permission === 'prompt' && await savedHandle.requestPermission() === 'granted')) {
                            if (DEBUG_MODE) console.log('Permission granted, setting video directory handle');
                            videoDirectoryHandle = savedHandle;
                            await loadChannelData();
                            await setupSubscriptionButton();
                            await syncSubscriptions();
                            await renderSubscribedChannelsList();
                            
                            try {
                              const searchInput = document.getElementById('headerSearchInput');
                              if (searchInput && typeof AutocompleteIntegration !== 'undefined' && typeof YouviAutocomplete !== 'undefined') {
                                const { videos, playlists } = await loadAllVideosAndPlaylistsForAutocomplete();
                                
                                const cacheValid = await window.autocompleteCache.isCacheValid(
                                  videos.length,
                                  playlists.length
                                );
                                
                                const autocompleteIntegration = new AutocompleteIntegration();
                                await autocompleteIntegration.init(searchInput, {
                                  videoDirectoryHandle: videoDirectoryHandle,
                                  allVideos: cacheValid ? [] : videos,
                                  allPlaylists: cacheValid ? [] : playlists
                                });
                                console.log('[Autocomplete] ✅ Initialized on youvi_ch_feed_rep.html');
                              }
                            } catch (error) {
                              console.error('[Autocomplete] Failed to initialize:', error);
                            }
                            
                            const urlPostId = getUrlParam('post_id');
                            const urlReplyId = getUrlParam('reply_id');
                            if (urlPostId) {
                                singlePostId = urlPostId;
                                if (urlReplyId) singleReplyId = urlReplyId;
                            }
                            await renderChannel();
                            
                            const postId = getUrlParam('post_id');
                            if (!postId) {
                                const hash = window.location.hash;
                                if (hash && hash.startsWith('#post_')) {
                                    const hashPostId = hash.substring(6);
                                    console.log('Post ID found in hash, scrolling to post:', hashPostId);
                                    setTimeout(async () => {
                                        await scrollToPost(hashPostId);
                                    }, 1000);
                                }
                            }
                        } else {
                            console.log('Permission denied');
                            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>Нет доступа к папке с видео</strong></div>';
                        }
                } else {
                    console.log('No saved video directory handle found');
                    document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>Сначала выберите папку с видео на главной странице</strong></div>';
                }
            } catch (e) {
                console.error('Error accessing directory:', e);
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red"><strong>Ошибка доступа к файловой системе</strong></div>';
            }
        }

        async function renderChannel() {
            if (DEBUG_MODE) console.log('Rendering channel:', currentChannelName);
            if (DEBUG_MODE) console.log('Channel data:', channelData);
            
            if (!channelData) {
                if (DEBUG_MODE) console.log('Channel data not loaded, waiting...');
                await loadChannelData();
            }
            
            document.getElementById('channelName').textContent = currentChannelName;
            document.getElementById('channelAvatar').textContent = currentChannelName.charAt(0).toUpperCase();
            document.title = `${currentChannelName} | Youvi`;

            const nameEl = document.getElementById('channelName');
            if (nameEl) {
                nameEl.className = `channel-name ${channelData.textColor === 'black' ? 'dark-text' : ''}`;
            }

            const channelDir = await getChannelDirectory();
            
            if (channelData && channelData.avatar) {
                const avatarEl = document.getElementById('channelAvatar');
                loadLazyImageFile(channelDir, channelData.avatar, avatarEl, 'custom-avatar')
                    .then(() => { avatarEl.textContent = ''; })
                    .catch(() => { avatarEl.textContent = currentChannelName.charAt(0).toUpperCase(); });
            }

            if (channelData && channelData.header) {
                const headerEl = document.getElementById('channelHeader');
                loadImageFile(channelDir, channelData.header)
                    .then(url => {
                        if (url) {
                            headerEl.style.backgroundImage = `url(${url})`;
                            headerEl.classList.add('custom-bg');
                        }
                    })
                    .catch(() => {});
            }

            if (channelData.background) {
                loadImageFile(channelDir, channelData.background)
                    .then(url => {
                        if (url) {
                            document.body.style.setProperty('--bg-image', `url(${url})`);
                            document.body.classList.add('custom-background');
                        }
                    })
                    .catch(() => {
                        document.body.classList.remove('custom-background');
                        document.body.style.removeProperty('--bg-image');
                    });
            }
            loadChannelVideos().catch(e => console.error('Error loading videos:', e));

            await renderFeed();
        }

        function setupEventListeners() {
            const postFeed = document.getElementById('postFeed');
            if (postFeed) {
                postFeed.addEventListener('click', async () => {
                    await createFeedPost(false);
                });
            }
            
            document.addEventListener('click', (e) => {
                if (e.target.matches('[data-tab]')) {
                    e.preventDefault();
                    const tab = e.target.dataset.tab;
                    let url;
                    if (tab === 'feed') {
                        url = `youvi_ch_feed.html?channel=${encodeURIComponent(currentChannelName)}`;
                    } else {
                        url = `youvi_ch_view.html?channel=${encodeURIComponent(currentChannelName)}&tab=${tab}`;
                    }
                    window.location.href = url;
                }
            });
            
            const authorPostBtn = document.getElementById('authorPostBtn');
            if (authorPostBtn) {
                authorPostBtn.addEventListener('click', async () => {
                    const text = document.getElementById('feedInput').innerHTML.trim();
                    
                    if (!text) {
                        alert('Введите текст для публикации');
                        return;
                    }
                    
                    await createFeedPost(true);
                    
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position:fixed;top:15px;right:15px;background:#4caf50;color:white;padding:10px 15px;border-radius:6px;z-index:1000;animation:slideIn 0.3s ease-out;';
                    successMsg.textContent = 'Пост опубликован от имени канала!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.style.animation = 'slideOut 0.3s ease-in';
                        setTimeout(() => successMsg.remove(), 300);
                    }, 2000);
                });
            }
            
            const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', async () => {
                    await loadMoreFeedPosts();
                });
            }
            
             document.addEventListener('click', (e) => {
                 if (e.target.classList.contains('close-reply-btn')) {
                     const postId = e.target.dataset.postId;
                     const replyForm = document.getElementById(`replyForm_${postId}`);
                     if (replyForm) {
                         replyForm.style.display = 'none';
                     }
                 }
                 
                 if (e.target.classList.contains('close-nested-reply-btn')) {
                     const postId = e.target.dataset.postId;
                     const replyId = e.target.dataset.replyId;
                     const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
                     if (nestedReplyForm) {
                         nestedReplyForm.style.display = 'none';
                     }
                 }
             });

            window.addEventListener('subscriptionChanged', async function() {
                await setupSubscriptionButton();
                await renderSubscribedChannelsList();
            });

            window.addEventListener('storage', async function(e) {
                if (e.key === '8site_subscriptions') {
                    await setupSubscriptionButton();
                }
            });
        }
        
        function setupEditorToolbars() {
            document.addEventListener('input', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === 'Текст для форматирования') {
                        const toolbar = editor.previousElementSibling;
                        if (toolbar && toolbar.classList.contains('compact-editor-toolbar')) {
                            toolbar.querySelectorAll('button[data-cmd]').forEach(btn => {
                                btn.classList.remove('active');
                            });
                        }
                    }
                }
            });
            
            document.addEventListener('focusin', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === 'Текст для форматирования') {
                        editor.textContent = 'Текст для форматирования';
                        editor.style.color = '#999';
                    }
                }
            });
            
            document.addEventListener('keydown', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === 'Текст для форматирования' && ev.key.length === 1) {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('focusout', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === 'Текст для форматирования') {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('click', (ev) => {
                if (ev.target.matches('#feedInput + .compact-editor-toolbar button[data-cmd]')) {
                    ev.preventDefault();
                    const button = ev.target;
                    const editor = document.getElementById('feedInput');
                    
                    if (editor) {
                        editor.focus();
                        
                        const selection = document.getSelection();
                        if (selection.rangeCount === 0 || selection.isCollapsed) {
                            const range = selection.getRangeAt(0);
                            const placeholder = document.createTextNode('Текст для форматирования');
                            range.insertNode(placeholder);
                            range.selectNodeContents(placeholder);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        
                        const command = button.dataset.cmd;
                        const value = button.dataset.value;
                        
                        if (command === 'formatBlock' && value) {
                            document.execCommand(command, false, value);
                        } else {
                            document.execCommand(command, false, null);
                        }
                        
                        editor.focus();
                    }
                }
            });
            
            document.addEventListener('focusin', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    if (editor.textContent === 'Текст для форматирования') {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('focusout', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    if (editor.textContent.trim() === '') {
                        editor.textContent = 'Текст для форматирования';
                        editor.style.color = '#999';
                    }
                }
            });
            
            document.addEventListener('click', (ev) => {
                if (ev.target.matches('.compact-editor-toolbar button[data-cmd]')) {
                    ev.preventDefault();
                    const button = ev.target;
                    const editor = button.closest('.compact-editor-toolbar').nextElementSibling;
                    
                    if (editor && editor.classList.contains('compact-editor')) {
                        const cmd = button.dataset.cmd;
                        
                        editor.focus();
                        
                        if (['bold', 'italic', 'underline'].includes(cmd)) {
                            const selection = document.getSelection();
                            
                            document.execCommand(cmd, false, null);
                            
                            setTimeout(() => {
                                button.classList.toggle('active', document.queryCommandState(cmd));
                            }, 10);
                            return;
                        }
                        
                        const selection = document.getSelection();
                        if (selection.rangeCount === 0 || selection.isCollapsed) {
                            const range = selection.getRangeAt(0);
                            const placeholder = document.createTextNode('Текст для форматирования');
                            range.insertNode(placeholder);
                            range.selectNodeContents(placeholder);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        
                        if (cmd === 'insertUnorderedList') {
                            const range = selection.getRangeAt(0);
                            const list = document.createElement('ul');
                            const li = document.createElement('li');
                            li.appendChild(range.extractContents());
                            list.appendChild(li);
                            range.insertNode(list);
                            
                            const newRange = document.createRange();
                            newRange.setStart(li, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                        } else if (cmd === 'insertOrderedList') {
                            const range = selection.getRangeAt(0);
                            const list = document.createElement('ol');
                            const li = document.createElement('li');
                            li.appendChild(range.extractContents());
                            list.appendChild(li);
                            range.insertNode(list);
                            
                            const newRange = document.createRange();
                            newRange.setStart(li, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                        } else if (cmd === 'removeList') {
                            const range = selection.getRangeAt(0);
                            const listItem = range.commonAncestorContainer.closest('li');
                            if (listItem) {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const textContent = listItem.textContent;
                                    const textNode = document.createTextNode(textContent);
                                    listItem.parentNode.replaceChild(textNode, listItem);
                                    
                                    if (list.children.length === 0) {
                                        list.remove();
                                    }
                                }
                            }
                        } else if (cmd === 'formatBlock') {
                            const range = selection.getRangeAt(0);
                            const block = document.createElement(button.dataset.value);
                            block.appendChild(range.extractContents());
                            range.insertNode(block);
                        }
                        
                        editor.focus();
                    }
                }
            });
            
            document.addEventListener('mouseup', updateButtonStates);
            document.addEventListener('keyup', updateButtonStates);
            document.addEventListener('input', updateButtonStates);
            document.addEventListener('selectionchange', updateButtonStates);
            
            document.addEventListener('keydown', (ev) => {
                if (ev.target.classList.contains('compact-editor') && ev.key === 'Enter') {
                    const selection = document.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const listItem = range.commonAncestorContainer.closest('li');
                        
                        if (listItem) {
                            ev.preventDefault();
                            
                            if (listItem.textContent.trim() === '') {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const textNode = document.createTextNode('\n');
                                    list.parentNode.insertBefore(textNode, list.nextSibling);
                                    list.remove();
                                    
                                    const newRange = document.createRange();
                                    newRange.setStartAfter(textNode);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            } else {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const newLi = document.createElement('li');
                                    newLi.textContent = '';
                                    list.appendChild(newLi);
                                    
                                    const newRange = document.createRange();
                                    newRange.setStart(newLi, 0);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            }
                        }
                    }
                }
            });
            
            function updateButtonStates() {
                const activeEditor = document.activeElement;
                if (!activeEditor || !activeEditor.classList.contains('compact-editor')) return;
                
                const toolbar = activeEditor.previousElementSibling;
                if (!toolbar || !toolbar.classList.contains('compact-editor-toolbar')) return;
                
                const boldBtn = toolbar.querySelector('[data-cmd="bold"]');
                const italicBtn = toolbar.querySelector('[data-cmd="italic"]');
                const underlineBtn = toolbar.querySelector('[data-cmd="underline"]');
                
                if (boldBtn) {
                    const isBold = document.queryCommandState('bold');
                    boldBtn.classList.toggle('active', isBold);
                }
                if (italicBtn) {
                    const isItalic = document.queryCommandState('italic');
                    italicBtn.classList.toggle('active', isItalic);
                }
                if (underlineBtn) {
                    const isUnderline = document.queryCommandState('underline');
                    underlineBtn.classList.toggle('active', isUnderline);
                }
            }
            
                 document.addEventListener('click', (ev) => {
                     if (ev.target.classList.contains('create-link-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const url = prompt('Введите URL ссылки:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.classList.contains('insert-image-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const imageInput = document.querySelector(`.image-file-input[data-post-id="${postId}"]`);
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.classList.contains('center-image-btn')) {
                         ev.preventDefault();
                         document.execCommand('justifyCenter', false, null);
                     }
                     
                     if (ev.target.classList.contains('create-nested-link-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const url = prompt('Введите URL ссылки:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.classList.contains('insert-nested-image-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const imageInput = document.querySelector(`.nested-image-file-input[data-post-id="${postId}"][data-reply-id="${replyId}"]`);
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.id === 'createLinkBtnFeed') {
                         ev.preventDefault();
                         const url = prompt('Введите URL ссылки:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.id === 'insertImageBtnFeed') {
                         ev.preventDefault();
                         const imageInput = document.getElementById('imageFileInputFeed');
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.id === 'centerImageBtnFeed') {
                         ev.preventDefault();
                         document.execCommand('justifyCenter', false, null);
                     }
                 });
            
                 document.addEventListener('change', (ev) => {
                     if (ev.target.classList.contains('image-file-input')) {
                         const files = ev.target.files;
                         const postId = ev.target.dataset.postId;
                         const editor = document.getElementById(`replyInput_${postId}`);
                         
                         if (files && editor) {
                             Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     const fileName = await saveOriginalImageFile(file, postId);
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'reply-image');
                                         if (fileName && typeof fileName === 'string' && !fileName.startsWith('data:')) {
                                             img.setAttribute('data-filename', fileName);
                                             img.onclick = () => openImageModal(e.target.result, fileName);
                                         } else {
                                         img.onclick = () => openImageModal(e.target.result);
                                         }
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                     
                     if (ev.target.classList.contains('nested-image-file-input')) {
                         const files = ev.target.files;
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const editor = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                         
                         if (files && editor) {
                             Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     const fileName = await saveOriginalImageFile(file, postId, replyId);
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'nested-reply-image');
                                         if (fileName && typeof fileName === 'string' && !fileName.startsWith('data:')) {
                                             img.setAttribute('data-filename', fileName);
                                             img.onclick = () => openImageModal(e.target.result, fileName);
                                         } else {
                                         img.onclick = () => openImageModal(e.target.result);
                                         }
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                     
                     if (ev.target.id === 'imageFileInputFeed') {
                         const files = ev.target.files;
                         const editor = document.getElementById('feedInput');
                         
                         if (files && editor) {
                            Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'comment-image');
                                        img.setAttribute('data-original-file', 'true');
                                         img.onclick = () => openImageModal(e.target.result);
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                 });
        }
        
        function setupEnterKeyHandling() {
            const feedInput = document.getElementById('feedInput');
            if (feedInput) {
                feedInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertParagraph', false, null);
                    } else if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        const postFeedBtn = document.getElementById('postFeed');
                        if (postFeedBtn) {
                            postFeedBtn.click();
                        }
                    }
                });
            }
            
             document.addEventListener('keydown', (e) => {
                 if (e.target.classList.contains('compact-editor') && e.target.id && e.target.id.startsWith('replyInput_')) {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         document.execCommand('insertParagraph', false, null);
                     } else if (e.key === 'Enter' && e.ctrlKey) {
                         e.preventDefault();
                         const postId = e.target.id.replace('replyInput_', '');
                         postReply(postId);
                     }
                 }
                 
                 if (e.target.classList.contains('compact-editor') && e.target.id && e.target.id.startsWith('nestedReplyInput_')) {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         document.execCommand('insertParagraph', false, null);
                     } else if (e.key === 'Enter' && e.ctrlKey) {
                         e.preventDefault();
                         const idParts = e.target.id.replace('nestedReplyInput_', '').split('_');
                         if (idParts.length === 2) {
                             const postId = idParts[0];
                             const replyId = idParts[1];
                             postNestedReply(postId, replyId);
                         }
                     }
                 }
             });
        }

        function searchByTag(tag) {
            console.log('Searching by tag:', tag);
        }

        function goToChannelFeed(channelName) {
            try {
                if (!channelName) return;
                const clean = channelName.replace(/\((ка|ka)\)\s*$/i,'').trim();
                const url = `youvi_ch_feed.html?channel=${encodeURIComponent(clean)}`;
                window.location.href = url;
            } catch (e) {
                console.error('goToChannelFeed error', e);
            }
        }

        async function loadSubscriptionsFromFile() {
            try {
                const localSubscriptions = localStorage.getItem('8site_subscriptions');
                if (localSubscriptions && localSubscriptions !== 'null' && localSubscriptions !== 'undefined') {
                    const parsed = JSON.parse(localSubscriptions);
                    if (Array.isArray(parsed)) {
                        return parsed;
                    }
                }

                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
                        const file = await subscriptionsFile.getFile();
                        const text = await file.text();
                        const fileSubscriptions = JSON.parse(text);

                        if (Array.isArray(fileSubscriptions)) {
                            localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
                            return fileSubscriptions;
                        }
                    } catch (fileError) {
                        console.log('Could not load from file:', fileError.message);
                    }
                }

                return [];
            } catch (e) {
                console.error('Error loading subscriptions:', e);
                return [];
            }
        }

        async function loadChannelAvatar(channelName) {
            const cacheKey = `avatar_${channelName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
                if (cached.url && cached.url.startsWith('blob:')) {
                    URL.revokeObjectURL(cached.url);
                }
                avatarCache.delete(cacheKey);
            }

            try {
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                const channelDir = await channelsDir.getDirectoryHandle(channelName, { create: true });

                const channelData = await readJSONFile(channelDir, 'channel.json', {});
                let avatarUrl = null;

                if (channelData.avatar) {
                    avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                }

                avatarCache.set(cacheKey, {
                    url: avatarUrl,
                    timestamp: Date.now()
                });

                return avatarUrl;
            } catch (e) {
                avatarCache.set(cacheKey, {
                    url: null,
                    timestamp: Date.now()
                });
                return null;
            }
        }

        async function renderSubscribedChannelsList() {
            const container = document.getElementById('subscribedChannelsContainer');
            if (!container) return;

            try {
                const subscriptions = await loadSubscriptionsFromFile();

                if (!subscriptions || subscriptions.length === 0) {
                    container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">Нет подписок</div>';
                    return;
                }

                container.innerHTML = '';

                for (const channelName of subscriptions.slice(0, 10)) {
                    const link = document.createElement('a');
                    link.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
                    link.className = 'sidebar-item';
                    link.style.display = 'flex';
                    link.style.alignItems = 'center';
                    link.style.gap = '8px';
                    link.style.cursor = 'pointer';
                    link.style.paddingTop = '6px';
                    link.style.paddingBottom = '6px';

                    const avatarDiv = document.createElement('div');
                    avatarDiv.style.width = '20px';
                    avatarDiv.style.height = '20px';
                    avatarDiv.style.borderRadius = '0';
                    avatarDiv.style.background = '#ff69b4';
                    avatarDiv.style.display = 'flex';
                    avatarDiv.style.alignItems = 'center';
                    avatarDiv.style.justifyContent = 'center';
                    avatarDiv.style.fontSize = '10px';
                    avatarDiv.style.color = 'white';
                    avatarDiv.style.fontWeight = 'bold';
                    avatarDiv.style.flexShrink = '0';
                    avatarDiv.textContent = channelName.charAt(0).toUpperCase();

                    const nameSpan = document.createElement('span');
                    nameSpan.style.flex = '1';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    nameSpan.textContent = channelName;

                    link.appendChild(avatarDiv);
                    link.appendChild(nameSpan);
                    container.appendChild(link);

                    loadChannelAvatar(channelName).then(avatarUrl => {
                        if (avatarUrl) {
                            avatarDiv.style.backgroundImage = `url(${avatarUrl})`;
                            avatarDiv.style.backgroundSize = 'cover';
                            avatarDiv.style.backgroundPosition = 'center';
                            avatarDiv.style.backgroundRepeat = 'no-repeat';
                            avatarDiv.textContent = '';
                        }
                    }).catch(() => {
                    });
                }

                if (subscriptions.length > 10) {
                    const moreLink = document.createElement('a');
                    moreLink.href = 'youvi_subscriptions.html';
                    moreLink.className = 'sidebar-item';
                    moreLink.style.fontSize = '11px';
                    moreLink.style.color = '#666';
                    moreLink.style.textAlign = 'center';
                    moreLink.textContent = `+${subscriptions.length - 10} еще`;
                    container.appendChild(moreLink);
                }
            } catch (e) {
                console.error('Error rendering subscriptions:', e);
                container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">Ошибка загрузки</div>';
            }
        }

        async function saveSubscriptionsToFile(subscriptions) {
            try {
                localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));

                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json', { create: true });
                        const writable = await subscriptionsFile.createWritable();
                        await writable.write(JSON.stringify(subscriptions, null, 2));
                        await writable.close();
                    } catch (fileError) {
                        console.warn('Could not save to file, but localStorage saved:', fileError);
                    }
                } else {
                    console.log('No videoDirectoryHandle, using localStorage only');
                }

                window.dispatchEvent(new CustomEvent('subscriptionChanged'));
            } catch (e) {
                console.error('Error saving subscriptions:', e);
                try {
                    localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));
                } catch (storageError) {
                    console.error('Critical: Could not save subscriptions anywhere!', storageError);
                }
            }
        }

        async function saveToDB(db, storeName, key, value) {
            try {
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
                
                if (db && db.objectStoreNames.contains(storeName)) {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.put(value, key);
                    if (DEBUG_MODE) console.log('Saved to IndexedDB successfully');
                } else {
                    if (DEBUG_MODE) console.warn(`IndexedDB store '${storeName}' does not exist, but data saved to localStorage`);
                }
            } catch (e) {
                if (DEBUG_MODE) console.error('Error saving to IndexedDB:', e);
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
            }
        }

        async function syncSubscriptions() {
            try {
                const db = await openDB();
                const fileSubscriptions = await loadSubscriptionsFromFile();
                const dbSubscriptions = await getFromDB(db, 'subscriptions');
                
                if (fileSubscriptions && !dbSubscriptions) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
                else if (dbSubscriptions && !fileSubscriptions) {
                    await saveSubscriptionsToFile(dbSubscriptions);
                }
                else if (fileSubscriptions && dbSubscriptions && 
                         JSON.stringify(fileSubscriptions) !== JSON.stringify(dbSubscriptions)) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
            } catch (e) {
                console.error('Error syncing subscriptions:', e);
            }
        }

        (function initLangSwitcher() {
            const langSwitcher = document.getElementById('langSwitcher');
            if (!langSwitcher) return;
            
            langSwitcher.value = i18n.getCurrentLanguage();
            
            langSwitcher.addEventListener('change', async (e) => {
                const newLang = e.target.value;
                await i18n.setLanguage(newLang);
                await loadChannelVideos();
                updateSubscribeButtonText();
                renderFeed();
            });
            
            i18n.subscribe(async (lang) => {
                langSwitcher.value = lang;
                await loadChannelVideos();
                updateSubscribeButtonText();
                renderFeed();
            });
        })();
        
        function updateSubscribeButtonText() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (subscribeBtn) {
                const isSubscribed = subscribeBtn.classList.contains('subscribed');
                subscribeBtn.textContent = i18n.t(isSubscribed ? 'channels.subscribed' : 'channels.subscribe');
            }
        }


    </script>
    
    <!-- Autocomplete Module -->
    <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
    <script src="youvi/autocomplete-data-loader.js"></script>
    <script src="youvi/autocomplete/autocomplete-cache.js"></script>
    <script src="youvi/autocomplete/autocomplete.js"></script>
    <script src="youvi/autocomplete/autocomplete-integration.js"></script>
    
    <script src="youvi/themes/theme-toggle.js"></script>
</body>
</html>