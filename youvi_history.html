<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n-title="history.pageTitle">История просмотра | Youvi</title>
    <script>
        (function() {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            
            var htmlClasses = [];
            if (theme === 'dark') htmlClasses.push('dark-theme');
            else if (theme === 'skeuo') htmlClasses.push('skeuo-theme');
            if (sidebar === 'true') htmlClasses.push('sidebar-collapsed');
            if (htmlClasses.length) document.documentElement.className = htmlClasses.join(' ');
        })();
    </script>
    <!-- Header styles -->
    <link rel="stylesheet" href="youvi/header/youvi-header.css">
    
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    <link rel="stylesheet" href="youvi/themes/dark-theme.css">
    <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    <link rel="stylesheet" href="youvi/sticky-video.css">
    <link rel="stylesheet" href="youvi/pagination.css">
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/header/youvi-header.js"></script>
    
    <!-- Video ID System -->
    <script src="youvi/video-id.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #fff;
            color: #111;
            --header-height: 88px; 
            --footer-height: 220px; 
        }

        .top-nav {
            background: #d94b88;
            border-bottom: 1px solid #c2185b;
            padding: 4px 0;
        }

        .top-nav-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .top-nav a {
            color: #fff;
            text-decoration: none;
            font-size: 12px;
            padding: 2px 0;
            transition: color 0.2s;
        }

        .top-nav a:hover {
            color: #ffd6ea;
        }

        .top-nav a.active {
            color: #ffd6ea;
            font-weight: 600;
        }

        .lang-switcher {
            margin-left: auto;
        }
        
        .lang-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }
        
        .lang-select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .lang-select option {
            background: #d94b88;
            color: #fff;
        }

        .header {
            background: #FFE7F4; 
            padding: 0;
            border-bottom: 1px solid #f2cfe1;
            min-height: 40px;
            width: 100%; 
        }

        .header-content-wrapper {
            display: flex;
            align-items: center;
            position: relative;
            box-sizing: border-box;
            max-width: 1600px; 
            margin: 0 auto; 
            padding: 0 20px; 
            width: 100%; 
            min-height: 40px; 
        }

        .nav-bar {
            display: flex;
            align-items: center;
            width: 100%; 
            justify-content: space-between;
            height: 100%;
        }

        .nav-links {
            display: flex;
            gap: 20px;
            margin-left: calc(200px + 20px + 20px); 
        }

        .nav-right-actions {
            display: flex;
            align-items: center;
            gap: 15px; 
        }

        .nav-links a {
            color: #111; 
            text-decoration: none;
            font-size: 13px;
            padding: 5px 0;
        }





        .search-btn {
            padding: 8px 15px;
            background: #ff69b4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .user-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .user-actions a {
            color: #111; 
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s;
        }
        
        .user-actions a:hover {
            color: #ff69b4;
        }

        .container {
            width: 100%;
            margin: 0;
            padding: 0 20px 0 20px;
            display: flex;
            gap: 20px;
            align-items: stretch;
            min-height: calc(100vh - 200px);
        }
        
        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
        }
        
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1500px;
            }
        }
        
        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1600px;
            }
        }
        
        .header-content-wrapper,
        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
        }

        .sidebar-collapsed .sidebar,
        html.sidebar-collapsed .sidebar {
            width: 60px !important;
            padding: 10px 8px !important;
            display: block !important;
            position: sticky !important;
            top: 40px !important;
            max-height: calc(var(--sidebar-max-height, 100vh) - 75px) !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
        }

        .sidebar-collapsed .container,
        html.sidebar-collapsed .container {
            padding-left: 20px;
        }

        .sidebar-collapsed .content-wrapper,
        html.sidebar-collapsed .content-wrapper {
            max-width: 1500px;
        }

        .sidebar-collapsed .sidebar-title,
        html.sidebar-collapsed .sidebar-title {
            display: none !important;
        }

        .sidebar-collapsed .sidebar-item,
        html.sidebar-collapsed .sidebar-item {
            padding: 8px !important;
            padding-left: 5px !important;
            padding-right: 8px !important;
            justify-content: center !important;
            border-left: 3px solid transparent !important;
            border-radius: 4px;
            font-size: 0 !important;
        }

        .sidebar-collapsed .sidebar-item:hover,
        html.sidebar-collapsed .sidebar-item:hover {
            background: rgba(255, 105, 180, 0.1);
        }

        .sidebar-collapsed .sidebar-item.active,
        html.sidebar-collapsed .sidebar-item.active {
            background: rgba(255, 105, 180, 0.15);
        }

        .sidebar-collapsed .sidebar-item svg,
        .sidebar-collapsed .sidebar-item img,
        html.sidebar-collapsed .sidebar-item svg,
        html.sidebar-collapsed .sidebar-item img {
            margin: 0 !important;
            width: 20px !important;
            height: 20px !important;
            font-size: 16px !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item {
            justify-content: center !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item span,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item span {
            display: none !important;
        }

        .sidebar-collapsed #subscribedChannelsContainer .sidebar-item div,
        html.sidebar-collapsed #subscribedChannelsContainer .sidebar-item div {
            margin: 0 !important;
        }

        .sidebar-collapsed .library-item,
        .sidebar-collapsed .nav-item,
        .sidebar-collapsed .filter-item,
        html.sidebar-collapsed .library-item,
        html.sidebar-collapsed .nav-item,
        html.sidebar-collapsed .filter-item {
            justify-content: center !important;
            gap: 0 !important;
        }

        .sidebar-collapsed .library-item span,
        .sidebar-collapsed .nav-item span,
        .sidebar-collapsed .filter-item span,
        html.sidebar-collapsed .library-item span,
        html.sidebar-collapsed .nav-item span,
        html.sidebar-collapsed .filter-item span {
            display: none !important;
        }

        .sidebar-collapsed .library-item svg,
        .sidebar-collapsed .nav-item svg,
        .sidebar-collapsed .filter-item svg,
        html.sidebar-collapsed .library-item svg,
        html.sidebar-collapsed .nav-item svg,
        html.sidebar-collapsed .filter-item svg {
            margin: 0 !important;
        }

        .sidebar {
            width: 200px;
            flex-shrink: 0;
            background: #f5f5f5;
            margin-left: -20px;
            padding-left: 20px;
            padding-top: 10px;
            padding-bottom: 0;
            align-self: stretch;
        }

        .sidebar-section {
            margin-bottom: 15px;
        }
        
        .sidebar-section:last-child {
            margin-bottom: 0;
        }

        .right-sidebar .sidebar-section:last-child {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .sidebar-title {
            font-size: 14px;
            color: #999;
            margin-bottom: 6px;
            text-transform: uppercase;
        }

        .sidebar-item {
            display: block;
            color: #333;
            text-decoration: none;
            padding: 6px 0;
            font-size: 13px;
            border-left: 3px solid transparent;
            padding-left: 10px;
        }

        .sidebar-item:hover {
            color: #c2185b; 
            border-left-color: #ff85b4; 
        }

        .sidebar-item.active {
            color: #000;
            border-left-color: #ff69b4;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding-top: 5px;
        }

        .main-content-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            margin-top: 5px; 
        }



        .section-title {
            font-size: 24px;
            color: #111;
            margin: 0;
        }

        .history-stats {
            font-size: 14px;
            color: #666;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-left: 0;
            flex: 1;
            min-height: 0;
        }
        
        .history-list .video-card {
            display: flex;
            gap: 10px;
            align-items: stretch;
            cursor: pointer;
            padding-bottom: 12px;
        }
        
        .history-list .video-thumbnail {
            flex: 0 0 280px;
            height: 158px;
            background: #eee;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }
        
        .history-list .video-thumbnail img { width: 100%; height: 100%; object-fit: cover; }
        
        .video-duration { position: absolute; bottom: 5px; right: 5px; background: rgba(0,0,0,0.8); padding: 2px 4px; border-radius: 2px; font-size: 11px; color: #fff; z-index: 2; }

        .progress {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 6px;
            background: rgba(255,255,255,0.35);
            z-index: 1;
            pointer-events: none;
        }
        .progress .bar {
            height: 100%;
            background: linear-gradient(180deg,#ff69b4,#d94b88);
            width: 0%;
        }

        .history-list .video-info {
            padding: 0 0 0 4px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            overflow: hidden;
            min-width: 0;
            flex: 1;
        }
        
        .history-list .video-card-title {
            font-size: 18px;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            overflow: hidden;
            color: #111;
            line-height: 1.3;
        }
        
        .history-list .video-card-title a { color: inherit; text-decoration: none; }
        .history-list .video-card-title a:hover { color: #ff69b4; }
        
        .history-list .video-meta-line,
        .history-list .video-dates-line {
            font-size: 13px;
            color: #666;
        }
        
        .history-list .video-desc {
            font-size: 13px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-clamp: 2;
            color: #444;
        }
        
        .history-list .video-channel-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 4px;
        }
        
        .history-list .video-channel-row .channel-avatar-mini {
            width: 20px;
            height: 20px;
            font-size: 12px;
            background: #ff69b4;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            border-radius: 0;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }
        
        .history-list .video-channel-row .playlist-channel-link {
            font-size: 14px;
            color: #ff69b4;
            text-decoration: none;
            font-weight: 500;
        }
        
        .history-list .video-channel-row .playlist-channel-link:hover { text-decoration: underline; }

        .history-actions { display: flex; flex-direction: column; gap: 8px; align-items: flex-end; width: 30px; flex-shrink: 0; }

        .remove-btn { width: 22px; height: 22px; line-height: 22px; text-align: center; padding: 0; background: #f0f0f0; color: #666; border: none; border-radius: 50%; font-size: 14px; cursor: pointer; transition: background-color 0.2s; }
        .remove-btn:hover { background: #ff69b4; color: white; }

        .watch-count { font-size: 10px; color: #999; text-align: right; }

        .right-sidebar {
            width: 200px;
            flex-shrink: 0;
            align-self: stretch;
            display: flex;
            flex-direction: column;
            padding-top: 20px; 
        }

        .stats-box { 
            padding-left: 10px; 
            font-size: 13px; 
            color: #333; 
            flex: 1; 
        }

        .action-btn {
            display: block;
            width: 100%;
            background: transparent;
            color: #333;
            text-decoration: none;
            border: none;
            border-radius: 0;
            font-size: 13px;
            padding: 8px 0;
            padding-left: 10px;
            text-align: left;
            cursor: pointer;
            transition: color 0.15s ease;
        }

        .action-btn:hover {
            color: #c2185b;
            text-decoration: none;
        }

        .action-btn.danger { color: #d32f2f; }
        .action-btn.danger:hover { color: #b71c1c; }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 60px 20px;
            font-size: 16px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .group { margin: 6px 0 20px 0; display: flex; flex-direction: column; gap: 12px; }
        .group-title { font-weight: 600; color: #111; margin: 0 0 8px 0; font-size: 20px; }


        @media (min-width: 1700px) {
            .footer-content {
                max-width: 1700px !important;
            }
        }

        @media (min-width: 2000px) {
            .footer-content {
                max-width: 1800px !important;
            }
        }

        @media (max-width: 1024px) {
            .right-sidebar {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }
            
            .sidebar {
                width: 100%;
                display: flex;
                overflow-x: auto;
                gap: 20px;
                padding: 10px 0;
                margin-bottom: 20px;
            }
            
            .sidebar-section {
                flex-shrink: 0;
                margin-bottom: 0;
            }
            
            .nav-links {
                display: none;
            }
            
            .search-input {
                width: 150px;
            }

            .history-item { flex-direction: row; }

            .video-thumbnail {
                width: 100%;
                height: 140px;
                align-self: center;
            }

            .history-actions { width: auto; flex-direction: column; justify-content: flex-start; }
        }

        @media (max-width: 480px) {
            .nav-bar {
                padding: 0 10px;
            }
            
            .search-input {
                width: 120px;
            }

            .video-thumbnail {
                height: 100px;
            }
        }

        .footer {
            background: #2c2c2c;
            color: #fff;
            padding: 25px 0 15px 0;
            margin-top: auto;
        }

        .footer-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .footer-logo {
            flex-shrink: 0;
            width: 200px;
        }

        .footer-logo img {
            height: 40px;
            width: auto;
        }

        .footer-logo p {
            margin-top: 8px;
            font-size: 11px;
            color: #ccc;
            line-height: 1.3;
        }

        .footer-sections {
            display: flex;
            gap: 30px;
            flex: 1;
        }

        .footer-main {
            display: flex;
            gap: 30px;
            flex: 1;
        }

        .footer-right {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .footer-mascot {
            flex-shrink: 0;
        }

        .footer-mascot img {
            height: 180px;
            width: auto;
        }

        .footer-section {
            flex: 1;
        }

        .footer-section h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #fff;
            font-weight: 600;
        }

        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .footer-section li {
            margin-bottom: 6px;
        }

        .footer-section a {
            color: #ccc;
            text-decoration: none;
            font-size: 11px;
            transition: color 0.2s;
        }

        .footer-section a:hover {
            color: #ff69b4;
        }

        .footer-bottom {
            border-top: 1px solid #444;
            margin-top: 20px;
            padding-top: 15px;
            text-align: center;
            color: #999;
            font-size: 10px;
        }

        @media (max-width: 768px) {
            .footer-content {
                flex-direction: column;
                gap: 20px;
            }
            
            .footer-sections {
                flex-direction: column;
                gap: 15px;
            }
            
            .footer-section {
                text-align: center;
            }
        }

                body.dark-theme input.search-input {
  background: #4a3a34 !important;
  color: #fff !important;
  border-color: #555 !important;
}
    </style>
</head>
<link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">
<body class="monolith">
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
      <a href="youvi_main.html"class="active" data-i18n="nav.video">Видео</a>
      <a href="index.html" data-i18n="nav.management">Управление</a>
      <a href="youvi_ch_list.html" data-i18n="nav.channels">Каналы</a>
      <a href="youvi_playlists_list.html" data-i18n="nav.playlists">Плейлисты</a>
      <a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a> 
      <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
      <div class="lang-switcher">
        <select id="langSwitcher" class="lang-select">
          <option value="ru">🇷🇺 RU</option>
          <option value="en">🇬🇧 EN</option>
          <option value="uk">🇺🇦 UK</option>
        </select>
      </div>
        </div>
    </div>

    <!-- Header -->
    <!-- Header -->
    <header class="header">
        <div class="header-content-wrapper">
            <div class="header-left">
                <button class="sidebar-toggle-btn" id="sidebarToggle" title="Свернуть/Развернуть боковую панель">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </button>
                
                <div class="logo">
                    <a href="youvi_main.html">
                        <img src="images/logo_youvi_ind.png" alt="Youvi logo">
                    </a>
                </div>
            </div>
            
            <div class="header-center">
                <div class="search-area autocomplete-wrapper">
                    <input type="text" class="search-input" id="headerSearchInput" placeholder="Поиск видео..." data-i18n-placeholder="search.placeholder">
                    <button class="search-btn" id="headerSearchBtn" data-i18n="search.button">Поиск</button>
                </div>
            </div>
            
            <div class="header-right">
                <div class="user-actions">
                   
                    <div class="settings-container">
                        <a href="#" class="settings-btn">⚙</a>
                        <div class="theme-dropdown">
                            <button class="theme-dropdown-item" data-theme="light" data-i18n="themes.light">Белая</button>
                            <button class="theme-dropdown-item" data-theme="dark" data-i18n="themes.dark">Черная</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation">Навигация</div>
                <a href="youvi_main.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9,22 9,12 15,12 15,22"/>
                    </svg>
                    <span data-i18n="sidebar.home">Главная</span>
                </a>
                <a href="youvi_feed_all.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 11a9 9 0 0 1 9 9"/>
                        <path d="M4 4a16 16 0 0 1 16 16"/>
                        <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                    </svg>
                    <span data-i18n="sidebar.feed">Feed</span>
                </a>
                <a href="youvi_tags.html" class="sidebar-item nav-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                     <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                  <line x1="7" y1="7" x2="7.01" y2="7"/>
                 </svg>
                    <span data-i18n="sidebar.allTagsLink">Все теги</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library">Библиотека</div>
                <a href="youvi_history.html" class="sidebar-item library-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.history">История</span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <span data-i18n="sidebar.favorites">Избранное</span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="8" y1="8" x2="16" y2="8"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="16" x2="16" y2="16"/>
                        <circle cx="6" cy="8" r="1"/>
                        <circle cx="6" cy="12" r="1"/>
                        <circle cx="6" cy="16" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.playlists">Плейлисты</span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span data-i18n="sidebar.channels">Каналы</span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
                        <polyline points="17,2 12,7 7,2"/>
                    </svg>
                    <span data-i18n="sidebar.subscriptions">Подписки</span>
                </a>
            </div>
        
            
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle">Подписки</div>
                <div id="subscribedChannelsContainer"></div>
            </div>
        
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="history.filters">Фильтры</div>
              <a href="#" class="sidebar-item filter-item active" data-filter="today" id="filterToday">
                <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                  <circle cx="12" cy="12" r="10"/>
                  <polyline points="12,6 12,12 16,14"/>
                </svg>
                <span data-i18n="history.today">Сегодня</span>
              </a>
              <a href="#" class="sidebar-item filter-item" data-filter="week" id="filterWeek">
                <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                  <rect x="3" y="4" width="18" height="17" rx="2" ry="2"/>
                  <line x1="3" y1="9" x2="21" y2="9"/>
                  <line x1="8" y1="2" x2="8" y2="6"/>
                  <line x1="16" y1="2" x2="16" y2="6"/>
                  <text x="12" y="18" text-anchor="middle" font-size="9" fill="#666" stroke="none" font-weight="bold">7</text>
                </svg>
                <span data-i18n="history.week">Неделя</span>
              </a>
              <a href="#" class="sidebar-item filter-item" data-filter="month" id="filterMonth">
                <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                  <rect x="3" y="4" width="18" height="17" rx="2" ry="2"/>
                  <line x1="3" y1="9" x2="21" y2="9"/>
                  <line x1="8" y1="2" x2="8" y2="6"/>
                  <line x1="16" y1="2" x2="16" y2="6"/>
                  <text x="12" y="18" text-anchor="middle" font-size="9" fill="#666" stroke="none" font-weight="bold">30</text>
                </svg>
                <span data-i18n="history.month">Месяц</span>
              </a>
              <a href="#" class="sidebar-item filter-item" data-filter="all" id="filterAll">
                <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                  <path d="M4 16L8 6l4 10"/>
                  <path d="M5 13h6"/>
                  <path d="M14 6h6"/>
                  <path d="M14 12h6"/>
                  <path d="M14 18h6"/>
                </svg>
                <span data-i18n="history.allHistory">Вся история</span>
              </a>
            </div>
        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
            <!-- Main Content -->
            <main class="main-content">
                <div class="main-content-header">
                    <h1 class="section-title" data-i18n="history.title">История просмотра</h1>
                    <div class="history-stats">
                        <span id="historyCount"></span> • <span id="totalTime"></span>
                    </div>
                </div>

                <div class="history-list" id="historyList"></div>
                <div class="pagination"></div>
            </main>

            <!-- Right Sidebar -->
            <aside class="right-sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-title" data-i18n="history.manage">Управление историей</div>
                    <a href="#" class="action-btn" id="pauseHistory" data-i18n="history.pauseHistory">Приостановить историю</a>
                    <a href="#" class="action-btn danger" id="clearToday" data-i18n="history.clearToday">Очистить за сегодня</a>
                    <a href="#" class="action-btn danger" id="clearWeek" data-i18n="history.clearWeek">Очистить за неделю</a>
                    <a href="#" class="action-btn danger" id="clearAll" data-i18n="history.clearAll">Очистить всю историю</a>
                </div>


                <div class="sidebar-section">
                    <div class="sidebar-title" data-i18n="history.statistics">Статистика</div>
                    <div class="stats-box"></div>
                </div>
            </aside>
        </div><!-- /content-wrapper -->
    </div>
       <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <img src="images/logo_youvi_ind_ex.png" alt="Youvi" loading="lazy">
                    <p data-i18n="footer.description">Платформа для просмотра видео контента. Сохраняйте, категоризируйте и смотрите видео.</p>
                </div>
                <div class="footer-sections">
                    <div class="footer-section">
                        <h3 data-i18n="footer.sections">Разделы</h3>
             <ul>
              <li><a href="youvi_main.html" data-i18n="footer.video">Видео</a></li>
              <li><a href="youvi_tags.html" data-i18n="sidebar.tags">Теги</a></li>
              <li><a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a></li>
              <li><a href="index.html" data-i18n="nav.management">Управление</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="sidebar.library">Библиотека</h3>
            <ul>
              <li><a href="youvi_ch_list.html" data-i18n="sidebar.channels">Каналы</a></li>
              <li><a href="youvi_playlists_list.html" data-i18n="sidebar.playlists">Плейлисты</a></li>
              <li><a href="youvi_subscriptions.html" data-i18n="sidebar.subscriptions">Подписки</a></li>
              <li><a href="youvi_fav.html" data-i18n="sidebar.favorites">Избранное</a></li>
              <li><a href="youvi_history.html" data-i18n="sidebar.history">История</a></li>
            </ul>
          </div>
          <div class="footer-section">
            <h3 data-i18n="nav.wiki">Wiki</h3>
            <ul>
              <li><a href="wiki/index.html" data-i18n="sidebar.home">Главная</a></li>
              <li><a href="wiki/player.html" data-i18n="footer.wiki.player">Плеер</a></li>
              <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku">Данмаку</a></li>
              <li><a href="wiki/tags/general.html" data-i18n="sidebar.tags">Теги</a></li>
              <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules">Правила тегирования</a></li>
              <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search">Поиск</a></li>
            </ul>
          </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.pgc">PGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
                            <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
                            <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
                            <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
                            <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.ugc">UGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
                            <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
                            <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
                            <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
                            <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
                            <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
                            <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
                        </ul>
                    </div>
          <div class="footer-section">
            <h3 data-i18n="footer.about">О сайте</h3>
            <ul>
              <li><a href="wiki/about.html" data-i18n="footer.aboutSite">Про сайт</a></li>
               <li><a href="wiki/docs.html" data-i18n="footer.docs">Документация</a></li>
              <li><a href="wiki/tech.html" data-i18n="footer.tech">Технологии</a></li>
            </ul>
                        </div>
                    </div>
                </div>
                <div class="footer-right">
                    <div class="footer-mascot">
                        <img src="images/mascot1.png" alt="Yuvi">
                    </div>
                </div>
            </div>
           
        </footer>




    <script>
        (function(){
            function updateHeaderOffset(){
                try{
                    var header=document.querySelector('.header');
                    var topNav=document.querySelector('.top-nav');
                    if(!header||!topNav) return;
                    if(window.scrollY===0){ header.style.top = topNav.offsetHeight+'px'; }
                    else { header.style.top='0px'; }
                }catch(_){ }
            }
            window.addEventListener('scroll', updateHeaderOffset, {passive:true});
            window.addEventListener('resize', updateHeaderOffset);
            document.addEventListener('DOMContentLoaded', updateHeaderOffset);
            updateHeaderOffset();
        })();
    </script>
    <!-- Mock functionality removed - real handlers are in the dynamic history script below -->
    <script>
      /**
       * DEBUG_MODE flag - Controls console logging
       * Set to false to disable console.log statements in production
       * Set to true to enable debugging output
       */
      const DEBUG_MODE = false;
      
      let videoDirectoryHandle = null;
      async function openDB(){return new Promise((res,rej)=>{const r=indexedDB.open('8SiteDB',1);r.onupgradeneeded=()=>{const db=r.result;if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');};r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});}
      async function getFromDB(db,key){const tx=db.transaction('handles','readonly');const s=tx.objectStore('handles');return new Promise((res)=>{const rq=s.get(key);rq.onsuccess=()=>res(rq.result);rq.onerror=()=>res(null);});}
      async function ensureHistoryDir(){
        try{
          if(!videoDirectoryHandle) {
            if (DEBUG_MODE) console.log('Debug: ensureHistoryDir: no videoDirectoryHandle');
            return null;
          }
          const dir = await videoDirectoryHandle.getDirectoryHandle('.history',{create:true});
          if (DEBUG_MODE) console.log('Debug: ensureHistoryDir: got history directory');
          return dir;
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: ensureHistoryDir: error:', e);
          return null;
        }
      }
      async function readHistoryFile(name,fallback){
        try{
          if (DEBUG_MODE) console.log('Debug: readHistoryFile: reading file:', name);
          const dir=await ensureHistoryDir();
          if(!dir) {
            if (DEBUG_MODE) console.log('Debug: readHistoryFile: no history directory, returning fallback');
            return fallback;
          }
          const fh=await dir.getFileHandle(name,{create:false});
          const f=await fh.getFile();
          const result = JSON.parse(await f.text());
          if (DEBUG_MODE) console.log('Debug: readHistoryFile: loaded file:', name, 'size:', f.size, 'items:', Array.isArray(result) ? result.length : 'not array');
          return result;
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: readHistoryFile: error reading file:', name, 'error:', e, 'returning fallback');
          return fallback;
        }
      }
      async function writeHistoryFile(name,data){
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try{
            const dir=await ensureHistoryDir();
            if(!dir) {
              if (DEBUG_MODE) console.log('Debug: writeHistoryFile: no history directory available');
              return false;
            }
            
            const jsonStr = JSON.stringify(data);
            const fh = await dir.getFileHandle(name, {create: true});
            const w = await fh.createWritable({keepExistingData: false});
            await w.write(jsonStr);
            await w.close();
            if (DEBUG_MODE) console.log('Debug: writeHistoryFile: successfully wrote', name);
            return true;
          }catch(e){
            console.warn('Debug: writeHistoryFile: attempt', attempt + 1, 'failed:', e.message);
            if (attempt < maxRetries - 1) {
              await new Promise(r => setTimeout(r, 100 * Math.pow(2, attempt)));
            }
          }
        }
        console.error('Debug: writeHistoryFile: all attempts failed for', name);
        alert('Не удалось сохранить. Закройте другие вкладки сайта и попробуйте снова.');
        return false;
      }
      async function loadHistory(){
        const history = await readHistoryFile('history.json', []);
        if (DEBUG_MODE) console.log('Debug: loadHistory loaded', history.length, 'items:', history.map(it => ({
          name: it.name,
          lastWatchedAt: it.lastWatchedAt,
          addedAt: it.addedAt,
          timestamp: new Date(it.lastWatchedAt || it.addedAt || 0)
        })));
        return history;
      } 
      
      async function saveHistory(a){
        const result = await writeHistoryFile('history.json',a||[]);
        if (DEBUG_MODE) console.log('Debug: saveHistory: saved', a?.length || 0, 'items, result:', result);
        return result;
      } 
      
      async function loadSettings(){
        const settings = await readHistoryFile('settings.json',{historyPaused:false});
        if (DEBUG_MODE) console.log('Debug: loadSettings: loaded settings:', settings);
        return settings;
      } 
      
      async function saveSettings(s){
        const result = await writeHistoryFile('settings.json',s||{historyPaused:false});
        if (DEBUG_MODE) console.log('Debug: saveSettings: saved settings:', s, 'result:', result);
        return result;
      }
      async function cacheDurationToDB(name,dur){try{const db=await openDB();const tx=db.transaction('handles','readwrite');const st=tx.objectStore('handles');const ex=await st.get('duration_'+name);if(!ex||ex.duration!==dur){await st.put({duration:dur,timestamp:Date.now()},'duration_'+name);}}catch(_){}}
      async function cacheDurationSecondsToDB(name,sec){try{if(!isFinite(sec)||isNaN(sec)||sec<=0) return;const db=await openDB();const tx=db.transaction('handles','readwrite');const st=tx.objectStore('handles');await st.put({seconds:Math.round(sec),timestamp:Date.now()},'durationSec_'+name);}catch(_){}}
      async function getCachedPreview(name){try{const db=await openDB();const c=await getFromDB(db,'preview_'+name);if(c && (Date.now()-c.timestamp<30*24*60*60*1000)) return c.preview;}catch(_){}return null;}
      async function getCachedDuration(name){
        try{
          const db=await openDB();
          const c=await getFromDB(db,'duration_'+name);
          if(c && typeof c.duration==='string' && (Date.now()-c.timestamp<30*24*60*60*1000)) return c.duration;
          const p=await getFromDB(db,'preview_'+name);
          if(p && typeof p.duration==='string' && (Date.now()-p.timestamp<30*24*60*60*1000)) return p.duration;
        }catch(_){}
        return null;
      }
      async function getCachedDurationSec(name){try{const db=await openDB();const c=await getFromDB(db,'durationSec_'+name);if(c && typeof c.seconds==='number' && (Date.now()-c.timestamp<30*24*60*60*1000)) return c.seconds;}catch(_){}return null;}
      async function readJSON(dirHandle,fileName,def){
        try{
          const fh=await dirHandle.getFileHandle(fileName,{create:false});
          const f=await fh.getFile();
          const result = JSON.parse(await f.text());
          if (DEBUG_MODE) console.log('Debug: readJSON: loaded file:', fileName, 'result:', result);
          return result;
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: readJSON: error reading file:', fileName, 'error:', e, 'returning default:', def);
          return def;
        }
      }
      async function loadMetaDescriptionForItem(it){
        try{
          if(!videoDirectoryHandle||!it||!it.name) {
            if (DEBUG_MODE) console.log('Debug: loadMetaDescriptionForItem: missing required data:', {videoDirectoryHandle: !!videoDirectoryHandle, it: !!it, name: it?.name});
            return '';
          }
          
          let dir=videoDirectoryHandle;
          const pl=(it.playlist||'').trim();
          
          if(pl){ 
            try{ 
              dir=await videoDirectoryHandle.getDirectoryHandle(pl); 
              if (DEBUG_MODE) console.log('Debug: loadMetaDescriptionForItem: using playlist directory:', pl);
            }catch(e){
              if (DEBUG_MODE) console.log('Debug: loadMetaDescriptionForItem: error getting playlist directory:', pl, 'error:', e);
            }
          }
          
          const metaDir=await dir.getDirectoryHandle('.metadata',{create:true});
          const meta=await readJSON(metaDir, it.name + '.meta.json', {});
          const d=typeof meta.description==='string'?meta.description.trim():'';
          
          if (DEBUG_MODE) console.log('Debug: loadMetaDescriptionForItem: loaded description for:', it.name, 'description:', d);
          return d;
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: loadMetaDescriptionForItem: error loading description for:', it?.name, 'error:', e);
          return ''; 
        } 
      }
      async function loadChannelForItem(it){
        try{
          if(!videoDirectoryHandle||!it||!it.name) {
            if (DEBUG_MODE) console.log('Debug: loadChannelForItem: missing required data:', {videoDirectoryHandle: !!videoDirectoryHandle, it: !!it, name: it?.name});
            return '';
          }
          
          let dir=videoDirectoryHandle;
          const pl=(it.playlist||'').trim();
          
          if(pl){ 
            try{ 
              dir=await videoDirectoryHandle.getDirectoryHandle(pl); 
              if (DEBUG_MODE) console.log('Debug: loadChannelForItem: using playlist directory:', pl);
            }catch(e){
              if (DEBUG_MODE) console.log('Debug: loadChannelForItem: error getting playlist directory:', pl, 'error:', e);
            }
          }
          
          const metaDir=await dir.getDirectoryHandle('.metadata',{create:true});
          const meta=await readJSON(metaDir, it.name + '.meta.json', {});
          
          if (DEBUG_MODE) console.log('Debug: loadChannelForItem: loaded meta for:', it.name, 'meta:', meta);
          
          let ch = '';
          if (typeof meta.channel === 'string') ch = meta.channel.trim();
          if (!ch && typeof meta.author === 'string') ch = meta.author.trim();
          if (!ch && typeof meta.uploader === 'string') ch = meta.uploader.trim();
          
          if (!ch){
            const tags = Array.isArray(meta.tags)? meta.tags : [];
            const authorTag = tags.find(t=> typeof t==='string' && (t.endsWith(' (ка)') || t.endsWith(' (канал)')));
            if (authorTag) ch = authorTag.replace(' (ка)','').replace(' (канал)','').trim();
          }
          
          if (DEBUG_MODE) console.log('Debug: loadChannelForItem: resolved channel for:', it.name, 'channel:', ch);
          return ch || '';
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: loadChannelForItem: error loading channel for:', it?.name, 'error:', e);
          return ''; 
        } 
      }
      function formatDuration(sec){if(!isFinite(sec)||isNaN(sec)||sec<=0) return '0:00';const s=Math.round(sec);const h=Math.floor(s/3600);const m=Math.floor((s%3600)/60);const ss=String(s%60).padStart(2,'0');return h>0?`${h}:${String(m).padStart(2,'0')}:${ss}`:`${m}:${ss}`;}
      function parseDurationToSeconds(str){try{if(!str||typeof str!=='string') return 0;const parts=str.split(':').map(x=>parseInt(x,10));if(parts.some(isNaN)) return 0;let s=0;if(parts.length===3){s = parts[0]*3600 + parts[1]*60 + parts[2];}else if(parts.length===2){s = parts[0]*60 + parts[1];}return s;}catch(_){return 0;}}
      function formatHumanTime(totalSeconds){
        if(!isFinite(totalSeconds)||isNaN(totalSeconds)||totalSeconds<=0) {
          return `0 ${i18n.t('history.hours')} 0 ${i18n.t('history.minutes')}`;
        }
        const h=Math.floor(totalSeconds/3600);
        const m=Math.floor((totalSeconds%3600)/60);
        return `${h} ${i18n.t('history.hours')} ${m} ${i18n.t('history.minutes')}`;
      }
      async function initVideoHandle(){
        try{
          if (DEBUG_MODE) console.log('Debug: initVideoHandle: starting');
          const db=await openDB();
          const h=await getFromDB(db,'videoDirectoryHandle');
          if(h){
            if (DEBUG_MODE) console.log('Debug: initVideoHandle: found handle in DB');
            const p=await h.queryPermission();
            if (DEBUG_MODE) console.log('Debug: initVideoHandle: permission:', p);
            if(p==='granted'||(p==='prompt' && await h.requestPermission()==='granted')){
              videoDirectoryHandle=h;
              if (DEBUG_MODE) console.log('Debug: initVideoHandle: handle set successfully');
            }else{
              if (DEBUG_MODE) console.log('Debug: initVideoHandle: permission denied');
            }
          }else{
            if (DEBUG_MODE) console.log('Debug: initVideoHandle: no handle found in DB');
          }
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: initVideoHandle: error:', e);
        }
      }
      async function selectVideoFolder(){
        try{
          if (DEBUG_MODE) console.log('Debug: selectVideoFolder: starting');
          const handle = await window.showDirectoryPicker();
          if (!handle) {
            if (DEBUG_MODE) console.log('Debug: selectVideoFolder: no handle selected');
            return;
          }
          if (DEBUG_MODE) console.log('Debug: selectVideoFolder: got handle:', handle.name);
          
          const db = await openDB();
          const tx = db.transaction('handles','readwrite');
          const store = tx.objectStore('handles');
          await store.put(handle,'videoDirectoryHandle');
          videoDirectoryHandle = handle;
          if (DEBUG_MODE) console.log('Debug: selectVideoFolder: handle saved to DB and set');
          
          currentPage = 1;
          await renderHistory();
          updateStats();
          await setPauseBtn();
          if (DEBUG_MODE) console.log('Debug: selectVideoFolder: completed');
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: selectVideoFolder: error:', e);
        }
      }
      const fileResolutionCache = new Map();
      
      async function resolveFileForItem(it){
        try{
          if(!videoDirectoryHandle||!it||!it.name) {
            if (DEBUG_MODE) console.log('Debug: resolveFileForItem: missing required data:', {videoDirectoryHandle: !!videoDirectoryHandle, it: !!it, name: it?.name});
            return null;
          }
          
          const cacheKey = `${it.name}_${it.playlist || 'root'}`;
          if (fileResolutionCache.has(cacheKey)) {
            const cached = fileResolutionCache.get(cacheKey);
            if (cached && Date.now() - cached.timestamp < 300000) {
              if (DEBUG_MODE) console.log('Debug: resolveFileForItem: using cached result for:', it.name);
              return cached.file;
            }
            fileResolutionCache.delete(cacheKey);
          }
          
          let dir=videoDirectoryHandle;
          const pl=(it.playlist||'').trim();
          
          if(pl){
            try{
              dir=await videoDirectoryHandle.getDirectoryHandle(pl);
              if (DEBUG_MODE) console.log('Debug: resolveFileForItem: using playlist directory:', pl);
            }catch(e){
              if (DEBUG_MODE) console.log('Debug: resolveFileForItem: error getting playlist directory:', pl, 'error:', e);
            }
          }
          
          try {
          const fh=await dir.getFileHandle(it.name);
          const file = await fh.getFile();
          if (DEBUG_MODE) console.log('Debug: resolveFileForItem: resolved file for:', it.name, 'size:', file.size);
            
            fileResolutionCache.set(cacheKey, {
              file: file,
              timestamp: Date.now()
            });
            
          return file;
          } catch (fileError) {
            if (DEBUG_MODE) console.log('Debug: resolveFileForItem: file not found in directory, searching subdirectories...');
            try {
              for await (const [name, handle] of dir.entries()) {
                if (handle.kind === 'directory') {
                  try {
                    const subDir = await dir.getDirectoryHandle(name);
                    const subFileHandle = await subDir.getFileHandle(it.name);
                    const file = await subFileHandle.getFile();
                    if (DEBUG_MODE) console.log('Debug: resolveFileForItem: found file in subdirectory:', name, 'size:', file.size);
                    
                    fileResolutionCache.set(cacheKey, {
                      file: file,
                      timestamp: Date.now()
                    });
                    
                    return file;
                  } catch (subError) {
                    continue;
                  }
                }
              }
            } catch (searchError) {
              if (DEBUG_MODE) console.log('Debug: resolveFileForItem: error searching subdirectories:', searchError);
            }
            
            if (DEBUG_MODE) console.log('Debug: resolveFileForItem: file not found anywhere:', it.name);
            
            fileResolutionCache.set(cacheKey, {
              file: null,
              timestamp: Date.now()
            });
            
            return null;
          }
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: resolveFileForItem: error resolving file for:', it?.name, 'error:', e);
          return null;
        }
      }
      async function getVideoMetadata(dirHandle, fileName) {
        try {
          const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
          const metaHandle = await metaDir.getFileHandle(fileName + '.meta.json');
          const file = await metaHandle.getFile();
          const metadata = JSON.parse(await file.text());
          return metadata;
        } catch (e) { 
          return { views: 0, likes: 0, dislikes: 0, tags: [], created: Date.now() }; 
        }
      }

      async function saveVideoMetadata(dirHandle, fileName, metadata) {
        try {
          const existingMeta = await getVideoMetadata(dirHandle, fileName);
          const safeMeta = {
            ...existingMeta,
            ...metadata,
            views: Math.max(existingMeta.views || 0, metadata.views || 0),
            quality: metadata.quality || existingMeta.quality,
            tags: metadata.tags || existingMeta.tags || []
          };
          
          const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
          const metaFileName = fileName + '.meta.json';
          const fh = await metaDir.getFileHandle(metaFileName, { create: true });
          const w = await fh.createWritable();
          await w.write(JSON.stringify(safeMeta, null, 2));
          await w.close();
        } catch (e) {
          console.error('Error saving video metadata:', e);
        }
      }

      async function getPreviewAndDuration(video) {
        if (video._cachedPreview && video._cachedDuration) {
          return { preview: video._cachedPreview, duration: video._cachedDuration };
        }

        const dirHandle = video.dirHandle || videoDirectoryHandle;
        const meta = await getVideoMetadata(dirHandle, video.name);

        const fileChanged = meta.size !== video.file.size || meta.modified !== video.file.lastModified;

        if (meta.preview && meta.duration && !fileChanged) {
          video._cachedPreview = meta.preview;
          video._cachedDuration = meta.duration;
          return { preview: meta.preview, duration: meta.duration };
        }

        try{
          const cachedDur = await getCachedDuration(video.name);
          if (cachedDur) {
            video._cachedDuration = cachedDur;
          }
        }catch(_){ }

        if (!video.file) {
          return { preview: '', duration: '0:00' };
        }

        return new Promise((resolve, reject) => {
          const el = document.createElement('video');
          el.muted = true;
          el.playsInline = true;
          el.preload = 'metadata';
          
          const url = URL.createObjectURL(video.file);
          
          const cleanup = () => {
            URL.revokeObjectURL(url);
            el.remove();
          };
          
          const timeout = setTimeout(() => {
            cleanup();
            resolve({ preview: null, duration: video._cachedDuration || '0:00' });
          }, 10000);
          
          el.addEventListener('error', (e) => {
            clearTimeout(timeout);
            cleanup();
            resolve({ preview: null, duration: '0:00' });
          }, { once: true });
          
          el.addEventListener('loadedmetadata', async () => {
            try {
              if (!isFinite(el.duration) || el.duration <= 0) {
                clearTimeout(timeout);
                cleanup();
                resolve({ preview: null, duration: '0:00' });
                return;
              }
              
              const duration = formatDuration(el.duration);
              el.currentTime = Math.max(0, el.duration / 2);
              
              el.addEventListener('seeked', async () => {
                try {
                  const canvas = document.createElement('canvas');
                  const ctx = canvas.getContext('2d');
                  
                  canvas.width = 320;
                  canvas.height = 180;
                  
                  if (el.videoWidth === 0 || el.videoHeight === 0) {
                    throw new Error('Invalid video dimensions');
                  }
                  
                  ctx.drawImage(el, 0, 0, canvas.width, canvas.height);
                  
                  let preview;
                  try {
                    preview = canvas.toDataURL('image/webp', 0.8);
                  } catch (e) {
                    preview = canvas.toDataURL('image/jpeg', 0.7);
                  }
                  
                  clearTimeout(timeout);
                  cleanup();
                  
                  const updatedMeta = {
                    ...meta,
                    preview: preview,
                    duration: duration,
                    size: video.file.size,
                    modified: video.file.lastModified,
                    compressed: preview.includes('image/webp')
                  };
                  saveVideoMetadata(dirHandle, video.name, updatedMeta).catch(console.error);

                  video._cachedPreview = preview;
                  video._cachedDuration = duration;
                  
                  resolve({ preview, duration });
                } catch (e) {
                  clearTimeout(timeout);
                  cleanup();
                  resolve({ preview: null, duration: duration });
                }
              }, { once: true });
              
              el.addEventListener('error', (e) => {
                clearTimeout(timeout);
                cleanup();
                resolve({ preview: null, duration: duration });
              }, { once: true });
              
            } catch (e) {
              clearTimeout(timeout);
              cleanup();
              resolve({ preview: null, duration: '0:00' });
            }
          }, { once: true });
          
          el.src = url;
        });
      }

      const previewQueue = [];
      let isProcessingQueue = false;

      const previewObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            const item = img.dataset.item ? JSON.parse(img.dataset.item) : null;
            if (item) {
              const priority = entry.intersectionRatio > 0.5 ? 1 : 2;
              previewQueue.push({ img, item, priority });
              previewQueue.sort((a, b) => a.priority - b.priority);
              
              previewObserver.unobserve(img);
              
              if (!isProcessingQueue) {
                processPreviewQueue();
              }
            }
          }
        });
      }, {
        rootMargin: '100px 0px',
        threshold: [0.1, 0.5, 1.0]
      });

      async function processPreviewQueue() {
        if (isProcessingQueue || previewQueue.length === 0) return;
        
        isProcessingQueue = true;
        
        while (previewQueue.length > 0) {
          const { img, item } = previewQueue.shift();
          await loadPreviewForItem(img, item);
          
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        isProcessingQueue = false;
      }

      async function loadPreviewForItem(img, it) {
        if (!img || !it) return;
        const name = it.name || '';
        if (!name) return;
        
        if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: loading preview for item:', name);
        
        img.setAttribute('decoding', 'async');
        img.setAttribute('loading', 'lazy');
        
        try {
          const c = await getCachedPreview(name);
          if (c && c.length > 100) {
            img.src = c;
            if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: using cached preview for:', name);
            
            const badge = img.closest('.video-thumbnail')?.querySelector('.video-duration');
            if (badge) {
              const d = await getCachedDuration(name);
              if (d) {
                badge.textContent = d;
              }
            }
            return;
          }
        } catch (e) {
          if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: error getting cached preview for:', name, 'error:', e);
        }
        
        try {
          const file = await resolveFileForItem(it);
          if (file) {
            if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: found file for:', name, 'size:', file.size);
            const video = {
              name: it.name,
              file: file,
              dirHandle: videoDirectoryHandle
            };
            
            const { preview, duration } = await getPreviewAndDuration(video);
            if (preview) {
              img.src = preview;
              if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: generated preview for:', name);
            }
            if (duration) {
              const badge = img.closest('.video-thumbnail')?.querySelector('.video-duration');
              if (badge) {
                badge.textContent = duration;
              }
              cacheDurationToDB(name, duration);
              cacheDurationSecondsToDB(name, parseDurationToSeconds(duration));
            }
          } else {
            if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: file not found for:', name);
            const badge = img.closest('.video-thumbnail')?.querySelector('.video-duration');
            if (badge) {
              badge.textContent = '0:00';
            }
          }
        } catch (e) {
          if (DEBUG_MODE) console.log('Debug: loadPreviewForItem: error handling preview for:', name, 'error:', e);
          const badge = img.closest('.video-thumbnail')?.querySelector('.video-duration');
          if (badge) {
            badge.textContent = '0:00';
          }
        }
      }

      async function fillThumbnail(img, it) {
        if (!img || !it) return;
        const name = it.name || '';
        if (!name) return;
        
        if (DEBUG_MODE) console.log('Debug: fillThumbnail: setting up thumbnail for item:', name);
        
        img.dataset.item = JSON.stringify(it);
        
        try {
          const c = await getCachedPreview(name);
          if (c && c.length > 100) {
            img.src = c;
            if (DEBUG_MODE) console.log('Debug: fillThumbnail: using cached preview for:', name);
            const badge = img.closest('.video-thumbnail')?.querySelector('.video-duration');
            if (badge) {
              const d = await getCachedDuration(name);
              if (d) {
                badge.textContent = d;
              }
            }
            return;
          }
        } catch (e) {
          if (DEBUG_MODE) console.log('Debug: fillThumbnail: error getting cached preview for:', name, 'error:', e);
        }
        
        previewObserver.observe(img);
      }
      let perPage=20,currentPage=1,currentQuery='',currentFilter='all';
      if (DEBUG_MODE) console.log('Debug: currentFilter initialized as:', currentFilter);
      
      let timeCalculationCache = {
        data: null,
        timestamp: 0,
        filter: '',
        query: ''
      };
      
      function invalidateCaches() {
        timeCalculationCache = {
          data: null,
          timestamp: 0,
          filter: '',
          query: ''
        };
        statsCache = {
          data: null,
          timestamp: 0,
          listLength: 0
        };
        if (DEBUG_MODE) console.log('Debug: caches invalidated');
      }
      function updatePageParam(){ try{ const url=new URL(window.location.href); if(currentPage && currentPage>1) url.searchParams.set('page', String(currentPage)); else url.searchParams.delete('page'); window.history.replaceState({},'',url.toString()); }catch(_){}}
      function readInitialPage(){ try{ const p=parseInt(new URL(window.location.href).searchParams.get('page')||'1',10); if(isFinite(p)&&p>0) currentPage=p; }catch(_){ currentPage=1; }}
      function groupByDate(items){
        const map=new Map();
        if (DEBUG_MODE) console.log('Debug: groupByDate called with', items.length, 'items');
        
        for(const it of items){
            let timestamp = it.lastWatchedAt || it.addedAt;
            
            if (DEBUG_MODE) console.log('Debug: item', it.name, 'timestamp:', timestamp, 'type:', typeof timestamp);
            
            if (!timestamp || timestamp === 0) {
                if (DEBUG_MODE) console.log('Debug: skipping item', it.name, 'due to missing/invalid timestamp');
                continue;
            }
            
            const d = new Date(timestamp);
            if (DEBUG_MODE) console.log('Debug: item', it.name, 'parsed date:', d, 'isValid:', !isNaN(d.getTime()));
            
            if (isNaN(d.getTime()) || d > new Date()) {
                if (DEBUG_MODE) console.log('Debug: skipping item', it.name, 'due to invalid date');
                continue;
            }
            
            const key = [d.getFullYear(), d.getMonth()+1, d.getDate()].join('-');
            if (DEBUG_MODE) console.log('Debug: item', it.name, 'date key:', key);
            if (!map.has(key)) map.set(key, []);
            map.get(key).push(it);
        }
        
        const entries = Array.from(map.entries()).sort((a, b) => {
            const [yearA, monthA, dayA] = a[0].split('-').map(n => parseInt(n, 10));
            const [yearB, monthB, dayB] = b[0].split('-').map(n => parseInt(n, 10));
            
            if (yearA !== yearB) return yearB - yearA;
            if (monthA !== monthB) return monthB - monthA;
            return dayB - dayA;
        });
        
        return entries.map(([k, arr]) => ({key: k, items: arr}));
      }
      function formatGroupDate(key){
        const [y,m,d]=key.split('-').map(n=>parseInt(n,10));
        const dt=new Date(y,m-1,d);
        const today=new Date();
        const isSame=(a,b)=>a.getFullYear()===b.getFullYear()&&a.getMonth()===b.getMonth()&&a.getDate()===b.getDate();
        const yest=new Date();
        yest.setDate(today.getDate()-1);
        
        if (DEBUG_MODE) console.log('Debug: formatGroupDate: key:', key, 'parsed date:', dt, 'today:', today, 'yesterday:', yest);
        
        if(isSame(dt,today)) {
          if (DEBUG_MODE) console.log('Debug: formatGroupDate: returning "Today"');
          return i18n.t('history.today');
        }
        if(isSame(dt,yest)) {
          if (DEBUG_MODE) console.log('Debug: formatGroupDate: returning "Yesterday"');
          return i18n.t('history.yesterday');
        }
        
        const currentLang = i18n.getCurrentLanguage();
        const locale = currentLang === 'en' ? 'en-US' : currentLang === 'uk' ? 'uk-UA' : 'ru-RU';
        const result = dt.toLocaleDateString(locale,{day:'numeric',month:'long',year:'numeric'});
        if (DEBUG_MODE) console.log('Debug: formatGroupDate: returning formatted date:', result);
        return result;
      }
      function buildVideoUrl(it){
        const n=encodeURIComponent(it.name||'');
        const p=encodeURIComponent(it.playlist||'');
        const url = window.VideoID 
            ? window.VideoID.buildVideoUrl(it.name, it.playlist)
            : `youvi_video.html?name=${n}&playlist=${p}`;
        if (DEBUG_MODE) console.log('Debug: buildVideoUrl: item:', it.name, 'url:', url);
        return url;
      }
      function getFileNameWithoutExtension(name){try{return String(name||'').replace(/\.[^/.]+$/,'');}catch(_){return name||'';}}
      function getDisplayTitle(it){
        try{
          const raw = (it && (it.title || it.name)) ? String(it.title || it.name) : 'Видео';
          const result = raw.replace(/\.(mp4|mkv|avi|mov|webm|m4v)$/i,'');
          if (DEBUG_MODE) console.log('Debug: getDisplayTitle: item:', it.name, 'raw:', raw, 'result:', result);
          return result;
        }catch(e){ 
          if (DEBUG_MODE) console.log('Debug: getDisplayTitle: error for item:', it.name, 'error:', e);
          return 'Видео'; 
        }
      }
      function formatDate(ts){
        if (!ts || ts === 0) {
          return 'Дата не указана';
        }
        const d = new Date(ts);
        if (isNaN(d.getTime())) {
          return 'Некорректная дата';
        }
        const currentLang = i18n.getCurrentLanguage();
        const locale = currentLang === 'en' ? 'en-US' : currentLang === 'uk' ? 'uk-UA' : 'ru-RU';
        return d.toLocaleString(locale,{day:'numeric',month:'long',hour:'2-digit',minute:'2-digit'});
      }
      function passesFilter(it){
        try{
          const t = it.lastWatchedAt || it.addedAt;
          
          if (!t || t === 0) {
            if (DEBUG_MODE) console.log('Debug: passesFilter: item', it.name, 'skipped due to missing timestamp');
            return false;
          }
          
          const now = new Date();
          const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
          const weekAgo = now.getTime() - 7*24*60*60*1000;
          const monthAgo = now.getTime() - 30*24*60*60*1000;
          
          const result = (() => {
            switch(currentFilter){
              case 'today': return t >= startOfToday;
              case 'week': return t >= weekAgo;
              case 'month': return t >= monthAgo;
              default: return true;
            }
          })();
          
          if (DEBUG_MODE) console.log('Debug: passesFilter: item', it.name, 'timestamp:', t, 'filter:', currentFilter, 'result:', result);
          return result;
        }catch(_){
          if (DEBUG_MODE) console.log('Debug: passesFilter: item', it.name, 'error in filter');
          return false;
        }
      }
      function setActiveFilterButton(key){
        if (DEBUG_MODE) console.log('Debug: setActiveFilterButton called with key:', key);
        const map={today:'#filterToday',week:'#filterWeek',month:'#filterMonth',all:'#filterAll'};
        document.querySelectorAll('#filterToday, #filterWeek, #filterMonth, #filterAll').forEach(el=>el.classList.remove('active'));
        const sel=map[key]||map.all;
        const btn=document.querySelector(sel);
        if(btn) {
          btn.classList.add('active');
          if (DEBUG_MODE) console.log('Debug: setActiveFilterButton: activated button:', sel);
        }
      }
      
      async function updateTotalTime(list) {
        try {
          const cacheKey = `${currentFilter}_${currentQuery}_${list.length}`;
          const now = Date.now();
          
          if (timeCalculationCache.data && 
              timeCalculationCache.filter === currentFilter && 
              timeCalculationCache.query === currentQuery &&
              (now - timeCalculationCache.timestamp) < 30000) {
            
            if (DEBUG_MODE) console.log('Debug: updateTotalTime: using cached result');
            document.getElementById('totalTime').textContent = timeCalculationCache.data;
            return;
          }
          
          if (DEBUG_MODE) console.log('Debug: updateTotalTime: calculating new result for', list.length, 'items');
          
          let watched = 0;
          const promises = [];
          
          const batchSize = 10;
          for (let i = 0; i < list.length; i += batchSize) {
            const batch = list.slice(i, i + batchSize);
            promises.push(processBatch(batch));
          }
          
          const results = await Promise.all(promises);
          watched = results.reduce((sum, batchResult) => sum + batchResult, 0);
          
          const formattedTime = formatHumanTime(Math.round(watched));
          document.getElementById('totalTime').textContent = formattedTime;
          
          timeCalculationCache = {
            data: formattedTime,
            timestamp: now,
            filter: currentFilter,
            query: currentQuery
          };
          
          if (DEBUG_MODE) console.log('Debug: updateTotalTime: calculated', Math.round(watched), 'seconds, formatted as', formattedTime);
        } catch (e) {
          if (DEBUG_MODE) console.log('Debug: updateTotalTime: error:', e);
          document.getElementById('totalTime').textContent = formatHumanTime(0);
        }
      }
      
      async function processBatch(batch) {
        let batchWatched = 0;
        
        for (const it of batch) {
          const name = it.name || '';
          let sec = 0;
          
          if (it.durationSec && isFinite(it.durationSec)) {
            sec = it.durationSec;
          } else {
            const cachedSec = await getCachedDurationSec(name);
            if (typeof cachedSec === 'number' && cachedSec > 0) {
              sec = cachedSec;
            } else {
              const durStr = await getCachedDuration(name);
              const parsed = durStr ? parseDurationToSeconds(durStr) : 0;
              sec = parsed;
            }
          }
          
          batchWatched += (sec || 0) * (it.progress || 0);
        }
        
        return batchWatched;
      }
      async function renderHistory(){const root=document.getElementById('historyList');const pag=document.querySelector('.pagination');const info=pag?.querySelector('.pagination-info');root.innerHTML='';
        if(!videoDirectoryHandle){
          root.innerHTML = '<div class="empty-state">Не выбран каталог с медиа и историей.<br><button id="pickFolderBtn" class="action-btn" style="margin-top:10px">Выбрать папку</button></div>';
          const btn = document.getElementById('pickFolderBtn');
          if (btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); selectVideoFolder(); });
          if(info) info.textContent='0-0 из 0';
          buildPagination(1,1);
          return;
        }
        let list=await loadHistory();
        if (DEBUG_MODE) console.log('Debug: renderHistory: loaded', list.length, 'items');
        
        if(currentQuery){
          const q=currentQuery.toLowerCase();
          list=list.filter(it=>((it.title||it.name||'').toLowerCase().includes(q)));
          if (DEBUG_MODE) console.log('Debug: renderHistory: after search filter:', list.length, 'items');
        }
        
        list=list.filter(passesFilter);
        if (DEBUG_MODE) console.log('Debug: renderHistory: after date filter:', list.length, 'items');
        list.sort((a,b)=>(b.lastWatchedAt||0)-(a.lastWatchedAt||0));
        const total=list.length;
        if(total===0){
          root.innerHTML=`<div class="empty-state">${i18n.t('history.noHistory')}</div>`;
          document.getElementById('historyCount').textContent=`0 ${i18n.t('history.videoCount')}`;
          document.getElementById('totalTime').textContent=`0 ${i18n.t('history.totalTime')} 0 ${i18n.t('history.minutes')}`;
          if(info) info.textContent=`0-0 ${i18n.t('pagination.of')} 0`;
          buildPagination(1,1);
          return;
        }
        const totalPages=Math.max(1,Math.ceil(total/perPage));
        if(currentPage>totalPages){ currentPage=totalPages; updatePageParam(); }
        const start=(currentPage-1)*perPage;const end=Math.min(total,start+perPage);
        const pageItems=list.slice(start,end);
        document.getElementById('historyCount').textContent=`${total} ${i18n.t('history.videoCount')}`;
        if(info) info.textContent=`${start+1}-${end} ${i18n.t('pagination.of')} ${total} (${i18n.t('pagination.page')} ${currentPage} ${i18n.t('pagination.of')} ${totalPages})`;
        updateTotalTime(list);
        if (DEBUG_MODE) console.log('Debug: pageItems before grouping:', pageItems.map(it => ({
          name: it.name,
          lastWatchedAt: it.lastWatchedAt,
          addedAt: it.addedAt,
          timestamp: new Date(it.lastWatchedAt || it.addedAt || 0)
        })));
        const groups=groupByDate(pageItems);
        if (DEBUG_MODE) console.log('Debug: groups after grouping:', groups);
        for(const g of groups){const wrap=document.createElement('div');wrap.className='group';const title=document.createElement('div');title.className='group-title';title.textContent=formatGroupDate(g.key);wrap.appendChild(title);
          for(const it of g.items){const row=document.createElement('div');row.className='video-card';
            const link=document.createElement('a');link.href=buildVideoUrl(it);link.className='video-thumbnail';
            const img=document.createElement('img');link.appendChild(img);
            const dur=document.createElement('div');dur.className='video-duration';dur.textContent='...';link.appendChild(dur);
            const prog=document.createElement('div');prog.className='progress';const bar=document.createElement('div');bar.className='bar';bar.style.width=Math.round((it.progress||0)*100)+'%';prog.appendChild(bar);link.appendChild(prog);
            
            const infoWrap=document.createElement('div');infoWrap.className='video-info';
            
            const progressPct = Math.round((it.progress||0)*100);
            const watchedText = i18n.t('history.watched');
            const progressLine = `<div class="video-meta-line">${watchedText}: ${progressPct}%</div>`;
            
            let watchedDate = '';
            if (it.lastWatchedAt) {
                const date = new Date(it.lastWatchedAt);
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                if (date.toDateString() === today.toDateString()) {
                    watchedDate = i18n.t('history.today');
                } else if (date.toDateString() === yesterday.toDateString()) {
                    watchedDate = i18n.t('history.yesterday');
                } else {
                    const currentLang = i18n.getCurrentLanguage();
                    const locale = currentLang === 'en' ? 'en-US' : currentLang === 'uk' ? 'uk-UA' : 'ru-RU';
                    watchedDate = date.toLocaleDateString(locale, {day: 'numeric', month: 'short', year: 'numeric'});
                }
            }
            const datesLine = watchedDate ? `<div class="video-dates-line">${watchedDate}</div>` : '';
            
            const tags = Array.isArray(it.tags) ? it.tags.filter(t=>!t.includes('(ка)')) : [];
            const descLine = tags.length ? `<div class="video-desc">${escapeHtml(tags.join(', '))}</div>` : '';
            
            const channelTags = Array.isArray(it.tags) ? it.tags.filter(t=>t.includes('(ка)')) : [];
            let channelName = channelTags.length ? channelTags[0].replace(' (ка)','') : '';
            let channelRow = '';
            if(channelName){
              channelRow = `<div class="video-channel-row"><span class="channel-avatar-mini" data-channel="${escapeHtml(channelName)}">${escapeHtml(channelName.charAt(0).toUpperCase())}</span><a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" class="playlist-channel-link">${escapeHtml(channelName)}</a></div>`;
            }
            
            infoWrap.innerHTML = `<div class="video-card-title"><a href="${buildVideoUrl(it)}" style="color:inherit;text-decoration:none;" title="${escapeHtml(getDisplayTitle(it))}">${escapeHtml(getDisplayTitle(it))}</a></div>${progressLine}${datesLine}${descLine}${channelRow}`;
            
            const actions=document.createElement('div');actions.className='history-actions';
            const del=document.createElement('button');del.className='remove-btn';del.setAttribute('aria-label','Удалить');del.textContent='✕';
            del.addEventListener('click',async(e)=>{
              e.stopPropagation();
              e.preventDefault();
              if (DEBUG_MODE) console.log('Debug: delete clicked for item:', it);
              
              const arr = await loadHistory();
              if (DEBUG_MODE) console.log('Debug: loaded history array length:', arr.length);
              if (arr.length > 0) {
                if (DEBUG_MODE) console.log('Debug: first item in array:', arr[0]);
              }
              
              let idx = -1;
              if (it.key) {
                idx = arr.findIndex(x => x.key === it.key);
                if (DEBUG_MODE) console.log('Debug: search by key:', it.key, 'found at:', idx);
              }
              
              if (idx < 0) {
                idx = arr.findIndex(x => x.name === it.name && (x.playlist || '') === (it.playlist || ''));
                if (DEBUG_MODE) console.log('Debug: search by name+playlist found at:', idx);
              }
              
              if (idx < 0) {
                idx = arr.findIndex(x => x.name === it.name);
                if (DEBUG_MODE) console.log('Debug: search by name only found at:', idx);
              }
              
              if (idx >= 0) {
                if (DEBUG_MODE) console.log('Debug: removing item at index:', idx);
                arr.splice(idx, 1);
                const saved = await saveHistory(arr);
                if (DEBUG_MODE) console.log('Debug: saveHistory result:', saved, 'new length:', arr.length);
                if (saved) {
                  invalidateCaches();
                  await renderHistory();
                } else {
                  alert('Ошибка сохранения! Проверьте консоль.');
                }
              } else {
                if (DEBUG_MODE) console.log('Debug: item not found in history array!');
                alert('Элемент не найден в истории');
              }
            });
            actions.appendChild(del);
            row.appendChild(link);row.appendChild(infoWrap);row.appendChild(actions);
            wrap.appendChild(row);
            fillThumbnail(img,it);
          }
          root.appendChild(wrap);
        }
        buildPagination(currentPage,totalPages);
      }
      function buildPagination(page,totalPages){
        if (DEBUG_MODE) console.log('Debug: buildPagination called with page:', page, 'totalPages:', totalPages);
        const pag=document.querySelector('.pagination');
        if(!pag) return;
        pag.innerHTML='';
        const info=document.createElement('div');
        info.className='pagination-info';
        info.textContent='';
        pag.appendChild(info);
        const prev=document.createElement('button');
        prev.className='pagination-btn';
        prev.textContent=i18n.t('pagination.previous');
        prev.disabled=page<=1;
        prev.addEventListener('click',()=>{ if(currentPage>1){ currentPage--; updatePageParam(); renderHistory(); } });
        pag.appendChild(prev);
        const maxButtons=5;
        let start=Math.max(1,page-2);
        let end=Math.min(totalPages,start+maxButtons-1);
        if(end-start+1<maxButtons){ start=Math.max(1,end-maxButtons+1); }
        if(start>1){
          const first=document.createElement('button');
          first.className='pagination-btn';
          first.textContent='1';
          first.addEventListener('click',()=>{ currentPage=1; updatePageParam(); renderHistory(); });
          pag.appendChild(first);
          if(start>2){ const dots=document.createElement('span'); dots.textContent=' ... '; pag.appendChild(dots); }
        }
        for(let i=start;i<=end;i++){
          const b=document.createElement('button');
          b.className='pagination-btn'+(i===page?' active':'');
          b.textContent=String(i);
          b.addEventListener('click',()=>{ currentPage=i; updatePageParam(); renderHistory(); });
          pag.appendChild(b);
        }
        if(end<totalPages){
          if(end<totalPages-1){ const dots=document.createElement('span'); dots.textContent=' ... '; pag.appendChild(dots); }
          const last=document.createElement('button');
          last.className='pagination-btn';
          last.textContent=String(totalPages);
          last.addEventListener('click',()=>{ currentPage=totalPages; updatePageParam(); renderHistory(); });
          pag.appendChild(last);
        }
        const next=document.createElement('button');
        next.className='pagination-btn';
        next.textContent=i18n.t('pagination.next');
        next.disabled=page>=totalPages;
        next.addEventListener('click',()=>{ if(currentPage<totalPages){ currentPage++; updatePageParam(); renderHistory(); } });
        pag.appendChild(next);
      }
      document.getElementById('headerSearchBtn').addEventListener('click',()=>{const q=(document.getElementById('headerSearchInput').value||'').trim();if(q)window.location.href=`youvi_search.html?q=${encodeURIComponent(q)}&type=videos`;});
      document.getElementById('headerSearchInput').addEventListener('keydown',(e)=>{if(e.key==='Enter'){const q=(e.target.value||'').trim();if(q)window.location.href=`youvi_search.html?q=${encodeURIComponent(q)}&type=videos`;}});
      const filterTodayBtn=document.getElementById('filterToday');
      const filterWeekBtn=document.getElementById('filterWeek');
      const filterMonthBtn=document.getElementById('filterMonth');
      const filterAllBtn=document.getElementById('filterAll');
      if(filterTodayBtn) filterTodayBtn.addEventListener('click',(e)=>{e.preventDefault();if (DEBUG_MODE) console.log('Debug: filterToday clicked');currentFilter='today';currentPage=1;updatePageParam();setActiveFilterButton('today');renderHistory();});
      if(filterWeekBtn) filterWeekBtn.addEventListener('click',(e)=>{e.preventDefault();if (DEBUG_MODE) console.log('Debug: filterWeek clicked');currentFilter='week';currentPage=1;updatePageParam();setActiveFilterButton('week');renderHistory();});
      if(filterMonthBtn) filterMonthBtn.addEventListener('click',(e)=>{e.preventDefault();if (DEBUG_MODE) console.log('Debug: filterMonth clicked');currentFilter='month';currentPage=1;updatePageParam();setActiveFilterButton('month');renderHistory();});
      if(filterAllBtn) filterAllBtn.addEventListener('click',(e)=>{e.preventDefault();if (DEBUG_MODE) console.log('Debug: filterAll clicked');currentFilter='all';currentPage=1;updatePageParam();setActiveFilterButton('all');renderHistory();});
      async function setPauseBtn(){
        try{
          if (DEBUG_MODE) console.log('Debug: setPauseBtn: starting');
          const s=await loadSettings();
          const paused=!!(s&&s.historyPaused);
          if (DEBUG_MODE) console.log('Debug: setPauseBtn: settings:', s, 'paused:', paused);
          
          const btn = document.getElementById('pauseHistory');
          if (btn) {
            btn.textContent=paused?'Возобновить историю':'Приостановить историю';
            if (DEBUG_MODE) console.log('Debug: setPauseBtn: button text updated to:', btn.textContent);
          }else{
            if (DEBUG_MODE) console.log('Debug: setPauseBtn: pause button not found');
          }
        }catch(e){
          if (DEBUG_MODE) console.log('Debug: setPauseBtn: error:', e);
        }
      }
      document.getElementById('pauseHistory').addEventListener('click',async(e)=>{e.preventDefault();const s=await loadSettings();const paused=!!(s&&s.historyPaused);await saveSettings({historyPaused:!paused});setPauseBtn();});
      const privacyBtn=document.getElementById('privacySettings');
      if(privacyBtn){privacyBtn.addEventListener('click',async(e)=>{e.preventDefault();const s=await loadSettings();const paused=!!(s&&s.historyPaused);await saveSettings({historyPaused:!paused});setPauseBtn();});}
      document.getElementById('clearAll').addEventListener('click',async(e)=>{e.preventDefault();if(!confirm('Вы уверены, что хотите очистить всю историю просмотра? Это действие нельзя отменить.')) return;await saveHistory([]);invalidateCaches();renderHistory();updateStats();});
      
      const clearTodayBtn = document.getElementById('clearToday');
      if(clearTodayBtn) clearTodayBtn.addEventListener('click',async(e)=>{e.preventDefault();if(!confirm('Очистить историю за сегодня?')) return;await clearRange(0);});
      
      const clearWeekBtn = document.getElementById('clearWeek');
      if(clearWeekBtn) clearWeekBtn.addEventListener('click',async(e)=>{e.preventDefault();if(!confirm('Очистить историю за неделю?')) return;await clearRange(7);});
      
      async function clearRange(days){
          if (DEBUG_MODE) console.log('Debug: clearRange called with days:', days);
          const arr = await loadHistory();
          const now = new Date();
          const fromTs = days===0 ? new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime() : now.getTime() - days*24*60*60*1000;
          
          if (DEBUG_MODE) console.log('Debug: clearRange: now:', now);
          if (DEBUG_MODE) console.log('Debug: clearRange: fromTs:', new Date(fromTs));
          
          const filtered = arr.filter(it=>{
              const t = it.lastWatchedAt || it.addedAt || 0;
              if (days===0){
                  const d = new Date(t);
                  const isToday = (d.getFullYear()===now.getFullYear() && d.getMonth()===now.getMonth() && d.getDate()===now.getDate());
                  if (DEBUG_MODE) console.log('Debug: clearRange: item', it.name, 'timestamp:', t, 'date:', d, 'isToday:', isToday);
                  return !isToday;
              }
              const isOlder = t < fromTs;
              if (DEBUG_MODE) console.log('Debug: clearRange: item', it.name, 'timestamp:', t, 'isOlder:', isOlder);
              return isOlder;
          });
          
          if (DEBUG_MODE) console.log('Debug: clearRange: original count:', arr.length, 'filtered count:', filtered.length);
          
          await saveHistory(filtered);
          invalidateCaches();
          await renderHistory();
          updateStats();
      }

      async function loadAllVideosAndPlaylistsForAutocomplete() {
        if (typeof AutocompleteDataLoader === 'undefined') {
          console.error('[Autocomplete] AutocompleteDataLoader module not loaded');
          return { videos: [], playlists: [] };
        }
        
        const result = await AutocompleteDataLoader.loadData();
        return { videos: result.videos || [], playlists: result.playlists || [] };
      }

        async function startHistory(){
          if (DEBUG_MODE) console.log('Debug: init started');
          await initVideoHandle();
          await setPauseBtn();
          readInitialPage(); 
          currentQuery = '';
          if (DEBUG_MODE) console.log('Debug: init: setting initial filter to "all"');
          setActiveFilterButton('all');
          if (DEBUG_MODE) console.log('Debug: init: calling renderHistory');
          renderHistory();
          updateStats();
          renderSubscribedChannelsList();

            if (window.i18n && typeof window.i18n.subscribe === 'function') {
              window.i18n.subscribe(() => {
                  statsCache = {};
                renderHistory();
                updateStats();
              });
            }

            let lastLang = window.i18n ? window.i18n.getCurrentLanguage() : 'ru';
            setInterval(async () => {
              try {
                const stored = localStorage.getItem('youvi_language') || 'ru';
                if (stored !== lastLang && window.i18n) {
                  lastLang = stored;
                  await window.i18n.setLanguage(stored);
                  renderHistory();
                  updateStats();
                }
              } catch (e) {}
            }, 1000);
          
          try {
            const searchInput = document.getElementById('headerSearchInput');
            if (searchInput && typeof AutocompleteIntegration !== 'undefined' && typeof YouviAutocomplete !== 'undefined') {
              const { videos, playlists } = await loadAllVideosAndPlaylistsForAutocomplete();
              
              const cacheValid = await window.autocompleteCache.isCacheValid(
                videos.length,
                playlists.length
              );
              
              const autocompleteIntegration = new AutocompleteIntegration();
              await autocompleteIntegration.init(searchInput, {
                videoDirectoryHandle: videoDirectoryHandle,
                allVideos: cacheValid ? [] : videos,
                allPlaylists: cacheValid ? [] : playlists
              });
              if (DEBUG_MODE) console.log('[Autocomplete] ✅ Initialized on youvi_history.html');
            }
          } catch (error) {
            console.error('[Autocomplete] Failed to initialize:', error);
          }
          
            if (DEBUG_MODE) console.log('Debug: init completed');
          }

      function searchByTag(tag) {
          if (DEBUG_MODE) console.log('Search by tag:', tag);
      }

      async function loadSubscriptionsFromFile() {
        try {
          const localSubscriptions = localStorage.getItem('8site_subscriptions');
          if (localSubscriptions) {
            return JSON.parse(localSubscriptions);
          }

          if (!videoDirectoryHandle) return null;

          const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
          const file = await subscriptionsFile.getFile();
          const text = await file.text();
          const fileSubscriptions = JSON.parse(text);

          localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
          return fileSubscriptions;
        } catch (e) {
          if (DEBUG_MODE) console.log('No subscriptions found, using default');
          return null;
        }
      }

      async function renderSubscribedChannelsList() {
        const sidebarContainer = document.getElementById('subscribedChannelsContainer');
        if (!sidebarContainer) return;

        try {
          const savedSubscriptions = await loadSubscriptionsFromFile();
          const subscribedChannels = Array.isArray(savedSubscriptions) ? savedSubscriptions : [];

          sidebarContainer.innerHTML = '';

          if (subscribedChannels.length === 0) {
            const noSubs = document.createElement('div');
            noSubs.className = 'sidebar-item';
            noSubs.textContent = 'Нет подписок';
            noSubs.style.fontStyle = 'italic';
            noSubs.style.color = '#999';
            sidebarContainer.appendChild(noSubs);
            return;
          }

          subscribedChannels.forEach((channelName, index) => {
            const link = document.createElement('a');
            link.href = '#';
            link.className = 'sidebar-item';
            link.dataset.channel = channelName;
            link.id = `sidebar_channel_${index}`;
            link.style.display = 'flex';
            link.style.alignItems = 'center';
            link.style.gap = '8px';

            const avatar = document.createElement('div');
            avatar.style.cssText = `
              width: 20px;
              height: 20px;
              background: #ff69b4;
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-weight: bold;
              font-size: 10px;
              flex-shrink: 0;
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              cursor: pointer;
            `;
            avatar.textContent = channelName.charAt(0).toUpperCase();
            avatar.title = 'Перейти к каналу';

            const textSpan = document.createElement('span');
            textSpan.textContent = channelName;
            textSpan.style.overflow = 'hidden';
            textSpan.style.textOverflow = 'ellipsis';
            textSpan.style.whiteSpace = 'nowrap';
            textSpan.style.flex = '1';

            link.appendChild(avatar);
            link.appendChild(textSpan);

            avatar.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
            });

            textSpan.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              window.location.href = 'youvi_subscriptions.html';
            });

            loadChannelAvatar(channelName).then(avatarUrl => {
              if (avatarUrl) {
                avatar.style.backgroundImage = `url(${avatarUrl})`;
                avatar.textContent = '';
              }
            }).catch(() => {
            });

            sidebarContainer.appendChild(link);
          });
        } catch (e) {
          console.error('Error loading subscriptions:', e);
          sidebarContainer.innerHTML = '<div class="sidebar-item" style="font-style: italic; color: #999;">Ошибка загрузки</div>';
        }
      }

      const avatarCache = new Map();

      async function loadChannelAvatar(channelName) {
        const cacheKey = `avatar_${channelName}`;
        if (avatarCache.has(cacheKey)) {
          const cached = avatarCache.get(cacheKey);
          if (Date.now() - cached.timestamp < 300000) {
            return cached.url;
          }
          if (cached.url && cached.url.startsWith('blob:')) {
            URL.revokeObjectURL(cached.url);
          }
          avatarCache.delete(cacheKey);
        }

        try {
          const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
          const channelDir = await channelsDir.getDirectoryHandle(channelName, { create: true });

          const channelData = await readJSONFile(channelDir, 'channel.json', {});
          let avatarUrl = null;

          if (channelData.avatar) {
            avatarUrl = await loadImageFile(channelDir, channelData.avatar);
          }

          avatarCache.set(cacheKey, {
            url: avatarUrl,
            timestamp: Date.now()
          });

          return avatarUrl;
        } catch (e) {
          avatarCache.set(cacheKey, {
            url: null,
            timestamp: Date.now()
          });
          return null;
        }
      }

      async function readJSONFile(dirHandle, name, defaultValue = null) {
        try {
          const fileHandle = await dirHandle.getFileHandle(name);
          const file = await fileHandle.getFile();
          const text = await file.text();
          return JSON.parse(text);
        } catch (e) {
          return defaultValue;
        }
      }

      async function loadImageFile(dirHandle, name) {
        try {
          const fileHandle = await dirHandle.getFileHandle(name);
          const file = await fileHandle.getFile();
          return URL.createObjectURL(file);
        } catch (e) {
          return null;
        }
      }

      let statsCache = {
        data: null,
        timestamp: 0,
        listLength: 0
      };
      
      async function updateStats(){
          try{
              if (DEBUG_MODE) console.log('Debug: updateStats called');
              const list = await loadHistory();
              const now = Date.now();
              
              if (statsCache.data && 
                  statsCache.listLength === list.length &&
                  (now - statsCache.timestamp) < 60000) {
                
                if (DEBUG_MODE) console.log('Debug: updateStats: using cached result');
                const box = document.querySelector('.right-sidebar .stats-box');
                if (box) {
                  box.innerHTML = statsCache.data;
                }
                return;
              }
              
              if (DEBUG_MODE) console.log('Debug: updateStats: calculating new result for', list.length, 'items');
              
              const dateNow = new Date();
              const startOfToday = new Date(dateNow.getFullYear(), dateNow.getMonth(), dateNow.getDate()).getTime();
              const weekAgo = dateNow.getTime() - 7*24*60*60*1000;
              const monthAgo = dateNow.getTime() - 30*24*60*60*1000;
              let today=0, week=0, month=0, total=list.length;
              
              if (DEBUG_MODE) console.log('Debug: updateStats: startOfToday:', new Date(startOfToday));
              if (DEBUG_MODE) console.log('Debug: updateStats: weekAgo:', new Date(weekAgo));
              if (DEBUG_MODE) console.log('Debug: updateStats: monthAgo:', new Date(monthAgo));
              
              for (const it of list){
                  const t = it.lastWatchedAt || it.addedAt || 0;
                  if (t >= startOfToday) today++;
                  if (t >= weekAgo) week++;
                  if (t >= monthAgo) month++;
              }
              
              if (DEBUG_MODE) console.log('Debug: updateStats: today:', today, 'week:', week, 'month:', month, 'total:', total);
              
              const statsHTML = `<div style="margin-bottom: 5px;"><strong>${i18n.t('history.todayStats')}:</strong> ${today} ${i18n.t('history.videoCount')}</div>
                  <div style="margin-bottom: 5px;"><strong>${i18n.t('history.weekStats')}:</strong> ${week} ${i18n.t('history.videoCount')}</div>
                  <div style="margin-bottom: 5px;"><strong>${i18n.t('history.monthStats')}:</strong> ${month} ${i18n.t('history.videoCount')}</div>
                  <div><strong>${i18n.t('history.totalInHistory')}:</strong> ${total}</div>`;
              
              const box = document.querySelector('.right-sidebar .stats-box');
              if (box){
                  box.innerHTML = statsHTML;
              }
              
              statsCache = {
                data: statsHTML,
                timestamp: now,
                listLength: list.length
              };
          }catch(e){
              if (DEBUG_MODE) console.log('Debug: updateStats error:', e);
          }
      }

      function escapeHtml(str){
        return String(str)
          .replace(/&/g,'&amp;')
          .replace(/</g,'&lt;')
          .replace(/>/g,'&gt;')
          .replace(/"/g,'&quot;')
          .replace(/'/g,'&#039;');
      }
      function timecodeToSeconds(code){
        const parts = code.split(':').map(n=>parseInt(n,10));
        if(parts.length===3){ const [h,m,s]=parts; if(h>=0&&m>=0&&m<60&&s>=0&&s<60) return h*3600+m*60+s; }
        if(parts.length===2){ const [m,s]=parts; if(m>=0&&s>=0&&s<60) return m*60+s; }
        return null;
      }
      function linkifyTimecodes(htmlText, baseUrl){
        const re=/(\b(?:[0-9]{1,2}:)?[0-5]?\d:[0-5]\d\b)/g;
        return htmlText.replace(re,(m)=>{
          const sec=timecodeToSeconds(m);
          if(sec==null) return m;
          const url = baseUrl + (baseUrl.includes('?')?'&':'?') + 't=' + sec;
          return `<a class="timecode" href="${url}">${m}</a>`;
        });
      }
    </script>
    
    <!-- Autocomplete Module -->
    <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
    <script src="youvi/autocomplete-data-loader.js"></script>
    <script src="youvi/autocomplete/autocomplete-cache.js"></script>
    <script src="youvi/autocomplete/autocomplete.js"></script>
    <script src="youvi/autocomplete/autocomplete-integration.js"></script>
    
    <script src="youvi/themes/theme-toggle.js"></script>
    
    <!-- i18n Support -->
    <script src="youvi/i18n/ru.js"></script>
    <script src="youvi/i18n/en.js"></script>
    <script src="youvi/i18n/uk.js"></script>
    <script src="youvi/i18n/i18n.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        if (typeof startHistory === 'function') {
          startHistory();
        }
      });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const langSwitcher = document.getElementById('langSwitcher');
            
            if (langSwitcher) {
                langSwitcher.value = i18n.getCurrentLanguage();
                
                langSwitcher.addEventListener('change', async function(e) {
                    const newLang = e.target.value;
                    await i18n.setLanguage(newLang);
                    statsCache = {};
                    renderHistory();
                    updateStats();
                });
            }
        });
    </script>
</body>
</html>