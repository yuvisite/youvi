<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Youvi</title>

    <script>
        (function () {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            var wideMode = localStorage.getItem('youvi_wide_mode');
            var c = [];
            if (theme === 'dark') c.push('dark-theme');
            else if (theme === 'skeuo') c.push('skeuo-theme');
            if (sidebar === 'true') c.push('sidebar-collapsed');
            if (wideMode === 'true') c.push('wide-screen-mode');
            if (c.length) document.documentElement.className = c.join(' ');
        })();
    </script>

    <!-- Critical CSS loaded first, non-critical deferred -->
    <link rel="preload" href="player/danmaku/danmaku.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="player/danmaku/danmaku.css">
    </noscript>
    <link rel="stylesheet" href="player/danmaku/danmaku-density.css">
    <link rel="preload" href="player/mini-player/mini-player.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="player/mini-player/mini-player.css">
    </noscript>
    <link rel="preload" href="player/drag-seek/drag-seek.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="player/drag-seek/drag-seek.css">
    </noscript>
    
    <!-- Subtitle Track Manager CSS -->
    <link rel="stylesheet" href="player/subtitles/subtitles.css">


    <link rel="preload" href="youvi_video_comments.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="youvi_video_comments.css">
    </noscript>

    <!-- Comment Images CSS -->
    <link rel="stylesheet" href="youvi/comments/comment-images.css">

    <!-- Tag Types Module CSS -->
    <link rel="stylesheet" href="youvi/tag-types/tag-types.css">

    <!-- Kaomoji Picker CSS -->
    <link rel="stylesheet" href="youvi/kaomoji-picker/kaomoji-picker.css">

    <!-- Theme System - defer loading -->
    <link rel="preload" href="youvi/dark-theme.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="youvi/dark-theme.css">
    </noscript>

    <link rel="preload" href="youvi/themes/skeuo-theme.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="youvi/themes/skeuo-theme.css">
    </noscript>

    <link rel="preload" href="youvi/themes/theme-dropdown.css" as="style"
        onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    </noscript>

    <!-- Header styles -->
    <link rel="preload" href="youvi/header/youvi-header.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript>
        <link rel="stylesheet" href="youvi/header/youvi-header.css">
    </noscript>
    <!-- Sticky layout for header + left sidebar -->
    <link rel="stylesheet" href="youvi/sticky-video.css">

    <!-- Wide Screen Mode -->
    <link rel="stylesheet" href="youvi/widescreen-mode.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: Arial, sans-serif;
            background: #fff;
            color: #111
        }

        .top-nav {
            background: #d94b88;
            border-bottom: 1px solid #c2185b;
            padding: 4px 0
        }

        .top-nav-content {
            max-width: none;
            margin: 0;
            padding: 0 20px;
            display: flex;
            gap: 20px;
            align-items: center
        }

        .top-nav a {
            color: #fff;
            text-decoration: none;
            font-size: 12px;
            padding: 2px 0;
            transition: color 0.2s
        }

        .top-nav a:hover {
            color: #ffd6ea
        }

        .top-nav a.active {
            color: #ffd6ea;
            font-weight: 600
        }

        .lang-switcher { margin-left: auto; }
        .lang-select { background: transparent; border: 1px solid rgba(255, 255, 255, 0.3); color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 11px; cursor: pointer; outline: none; }
        .lang-select:hover { border-color: rgba(255, 255, 255, 0.5); }
        .lang-select option { background: #d94b88; color: #fff; }

        .header {
            background: #FFE7F4;
            padding: 0;
            border-bottom: 1px solid #f2cfe1;
            min-height: 40px;
            width: 100%
        }

        .header-content-wrapper {
            display: flex;
            align-items: center;
            position: relative;
            box-sizing: border-box;
            max-width: none;
            margin: 0;
            padding: 0 20px;
            width: 100%;
            min-height: 40px;
            z-index: 100
        }

        .sidebar-toggle-btn {
            width: 32px;
            height: 32px;
            background: transparent;
            border: none;
            border-radius: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #111;
            transition: background-color 0.2s;
            margin-right: 10px;
            flex-shrink: 0;
            position: relative;
            z-index: 1000
        }

        .sidebar-toggle-btn:hover {
            background: transparent
        }

        .sidebar-toggle-btn svg {
            width: 16px;
            height: 16px;
            fill: #111;
            pointer-events: none
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 90px;
            flex-shrink: 0;
            height: 40px;
            position: relative;
            z-index: 99
        }

        .logo img {
            height: 30px;
            width: auto
        }

        .search-area {
            flex: 1;
            display: flex;
            justify-content: flex-start;
            gap: 8px;
            max-width: 600px;
            margin: 0 0 0 80px;
            min-width: 300px;
            position: relative;
            z-index: 99;
            transition: margin-left 0.25s ease
        }

        .search-input {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 13px;
            min-width: 280px;
            height: 32px
        }

        .search-btn {
            padding: 6px 14px;
            background: #ff69b4;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            height: 32px;
            display: flex;
            align-items: center;
            transition: background-color 0.2s
        }

        .search-btn:hover {
            background: #ff85c3
        }

        .user-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: auto;
            flex-shrink: 0
        }

        .user-actions a,
        .settings-btn {
            color: #111;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
            background: none;
            border: none;
            cursor: pointer;
            position: relative
        }

        .user-actions a:hover,
        .settings-btn:hover {
            background: rgba(255, 105, 180, 0.1)
        }

        .settings-container {
            position: relative;
            display: inline-block;
            z-index: 99999 !important;
            isolation: isolate
        }

        .settings-btn {
            padding: 4px 8px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .container {
            display: flex;
            width: 100%;
            margin: 0;
            gap: 20px;
            padding: 0 20px 0 20px;
            align-items: stretch;
            min-height: calc(100vh - 40px - 40px)
        }

        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1500px;
            margin: 0 auto;
            gap: 20px
        }

        .main-content {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            padding-top: 5px
        }

        .sidebar-collapsed .sidebar {
            width: 0;
            padding: 0;
            overflow: hidden;
            top: 40px !important
        }

        .sidebar-collapsed .container {
            padding-left: 20px
        }

        .sidebar-collapsed .main-content {
            margin-left: 0
        }

        .sidebar-collapsed .search-area {
            margin-left: 80px
        }

        .sidebar-collapsed .content-wrapper {
            max-width: 1500px
        }

        .player-section {
            background: white;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px
        }

        .video-player {
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .player-placeholder {
            color: #666;
            font-size: 18px
        }

        .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 48px;
            height: 48px;
            margin: -24px 0 0 -24px;
            border: 3px solid rgba(255, 105, 180, 0.25);
            border-top-color: #ff69b4;
            border-radius: 50%;
            animation: spin 0.9s linear infinite;
            z-index: 20;
            pointer-events: none;
            display: none
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }


        .video-info {
            background: white;
            border-radius: 4px;
            padding: 15px;
            padding-top: 20px;
            margin-top: 15px;
            margin-bottom: 15px
        }

        .video-title {
            font-size: 18px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
            line-height: 1.4
        }

        .video-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 2px 0 2px;
            align-items: center
        }

        .video-tag {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            color: #333
        }

        .edit-tags-btn {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            color: #333;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
            cursor: pointer;
            text-decoration: none
        }

        .edit-tags-btn:hover {
            background: #f5f5f5;
            border-color: #ff69b4;
            color: #ff69b4
        }

        .edit-tags-btn svg {
            width: 10px;
            height: 10px;
            flex-shrink: 0
        }

        .tags-edit-form {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 6px;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px
        }

        .tags-edit-controls {
            flex: 1
        }

        .tags-edit-controls input {
            width: 100%;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box
        }

        .tags-edit-actions {
            display: flex;
            gap: 5px
        }

        .tags-edit-cancel,
        .tags-edit-save {
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            transition: all 0.2s
        }

        .tags-edit-cancel {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #ddd
        }

        .tags-edit-cancel:hover {
            background: #e5e5e5
        }

        .tags-edit-save {
            background: #ff69b4;
            color: #fff
        }

        .tags-edit-save:hover {
            background: #d94b88
        }

        .video-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 11px;
            color: #999;
            margin-bottom: 15px
        }

        .video-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 10px
        }

        .channel-info-left {
            display: flex;
            align-items: center;
            gap: 10px
        }

        .actions-right {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .action-btn {
            background: none;
            border: 1px solid #ddd;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s
        }

        .action-btn:hover {
            background: #f5f5f5;
            border-color: #ff69b4;
            color: #ff69b4
        }

        .action-btn.liked {
            background: #ff69b4;
            color: white;
            border-color: #ff69b4
        }

        .video-description {
            background: white;
            border-radius: 4px;
            padding: 6px;
            margin-bottom: 8px;
            border: 1px solid #eee
        }

        .description-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            cursor: pointer;
            position: relative
        }

        .description-header h3 {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin: 0;
            line-height: 1.2;
            flex: 1
        }

        .description-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .description-toggle:hover {
            background: #f5f5f5;
            color: #ff69b4
        }

        .description-toggle svg {
            width: 16px;
            height: 16px;
            transition: transform 0.2s
        }

        .description-toggle.collapsed svg {
            transform: rotate(-90deg)
        }

        .description-content {
            overflow: hidden;
            transition: max-height 0.3s ease
        }

        .description-content.collapsed {
            max-height: 0
        }

        .description-content.expanded {
            max-height: none;
            overflow: visible
        }

        .uploader-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px
        }

        .uploader-avatar {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            background: #ff69b4;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            flex-shrink: 0;
            font-size: 16px
        }

        .uploader-name {
            font-size: 14px;
            color: #333;
            font-weight: 500
        }

        .subscribe-btn {
            background: #ff69b4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 0;
            flex-shrink: 0
        }

        .subscribe-btn:hover {
            background: #d94b88
        }

        .subscribe-btn.subscribed {
            background: #999
        }

        .description-text {
            font-size: 13px;
            color: #111;
            line-height: 1.5;
            white-space: pre-line
        }

        .time-code {
            color: #ff69b4;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: none;
            border: none;
            padding: 1px 2px;
            border-radius: 2px;
            text-decoration: none;
            display: inline-block
        }

        .time-code:hover {
            background: #ff69b4;
            color: #fff;
            padding: 1px 2px;
            border-radius: 2px
        }

        .description-edit-form {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 6px;
            margin-top: 8px;
            display: none
        }

        .description-edit-controls {
            flex: 1
        }

        .description-edit-controls textarea {
            width: 100%;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            min-height: 80px;
            resize: vertical;
            font-family: inherit
        }

        .description-edit-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px
        }

        .description-edit-cancel,
        .description-edit-save {
            padding: 3px 8px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            border: none;
            transition: all 0.2s
        }

        .description-edit-cancel {
            background: #f5f5f5;
            color: #666;
            border: 1px solid #ddd
        }

        .description-edit-cancel:hover {
            background: #e5e5e5
        }

        .description-edit-save {
            background: #ff69b4;
            color: #fff
        }

        .description-edit-save:hover {
            background: #d94b88
        }

        .edit-description-btn {
            background: none;
            border: none;
            padding: 2px;
            font-size: 11px;
            color: #666;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
            text-decoration: none;
            border-radius: 3px
        }

        .edit-description-btn:hover {
            background: #f5f5f5;
            color: #ff69b4
        }

        .edit-description-btn svg {
            width: 12px;
            height: 12px;
            flex-shrink: 0
        }

        .description-toggle {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .right-sidebar {
            width: 325px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            padding-top: 5px;
            gap: 10px;
        }

        .playlist-section-header,
        .video-carousel-wrapper {
            display: none !important
        }

        .sidebar-section-right {
            background: #fafafa;
            border-radius: 4px;
            overflow: hidden
        }

        .section-title-right {
            padding: 4px 12px;
            background: #f5f5f5;
            font-size: 11px;
            font-weight: 600;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center
        }

        #recommendationsSidebar {
            background: transparent !important;
            border: none !important
        }

        #recommendationsSidebar .section-title-right {
            background: transparent !important;
            border-bottom: none !important
        }

        .sidebar-panel-combined {
            display: flex;
            flex-direction: column;
            background: #fafafa;
            border-radius: 8px;
            overflow: hidden;
            min-height: 400px;
            border: 1px solid #e0e0e0;
        }

        .sidebar-panel-tabs {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f0f0f0;
            padding: 0;
            gap: 0;
            flex-shrink: 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .sidebar-tabs-left {
            display: flex;
            align-items: center;
        }

        .sidebar-panel-tab {
            padding: 8px 12px;
            background: transparent;
            border: none;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }

        .sidebar-panel-tab:hover {
            color: #333;
            background: rgba(255, 105, 180, 0.05);
        }

        .sidebar-panel-tab.active {
            color: #ff69b4;
            background: #fafafa;
            border-bottom-color: #ff69b4;
        }

        .sidebar-panel-tab span {
            margin-left: 4px;
            color: inherit;
        }

        .sidebar-panel-tab.active span {
            color: #ff69b4;
        }

        .sidebar-panel-controls {
            display: flex;
            align-items: center;
            gap: 2px;
            padding: 0 8px;
        }

        .sidebar-panel-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .sidebar-panel-btn:hover {
            color: #666;
            background: rgba(0, 0, 0, 0.05);
        }

        .sidebar-panel-btn.active {
            color: #ff69b4;
        }

        .sidebar-panel-btn.rotated svg {
            transform: rotate(180deg);
        }

        .sidebar-panel-btn svg {
            width: 14px;
            height: 14px;
        }

        .sidebar-panel-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }

        .sidebar-tab-content {
            display: none;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            background: #fafafa;
        }
        
        #playlistTabContent {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #playlistContent {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        #playlistContent::-webkit-scrollbar {
            width: 4px;
        }
        
        #playlistContent::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #playlistContent::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.3);
            border-radius: 2px;
        }
        
        #playlistContent::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 105, 180, 0.5);
        }

        .sidebar-tab-content.active {
            display: block;
        }
        
        .playlist-control-btn {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: all 0.2s;
        }
        
        .playlist-control-btn:hover {
            border-color: #ff69b4;
            color: #ff69b4;
        }
        
        .playlist-control-btn.active {
            background: #ff69b4;
            border-color: #ff69b4;
            color: #fff;
        }
        
        .dark-theme .playlist-control-btn {
            background: #2a2a2a;
            border-color: #444;
            color: #999;
        }
        
        .dark-theme .playlist-control-btn:hover {
            border-color: #ff69b4;
            color: #ff69b4;
        }
        
        .dark-theme .playlist-control-btn.active {
            background: #ff69b4;
            border-color: #ff69b4;
            color: #fff;
        }
        
        .dark-theme #playlistHeader {
            background: #252525 !important;
            border-color: #333 !important;
        }
        
        .dark-theme #playlistTitle {
            color: #ccc !important;
        }
        
        .dark-theme #playlistOpenLink {
            color: #777 !important;
        }
        
        .dark-theme #playlistOpenLink:hover {
            color: #ff69b4 !important;
        }

        .sidebar-tab-content::-webkit-scrollbar {
            width: 4px;
        }

        .sidebar-tab-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar-tab-content::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.3);
            border-radius: 2px;
        }

        .sidebar-tab-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 105, 180, 0.5);
        }

        .dark-theme .sidebar-panel-combined {
            background: #1e1e1e;
            border-color: #333;
        }

        .dark-theme .sidebar-panel-tabs {
            background: #252525;
            border-bottom-color: #333;
        }

        .dark-theme .sidebar-panel-tab {
            color: #999;
        }

        .dark-theme .sidebar-panel-tab:hover {
            color: #ccc;
            background: rgba(255, 105, 180, 0.1);
        }

        .dark-theme .sidebar-panel-tab.active {
            color: #ff69b4;
            background: #1e1e1e;
        }

        .dark-theme .sidebar-panel-btn {
            color: #777;
        }

        .dark-theme .sidebar-panel-btn:hover {
            color: #ccc;
            background: rgba(255, 255, 255, 0.1);
        }

        .dark-theme .sidebar-panel-btn.active {
            color: #ff69b4;
        }

        .dark-theme .sidebar-tab-content {
            background: #1e1e1e;
        }

        .dark-theme .sidebar-tab-content::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.4);
        }

        .dark-theme .sidebar-tab-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 105, 180, 0.6);
        }

        .right-sidebar-collapse-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .right-sidebar-collapse-btn:hover {
            color: #666;
            background: rgba(0, 0, 0, 0.05);
        }

        .right-sidebar-collapse-btn svg {
            width: 14px;
            height: 14px;
            transition: transform 0.2s;
        }

        .dark-theme .right-sidebar-collapse-btn {
            color: #777;
        }

        .dark-theme .right-sidebar-collapse-btn:hover {
            color: #ccc;
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-panel-combined.collapsed {
            min-height: 0 !important;
            height: auto !important;
            flex: 0 0 auto !important;
        }

        .sidebar-panel-combined.collapsed .sidebar-panel-content {
            height: 0 !important;
            min-height: 0 !important;
            flex: 0 0 0 !important;
            overflow: hidden !important;
            visibility: hidden;
        }

        .sidebar-panel-combined.collapsed ~ #recommendationsSidebar {
            flex: 1;
        }

        .right-sidebar-collapse-btn svg {
            transform: rotate(-90deg);
        }

        .sidebar-panel-combined.collapsed .right-sidebar-collapse-btn svg {
            transform: rotate(90deg);
        }

        .dark-theme #playlistContent::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.4);
        }
        
        .dark-theme #playlistContent::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 105, 180, 0.6);
        }

        .dark-theme .danmaku-comment-item {
            border-bottom-color: #333;
        }

        .dark-theme .danmaku-comment-item:hover {
            background-color: #2a2a2a !important;
        }

        .dark-theme .danmaku-comment-item.current {
            background-color: rgba(255, 105, 180, 0.2) !important;
        }

        .playlist-toggle-btn {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 3px;
            border-radius: 3px;
            transition: color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .playlist-toggle-btn:hover {
            color: #ff69b4
        }

        .playlist-toggle-btn svg {
            transition: transform 0.2s
        }

        .playlist-toggle-btn.rotated svg {
            transform: rotate(180deg)
        }

        .danmaku-comment-item {
            transition: background-color 0.2s
        }

        .danmaku-comment-item:hover {
            background-color: #f8f8f8 !important
        }

        .danmaku-comment-item.current {
            background-color: rgba(255, 105, 180, 0.15) !important;
        }

        .related-video {
            display: flex;
            padding: 10px;
            gap: 10px;
            border-bottom: none;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 6px;
            margin-bottom: 8px;
            background: transparent;
            box-shadow: none
        }

        .related-video:hover {
            background: #f8f8f8 !important;
            box-shadow: none;
            transform: none
        }

        .related-thumb {
            width: 120px;
            height: 68px;
            background: #f0f0f0;
            border-radius: 6px;
            position: relative;
            flex-shrink: 0;
            overflow: hidden
        }

        .related-duration {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 4px;
            font-size: 10px;
            border-radius: 2px
        }

        .related-info {
            flex: 1;
            min-width: 0;
            padding: 0 5px
        }

        .related-title {
            font-size: 13px;
            color: #111;
            line-height: 1.3;
            margin-bottom: 3px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            font-weight: 500
        }

        .related-meta {
            font-size: 11px;
            color: #666;
            margin-bottom: 2px
        }

        .video-player-wrapper {
            display: flex;
            gap: 20px;
            margin-bottom: 20px
        }

        .video-player {
            flex: 2;
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            contain: layout style paint
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            contain: layout style paint
        }

        .video-player video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            will-change: auto
        }

        .video-player video::-webkit-media-controls,
        .video-player video::-webkit-media-controls-picture-in-picture-button,
        .video-player video::-webkit-media-controls-enclosure {
            display: none !important
        }

        .video-clock {
            position: absolute;
            top: 4%;
            left: 5%;
            color: white;
            font-size: 18px;
            font-weight: bold;
            font-family: monospace;
            border-radius: 4px;
            z-index: 25;
            pointer-events: none;
            opacity: 0.9;
            transition: all 0.2s ease;
            display: none
        }

        .video-container.fullscreen .video-clock {
            font-size: 28px;
            top: 3%;
            left: 4%
        }

        body.cinema-mode .video-clock {
            font-size: 22px;
            top: 3.5%;
            left: 4%
        }

        .video-clock.blinking .clock-colon {
            animation: colonBlink 1s infinite
        }

        .video-clock.blinking.paused .clock-colon {
            animation-play-state: paused
        }

        @keyframes colonBlink {

            0%,
            50% {
                opacity: 1
            }

            51%,
            100% {
                opacity: 0
            }
        }

        .video-logo {
            position: absolute;
            top: 4%;
            right: calc(5% + 12px);
            opacity: 0.8;
            pointer-events: none;
            width: 3%;
            max-width: 60px;
            min-width: 25px;
            height: auto;
            z-index: 25;
            transition: width 0.2s ease, top 0.2s ease, right 0.2s ease;
            object-fit: contain
        }

        .video-container.fullscreen .video-logo {
            width: 3.80%;
            top: 4%;
            right: 5%
        }

        body.cinema-mode .video-logo {
            width: 3%;
            top: 3.5%;
            right: 4%
        }

        .video-container.fullscreen video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain
        }

        @media(max-width:600px) {
            .video-logo {
                max-width: 15%
            }
        }

        #videoLogo {
            display: none
        }


        .progress-bar {
            position: absolute;
            bottom: 45px;
            left: 15px;
            right: 15px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            z-index: 10004;
            opacity: 1;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out, height 0.3s ease-out;
            display: none;
            transform: translateY(0);
            will-change: transform, opacity, height
        }

        .progress-bar.autohide {
            opacity: 0.3;
            pointer-events: auto;
            transform: translateY(45px);
            height: 2px
        }

        .progress-bar.show {
            transform: translateY(0);
            opacity: 1;
            height: 4px
        }

        .progress-bar.no-transition {
            transition: none !important
        }

        .progress-filled {
            height: 100%;
            background: #ff69b4;
            width: 0%;
            border-radius: 2px
        }

        .progress-handle {
            position: absolute;
            top: 50%;
            left: 0%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #ff69b4;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            z-index: 10005
        }

        .progress-preview {
            position: absolute;
            bottom: 100%;
            left: 0;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-size: 11px;
            padding: 6px;
            border-radius: 6px;
            display: none;
            z-index: 40;
            text-align: center;
            pointer-events: none
        }

        .progress-preview canvas {
            display: block;
            border-radius: 4px;
            margin-bottom: 4px
        }

        .video-controls {
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 15px;
            display: none;
            align-items: center;
            gap: 8px;
            opacity: 1;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            will-change: opacity, transform;
            transform: translateY(0);
            backface-visibility: hidden;
            z-index: 10002
        }

        .video-controls.autohide {
            opacity: 0;
            pointer-events: none;
            transform: translateY(100%)
        }

        .video-controls.show {
            opacity: 1;
            transform: translateY(0)
        }

        .video-controls.no-transition {
            transition: none !important
        }

        .play-btn {
            width: 30px;
            height: 30px;
            background: rgba(128, 128, 128, 0.2);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 30px;
            will-change: transform;
            transform: translateZ(0)
        }

        .control-btn {
            background: none;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            padding: 3px;
            border-radius: 3px
        }

        .fullscreen-btn {
            background: none;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-size: 14px;
            padding: 3px;
            border-radius: 3px
        }

        #cinemaModeBtn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1
        }

        #resizeVideoBtn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            line-height: 1
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2)
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2)
        }

        .settings-container {
            position: relative;
            display: inline-block;
            z-index: 99999 !important;
            isolation: isolate
        }

        .settings-menu {
            position: absolute;
            bottom: calc(100% + 15px);
            right: 0;
            background: linear-gradient(180deg, #2a2a2a, #1a1a1a);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 8px;
            min-width: 150px;
            display: none;
            z-index: 99999 !important
        }

        .settings-menu.show {
            display: block
        }

        .settings-section {
            margin-bottom: 8px
        }

        .settings-section:last-child {
            margin-bottom: 0
        }

        .settings-label {
            color: #ffffff;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 4px;
            display: block
        }

        .settings-option {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 3px;
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 2px
        }

        .settings-option:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff
        }

        .settings-option.active {
            background: #ff69b4;
            color: #ffffff
        }

        .chapter-marker {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            z-index: 15;
            transition: all 0.2s
        }

        .chapter-marker:hover {
            background: rgba(255, 255, 255, 1);
            height: 120%
        }

        .chapter-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            margin-top: 8px;
            z-index: 50
        }

        .chapter-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-bottom-color: rgba(0, 0, 0, 0.9)
        }

        .chapter-marker:hover .chapter-tooltip {
            opacity: 1
        }

        .time-display {
            color: white;
            font-size: 11px
        }

        .volume-btn,
        .fullscreen-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px
        }

        .video-right-sidebar {
            flex: 1;
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto
        }

        .video-title {
            font-size: 24px;
            margin-bottom: 5px;
            color: #111
        }

        .video-meta {
            color: #666;
            font-size: 14px
        }

        .video-right-sidebar-channel {
            color: #ff69b4;
            text-decoration: none;
            font-weight: 500
        }

        .video-right-sidebar-channel:hover {
            text-decoration: underline
        }

        .video-right-sidebar-description {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            margin-top: 10px;
            max-height: 9em;
            overflow-y: auto;
            display: -webkit-box;
            line-clamp: 6;
            -webkit-line-clamp: 6;
            -webkit-box-orient: vertical
        }

        .autoplay-toggle-section {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1)
        }

        .autoplay-toggle-text {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px
        }

        .autoplay-toggle-btn {
            background: none;
            border: none;
            color: #ff69b4;
            font-size: 12px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            font-family: inherit
        }

        .autoplay-toggle-btn:hover {
            color: #ff8ac0
        }

        .autoplay-toggle {
            width: 40px;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            position: relative;
            transition: background 0.3s;
            cursor: pointer
        }

        .autoplay-toggle.active {
            background: #ff69b4
        }

        .autoplay-toggle-handle {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3)
        }

        .autoplay-toggle.active .autoplay-toggle-handle {
            left: 22px
        }

        .video-section {
            margin-bottom: 40px
        }

        .section-title {
            font-size: 24px;
            margin-bottom: 15px;
            color: #111;
            padding-left: 20px
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px
        }

        .video-card {
            position: relative;
            cursor: pointer
        }

        .video-thumbnail {
            width: 100%;
            height: 110px;
            background: #333;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin-bottom: 8px;
            display: block
        }

        .video-thumbnail.active-thumbnail {
            border: 2px solid #ff69b4;
            border-radius: 6px
        }

        .video-duration {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px
        }

        .video-info {
            padding: 0 5px
        }

        .video-card-title {
            font-size: 13px;
            margin-bottom: 3px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-clamp: 2;
            color: #111
        }

        .video-playlist {
            font-size: 11px;
            color: #ff69b4;
            margin-bottom: 2px
        }

        .video-category {
            font-size: 11px;
            color: #666
        }

        .video-tag-link,
        .video-category-link {
            color: #666;
            text-decoration: none;
            margin-right: 5px;
            cursor: pointer
        }

        .playlists-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px
        }

        .playlist-section-carousel {
            margin-bottom: 30px
        }

        .playlist-item {
            background: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative
        }

        .playlist-thumbnail {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            aspect-ratio: 16/9;
            background: #333;
            position: relative
        }

        .playlist-thumb {
            background: #444;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 10px;
            border: 1px solid #222;
            position: relative;
            overflow: hidden
        }

        .playlist-info {
            padding: 12px;
            background: #fafafa;
            border-top: 1px solid #eee
        }

        .playlist-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 14px;
            color: #111
        }

        .playlist-meta {
            font-size: 12px;
            color: #777;
            margin-bottom: 4px
        }

        .playlist-channel {
            font-size: 11px;
            color: #ff69b4
        }

        .playlist-channel-link {
            color: #ff69b4;
            text-decoration: none;
            font-weight: 500
        }

        .playlist-channel-link:hover {
            text-decoration: underline
        }

        .playlist-section-title {
            font-size: 20px;
            margin-bottom: 5px;
            color: #111
        }

        .playlist-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            margin-bottom: 5px;
            min-height: 32px;
            gap: 20px
        }

        .playlist-section-all-link {
            color: #111;
            text-decoration: none;
            font-size: 12px;
            cursor: pointer;
            flex-shrink: 0;
            white-space: nowrap;
            margin-left: auto
        }

        .video-carousel-wrapper {
            position: relative;
            padding: 0 20px;
            margin-bottom: 30px
        }

        .video-carousel {
            display: flex;
            overflow: hidden;
            gap: 15px;
            width: 100%;
            justify-content: flex-start
        }

        .video-carousel .video-card {
            flex: 1;
            max-width: calc((100% - 60px)/5);
            min-width: 160px;
            overflow: hidden
        }

        .video-carousel .video-thumbnail {
            background: #444;
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 108px;
            margin-bottom: 8px;
            display: block
        }

        .video-carousel .video-duration {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
            color: #fff
        }

        .video-carousel .video-info {
            padding: 0 5px
        }

        .video-carousel .video-playlist {
            font-size: 11px;
            color: #ff69b4;
            margin-bottom: 2px
        }

        .video-carousel .video-card-title {
            font-size: 13px;
            margin-top: 8px;
            margin-bottom: 3px;
            color: #111
        }

        .video-carousel .video-category {
            font-size: 11px;
            color: #666
        }

        .carousel-nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(128, 128, 128, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            z-index: 10;
            border-radius: 50%;
            font-size: 20px;
            line-height: 1;
            height: 50px;
            width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: opacity 0.2s;
            margin-top: -25px
        }

        .carousel-nav-btn.prev-btn {
            left: 20px
        }

        .carousel-nav-btn.next-btn {
            right: 20px
        }

        .empty-state {
            text-align: center;
            color: #666;
            padding: 60px 20px;
            font-size: 16px
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666
        }

        .sidebar-collapsed .video-player {
            max-width: 100%;
            margin: 0 auto;
        }

        .sidebar-collapsed .player-section {
            width: 100%;
        }

        .sidebar-collapsed .header-content-wrapper,
        .sidebar-collapsed .top-nav-content {
            margin: 0 auto !important;
            width: 100% !important;
            padding: 0 20px !important;
        }


        .main-content {
            padding-top: 10px;
            width: 100%;
            max-width: none;
        }

        .header,
        .top-nav {
            width: 100% !important;
        }

        .header-content-wrapper,
        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
            padding: 0 20px !important;
        }

        .search-area {
            margin: 0 !important;
        }

        .user-actions {
            margin-left: auto !important;
        }

        .container {
            max-width: none;
            margin: 0;
            width: 100%;
        }

        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1500px;
            margin: 0 auto;
            gap: 20px;
        }

        .footer-content {
            max-width: 1600px !important;
        }

        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1600px;
            }

            .footer-content {
                max-width: 1700px !important;
            }
        }

        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1800px;
            }

            .footer-content {
                max-width: 1900px !important;
            }
        }

        @media (min-width: 2400px) {
            .content-wrapper {
                max-width: 2100px;
            }

            .footer-content {
                max-width: 2200px !important;
            }
        }

        @media (min-width: 2800px) {
            .content-wrapper {
                max-width: 2400px;
            }

            .footer-content {
                max-width: 2500px !important;
            }
        }

        .player-section {
            margin-bottom: 0 !important;
        }

        .video-player-wrapper {
            margin-bottom: 0 !important;
        }

        #danmakuContent,
        .danmaku-content {
            margin-top: 0 !important;
            padding: 0 !important;
            margin-left: 0 !important;
        }

        .video-player.error-state {
            position: relative;
        }

        .video-player.error-state .video-container {
            background: #000;
            position: relative;
            height: 100%;
            min-height: 400px;
        }

        .video-player.error-state .error-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 1;
            z-index: 1;
        }

        .video-player.error-state video {
            display: none;
        }

        .video-player.error-state .video-controls {
            pointer-events: none;
            z-index: 2;
        }

        .video-player.error-state .video-controls button,
        .video-player.error-state .video-controls input,
        .video-player.error-state .video-controls .progress-bar {
            pointer-events: none;
            z-index: 2;
        }

        .video-player.error-state .control-btn,
        .video-player.error-state .play-btn,
        .video-player.error-state .volume-btn,
        .video-player.error-state .volume-slider {
            pointer-events: none;
            z-index: 2;
        }

        .video-player.error-state .resize-video-btn,
        .video-player.error-state .pip-btn,
        .video-player.error-state .fullscreen-btn,
        .video-player.error-state .theater-btn {
            pointer-events: none;
            z-index: 2;
        }

        body.error-state .video-meta,
        body.error-state .video-actions,
        body.error-state .video-tags,
        body.error-state .video-description,
        body.error-state #commentsContainer,
        body.error-state .playlist-section-header,
        body.error-state .video-carousel-wrapper {
            display: none !important;
        }

        body.error-state .video-title {
            font-weight: bold;
        }

        body.error-state .danmaku-content {
            pointer-events: none;
        }

        body.error-state .danmaku-form {
            pointer-events: none;
        }

        body.error-state .danmaku-form input,
        body.error-state .danmaku-form textarea,
        body.error-state .danmaku-form button,
        body.error-state .danmaku-form select {
            pointer-events: none;
            background-color: #f0f0f0 !important;
            color: #999 !important;
        }

        body.dark-theme.error-state .danmaku-form {
            background: #2a2a2a !important;
            border-color: #444 !important;
        }

        body.dark-theme.error-state .danmaku-form input,
        body.dark-theme.error-state .danmaku-form textarea,
        body.dark-theme.error-state .danmaku-form button,
        body.dark-theme.error-state .danmaku-form select {
            background-color: #1a1a1a !important;
            color: #666 !important;
            border-color: #444 !important;
        }

        body.dark-theme.error-state .danmaku-form input::placeholder,
        body.dark-theme.error-state .danmaku-form textarea::placeholder {
            color: #555 !important;
        }

        body.dark-theme.error-state .danmaku-form select option {
            background: #1a1a1a !important;
            color: #666 !important;
        }

        body.dark-theme.error-state .danmaku-controls select {
            background: #1a1a1a !important;
            color: #666 !important;
            border-color: #444 !important;
        }

        body.dark-theme.error-state .danmaku-controls select option {
            background: #1a1a1a !important;
            color: #666 !important;
        }

        .danmaku-form {
            margin-top: 0 !important;
            margin-left: 0 !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }

        #danmakuContent,
        .danmaku-content {
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box;
            align-self: stretch;
        }

        .danmaku-content {
            max-width: 1600px;
            margin: 0 auto;
            transition: max-width 0.3s ease;
        }

        @media (min-width: 1400px) {
            .danmaku-content {
                max-width: 1700px;
            }
        }

        @media (min-width: 1600px) {
            .danmaku-content {
                max-width: 1800px;
            }
        }

        @media (min-width: 1800px) {
            .danmaku-content {
                max-width: 1900px;
            }
        }

        @media (min-width: 2000px) {
            .danmaku-content {
                max-width: 1950px;
            }
        }

        @media (max-width: 1600px) {
            .danmaku-content {
                max-width: 95%;
            }
        }

        @media (max-width: 1200px) {
            .danmaku-content {
                max-width: 90%;
            }
        }

        @media (max-width: 992px) {
            .danmaku-content {
                max-width: 85%;
            }
        }

        @media (max-width: 768px) {
            .danmaku-content {
                max-width: 100%;
                margin: 0;
            }
        }

        body.wide-screen-mode .danmaku-content,
        body.wide-screen-mode #danmakuContent {
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
        }

        .player-section {
            width: 100% !important;
        }

        .video-player {
            width: 100% !important;
        }

        .video-container {
            width: 100% !important;
        }

        .right-sidebar {
            padding-top: 10px;
        }

        @media (min-width: 1400px) {
            .related-thumb {
                width: 140px !important;
                height: 80px !important;
            }
        }

        @media (min-width: 1600px) {
            .related-thumb {
                width: 160px !important;
                height: 90px !important;
            }
        }

        .playlist-container {
            max-height: 500px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
            transition: max-height 0.3s ease;
        }

        .playlist-container.collapsed {
            max-height: 0;
            overflow: hidden;
        }

        .right-sidebar:has(#danmakuCommentsContainer:not(.collapsed)) #playlistContainer {
            max-height: 300px;
        }

        body .player-section {
            max-width: 1600px !important;
            width: 100% !important;
            margin: 0 auto 15px auto !important;
            box-sizing: border-box !important;
        }

        body .video-player {
            width: 100% !important;
            flex: none !important;
            max-width: none !important;
        }

        body .video-player-wrapper {
            display: block !important;
            width: 100% !important;
        }

        body .main-content {
            width: 100% !important;
            max-width: none !important;
        }

        .player-section {
            max-width: 1600px !important;
            margin: 0 auto 15px auto !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .video-player {
            width: 100% !important;
            max-width: none !important;
        }

        .video-player-wrapper {
            display: block !important;
            width: 100% !important;
            max-width: none !important;
        }

        .main-content {
            width: 100% !important;
            max-width: none !important;
        }

        .video-player {
            flex: none !important;
        }

        @media (min-width: 1400px) {
            .player-section {
                max-width: 1700px;
            }
        }

        @media (min-width: 1600px) {
            .player-section {
                max-width: 1800px;
            }
        }

        @media (min-width: 1800px) {
            .player-section {
                max-width: 1900px;
            }
        }

        @media (min-width: 2000px) {
            .player-section {
                max-width: 1950px;
            }
        }

        @media (max-width: 1600px) {
            .player-section {
                max-width: 95%;
            }
        }

        @media (max-width: 1200px) {
            .player-section {
                max-width: 90%;
            }
        }

        @media (max-width: 992px) {
            .player-section {
                max-width: 85%;
            }
        }

        @media (max-width: 768px) {
            .player-section {
                max-width: 100%;
                margin: 0 0 15px 0;
            }
        }

        @media (max-width: 576px) {
            .player-section {
                max-width: 100%;
                margin: 0 0 10px 0;
            }

            .video-player {
                border-radius: 6px;
            }
        }

        @media (max-width: 400px) {
            .player-section {
                margin: 0 0 8px 0;
            }

            .video-player {
                border-radius: 4px;
            }
        }

        .playlist-container::-webkit-scrollbar {
            width: 4px;
        }

        .playlist-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .playlist-container::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.4);
            border-radius: 2px;
        }

        .playlist-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 105, 180, 0.6);
        }

        .related-video {
            position: relative;
            margin-bottom: 4px;
            padding: 6px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
            background: #fff;
        }

        .related-video.current-video {
            border-color: #ff69b4;
            background: rgba(255, 105, 180, 0.1);
        }

        .related-video-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            opacity: 0;
            pointer-events: none;
            text-decoration: none;
            color: transparent;
        }

        .related-video:hover .related-video-link {
            pointer-events: auto;
        }

        .related-thumb {
            width: 120px !important;
            height: 68px !important;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            contain: layout style paint;
        }

        .related-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            will-change: auto;
        }


        .lazy-thumb {
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 12px;
            width: 100%;
            height: 100%;
            contain: layout style paint;
        }

        .lazy-thumb.loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
            will-change: background-position;
        }

        @keyframes loading {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        .related-channel {
            font-size: 10px;
            color: #ff69b4;
            margin-bottom: 1px;
        }

        .related-title {
            margin-bottom: 1px !important;
        }

        .related-meta {
            margin-bottom: 0 !important;
            margin-top: 0 !important;
            font-size: 11px;
            line-height: 1.2;
            padding: 0;
        }

        .danmaku-comment-item {
            padding: 6px 10px;
            border: none !important;
            font-size: 11px;
            line-height: 1.3;
            cursor: pointer;
            transition: background-color 0.2s;
            background: transparent;
        }

        .danmaku-comment-item:hover {
            background-color: #f0f0f0 !important;
        }

        .danmaku-comment-item:last-child {
            border-bottom: none;
        }

        .danmaku-comment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .danmaku-comment-date {
            color: #999;
            font-size: 10px;
            white-space: nowrap;
        }

        .danmaku-comment-time {
            color: #ff69b4;
            font-weight: 500;
            margin-right: 8px;
            cursor: pointer;
        }

        .danmaku-comment-time:hover {
            text-decoration: underline;
        }

        .danmaku-comment-text {
            color: #333;
        }

        .danmaku-comment-meta {
            color: #666;
            font-size: 10px;
            margin-top: 2px;
        }

        #danmakuCommentsContainer {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: max-height 0.3s ease;
        }

        #danmakuCommentsContainer.collapsed {
            max-height: 0;
            overflow: hidden;
        }

        .danmaku-form {
            padding: 6px !important;
            display: flex !important;
            align-items: center !important;
            gap: 6px !important;
        }

        .danmaku-input {
            flex: 1 !important;
            margin-bottom: 0 !important;
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
        }

        .danmaku-input input {
            padding: 4px 8px !important;
            font-size: 12px !important;
            width: auto !important;
            flex: 1 !important;
            min-width: 0 !important;
            height: 26px !important;
            line-height: 18px !important;
            border-radius: 4px !important;
            box-sizing: border-box !important;
        }

        .danmaku-controls {
            display: flex !important;
            gap: 5px !important;
            margin-top: 0 !important;
            align-items: center !important;
        }

        .danmaku-controls select,
        .danmaku-controls button {
            padding: 3px 5px !important;
            font-size: 11px !important;
        }

        #sendDanmaku {
            background: #ff69b4 !important;
            color: #fff !important;
            border: none !important;
            height: 26px !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-width: 38px !important;
            cursor: pointer !important;
            box-sizing: border-box !important;
        }

        #sendDanmaku:hover {
            background: #d94b88 !important;
        }

        #sendDanmaku svg {
            display: block;
            width: 16px;
            height: 16px;
        }


        .danmaku-controls select {
            height: 26px !important;
            line-height: 18px !important;
            border-radius: 4px !important;
            box-sizing: border-box !important;
        }

        #danmakuContent,
        .danmaku-content {
            margin-top: -1px !important;
            border-top-left-radius: 0 !important;
            border-top-right-radius: 0 !important;
            box-shadow: none !important;
            border-bottom: 0;
        }

        .danmaku-form {
            border-top-left-radius: 0 !important;
            border-top-right-radius: 0 !important;
        }

        #danmakuContent,
        .danmaku-content,
        .danmaku-form {
            overflow: hidden;
        }

        .danmaku-content::before,
        .danmaku-content::after,
        .danmaku-form::before,
        .danmaku-form::after {
            content: none !important;
        }

        #fullscreenDanmakuFormOverlay {
            background: #000;
            padding: 0 !important;
            left: 0;
            right: 0;
        }

        .video-container.fullscreen #fullscreenDanmakuFormOverlay {
            position: absolute !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            top: auto !important;
            z-index: 1000 !important;
            pointer-events: none !important;
            width: 100% !important;
            margin: 0 !important;
            height: var(--fs-form-height, auto) !important;
        }

        .video-container.fullscreen #fullscreenDanmakuFormOverlay .danmaku-form {
            width: 100% !important;
            max-width: none !important;
            margin: 0 !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-form {
            pointer-events: auto !important;
            background: rgba(0, 0, 0, 0.9) !important;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
            border: none !important;
            border-radius: 0 !important;
            padding: 8px !important;
            max-width: none !important;
            width: 100% !important;
            margin: 0 !important;
            box-shadow: none;
        }

        #fullscreenDanmakuFormOverlay .danmaku-input {
            flex: 1 1 auto !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-input input {
            width: auto !important;
            flex: 1 !important;
            min-width: 0 !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-input input {
            background: #222 !important;
            border: 1px solid #444 !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-input input::placeholder {
            color: #aaa !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-controls select,
        #fullscreenDanmakuFormOverlay .danmaku-controls button {
            background: #222 !important;
            color: #fff !important;
            border: 1px solid #444 !important;
        }

        #fullscreenDanmakuFormOverlay .danmaku-controls select option {
            color: #fff;
            background: #222;
        }

        #fullscreenDanmakuFormOverlay .kaomoji-picker-btn,
        #fullscreenDanmakuFormOverlay button.kaomoji-picker-btn,
        #fullscreenDanmakuFormOverlay #danmakuKaomojiBtn {
            background: #222 !important;
            color: #fff !important;
            border: 1px solid #444 !important;
        }

        #fullscreenDanmakuFormOverlay .kaomoji-picker-btn:hover,
        #fullscreenDanmakuFormOverlay button.kaomoji-picker-btn:hover,
        #fullscreenDanmakuFormOverlay #danmakuKaomojiBtn:hover {
            background: #333 !important;
            border-color: #555 !important;
            color: #fff !important;
        }

        #fullscreenDanmakuFormOverlay #sendDanmaku {
            background: #ff69b4 !important;
        }

        .player-section {
            border-bottom-left-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
            box-shadow: none !important;
        }

        .video-player {
            border-bottom-left-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
        }

        @media (max-width: 1024px) {
            .right-sidebar {
                display: none;
            }

            .video-carousel-wrapper {
                padding: 0 30px;
            }

            .carousel-nav-btn {
                padding: 8px 12px;
                font-size: 18px;
                height: 40px;
                width: 40px;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                padding: 10px;
            }

            .video-player-wrapper {
                flex-direction: column;
            }

            .video-right-sidebar {
                max-height: none;
                width: 100%;
            }

            .video-carousel-wrapper {
                padding: 0 20px;
            }

            .carousel-nav-btn {
                padding: 6px 10px;
                font-size: 16px;
                height: 35px;
                width: 35px;
            }

            .playlist-section-title {
                font-size: 16px;
                padding-left: 0;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .nav-bar {
                padding: 0 10px;
            }

            .search-area {
                margin-right: 10px;
            }

            .search-input {
                width: 120px;
            }


            .video-right-sidebar {
                padding: 10px;
            }

            .video-right-sidebar-title {
                font-size: 16px;
            }

            .video-carousel-wrapper {
                padding: 0 10px;
            }

            .carousel-nav-btn {
                display: none;
            }
        }

        .speed-hud {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            font-weight: 700;
            font-size: 14px;
            z-index: 26;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .video-container.fullscreen .video-controls {
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
            opacity: 1;
            transition: opacity 0.2s ease, transform 0.2s ease;
            bottom: var(--fs-form-height, 0px) !important;
            position: absolute;
            z-index: 10005;
            display: flex !important;
        }

        .video-container .video-controls.autohide,
        body.cinema-mode .video-controls.autohide {
            opacity: 0;
            pointer-events: none;
            transform: translateY(100%);
        }

        .video-container .video-controls.show,
        body.cinema-mode .video-controls.show {
            transform: translateY(0);
        }

        .video-container:not(.fullscreen) .mini-progress-bar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 4px;
            z-index: 1;
            pointer-events: none;
            opacity: 0;
            transform: scaleY(0.5) translateY(2px);
            transform-origin: bottom;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .video-container:not(.fullscreen) .mini-progress-bar.show {
            opacity: 1;
            transform: scaleY(1) translateY(0);
        }

        .video-container:not(.fullscreen) .mini-progress-bar.no-transition {
            transition: none !important;
        }

        .video-container:not(.fullscreen) .mini-progress-track {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.35);
            border-radius: 0;
        }

        .video-container:not(.fullscreen) .mini-progress-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0%;
            background: #ff69b4;
            transition: width 0.1s linear;
            border-radius: 0;
        }

        .video-container:not(.fullscreen) .mini-progress-bar .chapter-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            z-index: 2;
            transition: all 0.2s;
            transform: none;
        }

        .video-container:not(.fullscreen) .mini-progress-bar .chapter-marker:hover {
            background: rgba(255, 255, 255, 1);
            width: 3px;
        }

        .video-container.fullscreen .mini-progress-bar {
            display: none !important;
        }

        .video-container:not(.fullscreen) .progress-bar.autohide {
            opacity: 0;
            pointer-events: none;
            transform: translateY(45px);
        }

        .video-container:not(.fullscreen) .progress-bar.show {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .video-container.fullscreen .progress-bar {
            display: block !important;
            bottom: calc(45px + var(--fs-form-height, 0px)) !important;
            z-index: 10006 !important;
            transition: opacity 0.2s ease, transform 0.2s ease, height 0.2s ease;
        }

        .video-container.fullscreen .progress-bar.autohide {
            pointer-events: auto;
            transform: translateY(50px);
            height: 2px;
        }

        .video-container.fullscreen .progress-bar.autohide .progress-handle {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0s 0.2s !important;
        }

        .video-container.fullscreen .progress-bar.show .progress-handle {
            opacity: 1;
            pointer-events: auto;
            transition: none !important;
        }

        .video-container.fullscreen .progress-bar.show {
            transform: translateY(0);
            height: 4px;
        }

        .settings-container {
            position: relative;
            display: inline-block;
            z-index: 99999 !important;
            isolation: isolate
        }

        .settings-menu {
            position: absolute;
            bottom: calc(100% + 15px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 0;
            min-width: 200px;
            display: none;
            z-index: 99999 !important;
            overflow: hidden
        }

        .settings-menu.show {
            display: block
        }

        .settings-main-menu {
            display: block
        }

        .settings-main-menu {
            display: flex;
            flex-direction: column
        }

        .settings-tab {
            background: none;
            border: none;
            color: #ffffff;
            cursor: pointer;
            font-size: 13px;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            text-align: left;
            transition: background 0.15s ease
        }

        .settings-tab:hover {
            background: rgba(255, 255, 255, 0.1)
        }

        .settings-tab-value {
            color: #cccccc;
            font-size: 12px
        }

        .settings-sub-menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            display: none;
            animation: slideIn 0.2s ease-out;
            flex-direction: column;
            z-index: 99999 !important
        }

        .settings-sub-menu.slide-out {
            animation: slideOut 0.12s ease-in forwards
        }

        .settings-sub-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            gap: 8px
        }

        .settings-back-btn {
            background: none;
            border: none;
            color: #ffffff;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.15s ease
        }

        .settings-back-btn:hover {
            background: rgba(255, 255, 255, 0.1)
        }

        .settings-back-btn svg {
            width: 18px;
            height: 18px
        }

        .settings-sub-title {
            color: #ffffff;
            font-size: 13px;
            font-weight: 500;
            flex: 1;
            text-align: center;
            margin-right: 26px
        }

        .settings-sub-separator {
            height: 1px;
            background: rgba(255, 255, 255, 0.15);
            margin: 0 12px
        }

        .settings-sub-options {
            padding: 8px 0;
            display: flex;
            flex-direction: column
        }

        .settings-option {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 12px;
            padding: 8px 12px;
            display: block;
            width: 100%;
            text-align: left;
            transition: background 0.15s ease;
            border-radius: 0
        }

        .settings-option:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff
        }

        .settings-option.active {
            background: rgba(255, 105, 180, 0.2);
            color: #fff
        }

        .settings-section {
            margin-bottom: 8px
        }

        .settings-section:last-child {
            margin-bottom: 0
        }

        .settings-label {
            color: #ffffff;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 4px;
            display: block
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(10px)
            }

            to {
                opacity: 1;
                transform: translateX(0)
            }
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateX(0)
            }

            to {
                opacity: 0;
                transform: translateX(10px)
            }
        }



        .video-container.fullscreen {
            cursor: none;
            padding-bottom: var(--fs-form-height, 0px) !important;
            background: #000 !important;
        }
        
        .video-container.fullscreen .hide-in-fullscreen {
            display: none !important;
        }

        .video-container.fullscreen.show-cursor {
            cursor: auto;
        }

        .video-container.hide-cursor {
            cursor: none;
        }

        .video-container.show-cursor {
            cursor: auto;
        }

        .fs-danmaku-toggle {
            display: none !important;
        }

        .video-container.fullscreen .fs-danmaku-toggle {
            display: inline-flex !important;
        }

        .video-container.fullscreen.fs-form-hidden #fullscreenDanmakuFormOverlay {
            display: none !important;
        }

        .time-display {
            color: white;
            font-size: 11px;
        }

        .volume-hud {
            position: absolute;
            right: 10px;
            bottom: 50px;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-weight: 700;
            font-size: 12px;
            z-index: 26;
            display: none;
        }

        .volume-container {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .controls-spacer {
            flex: 1;
        }

        .volume-btn {
            background: none;
            border: none;
            color: white;
            font-size: 14px;
            padding: 2px;
            cursor: default;
            pointer-events: none;
            transition: color 0.2s;
        }

        .volume-btn:hover {
            color: #ccc;
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 50px;
            height: 4px;
            background: transparent;
            outline: none;
            border-radius: 2.5px;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: linear-gradient(to right, var(--volColor, #999) var(--volPos, 0%), rgba(255, 255, 255, 0.3) var(--volPos, 0%));
            border-radius: 2.5px;
        }

        .volume-slider::-moz-range-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: linear-gradient(to right, var(--volColor, #999) var(--volPos, 0%), rgba(255, 255, 255, 0.3) var(--volPos, 0%));
            border-radius: 2.5px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: 2px solid var(--volColor, #999);
            margin-top: -4px;
            box-shadow: none;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: 2px solid var(--volColor, #999);
            box-shadow: none;
            margin-top: -4px;
        }

        #speedSlider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: transparent;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            margin: 8px 0;
        }

        #speedSlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, #ff69b4 var(--speedPos, 0%), rgba(255, 105, 180, 0.3) var(--speedPos, 0%));
            border-radius: 2px;
            cursor: pointer;
        }

        #speedSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #ff69b4;
            margin-top: -4px;
            box-shadow: none;
        }

        #speedSlider::-moz-range-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(to right, #ff69b4 var(--speedPos, 0%), rgba(255, 105, 180, 0.3) var(--speedPos, 0%));
            border-radius: 2px;
            cursor: pointer;
        }

        #speedSlider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #ff69b4;
            margin-top: -4px;
            box-shadow: none;
        }

        #speedSlider::-moz-range-progress {
            background: #ff69b4;
            height: 4px;
            border-radius: 2px;
        }

        #resizeVideoBtn.active {
            color: #ffffff;
        }

        #cinemaModeBtn.active {
            color: #ff69b4;
        }

        #pipBtn.active {
            color: #ff69b4;
        }

        #wideModeBtn.active {
            color: #ff69b4;
        }

        .danmaku-panel-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10003;
            opacity: 0;
            transform: translateY(-40px);
            transition: opacity 0.3s ease, transform 0.3s ease, background 0.2s;
            pointer-events: none;
        }

        .danmaku-panel-btn:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .danmaku-panel-btn svg {
            width: 18px;
            height: 18px;
        }

        .video-container.fullscreen .danmaku-panel-btn,
        body.cinema-mode .danmaku-panel-btn,
        body.wide-screen-mode .danmaku-panel-btn {
            display: flex;
        }

        .video-container.fullscreen .danmaku-panel-btn.active,
        body.cinema-mode .danmaku-panel-btn.active,
        body.wide-screen-mode .danmaku-panel-btn.active {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        .video-container.fullscreen .danmaku-panel-btn.show:not(.active),
        body.cinema-mode .danmaku-panel-btn.show:not(.active),
        body.wide-screen-mode .danmaku-panel-btn.show:not(.active) {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .danmaku-panel-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 50px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            z-index: 10002;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.25s ease, transform 0.25s ease, bottom 0.3s ease;
            pointer-events: none;
        }

        .danmaku-panel-overlay.open {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .danmaku-panel-overlay.expanded {
            bottom: 0;
        }

        .danmaku-panel-header {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            gap: 8px;
        }

        .danmaku-panel-title-wrap {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .danmaku-panel-title {
            color: #fff;
            font-size: 11px;
            font-weight: 600;
        }

        .danmaku-panel-count {
            color: #ff69b4;
            font-size: 11px;
            margin-left: 4px;
        }

        .danmaku-panel-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .danmaku-panel-follow {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: color 0.2s, background 0.2s;
        }

        .danmaku-panel-follow:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .danmaku-panel-follow.active {
            color: #ff69b4;
        }

        .danmaku-panel-follow svg {
            width: 14px;
            height: 14px;
        }

        .danmaku-panel-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .danmaku-panel-close:hover {
            color: #fff;
        }

        .danmaku-panel-close svg {
            width: 14px;
            height: 14px;
        }

        .danmaku-panel-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            overscroll-behavior: contain;
        }

        .danmaku-panel-list::-webkit-scrollbar {
            width: 4px;
        }

        .danmaku-panel-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .danmaku-panel-list::-webkit-scrollbar-thumb {
            background: rgba(255, 105, 180, 0.4);
            border-radius: 2px;
        }

        .danmaku-panel-item {
            padding: 6px 10px;
            font-size: 11px;
            line-height: 1.3;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .danmaku-panel-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .danmaku-panel-item.current {
            background: rgba(255, 105, 180, 0.15);
        }

        .danmaku-panel-time {
            color: #ff69b4;
            font-weight: 500;
            margin-right: 8px;
        }

        .danmaku-panel-text {
            color: #ddd;
        }

        .danmaku-panel-empty {
            color: #666;
            font-size: 11px;
            text-align: center;
            padding: 20px 10px;
        }

        body.cinema-mode {
            overflow: hidden;
            background: #fff;
        }

        body.cinema-mode .top-nav {
            display: none !important;
        }

        body.cinema-mode .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        body.cinema-mode .header-content-wrapper {
            position: relative !important;
            padding-left: 20px !important;
            padding-right: 20px !important;
        }

        body.cinema-mode .sidebar-toggle-btn {
            width: 32px !important;
            height: 32px !important;
            margin-right: 10px !important;
            position: relative !important;
            left: auto !important;
            top: auto !important;
            transform: none !important;
            z-index: auto !important;
        }

        body.cinema-mode .logo {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin-right: 110px !important;
            flex-shrink: 0 !important;
            height: 40px !important;
            position: relative !important;
            left: auto !important;
            top: auto !important;
            transform: none !important;
            z-index: auto !important;
        }

        body.cinema-mode .logo img {
            height: 30px !important;
        }

        body.cinema-mode .user-actions {
            display: flex !important;
            gap: 8px !important;
            align-items: center !important;
            margin-left: auto !important;
            flex-shrink: 0 !important;
            position: relative !important;
            right: auto !important;
            top: auto !important;
            height: auto !important;
            transform: none !important;
            z-index: auto !important;
        }

        body.cinema-mode .container {
            max-width: none;
            padding: 0;
            margin: 40px auto 0;
            gap: 0;
        }

        body.cinema-mode .content-wrapper {
            max-width: none !important;
            margin: 0 !important;
            width: 100% !important;
            padding: 0 !important;
        }

        body.cinema-mode .sidebar {
            position: fixed !important;
            top: 40px !important;
            left: 0 !important;
            bottom: 0 !important;
            width: 200px !important;
            z-index: 1500 !important;
            transform: translateX(-200px) !important;
            transition: transform 0.25s ease !important;
            overflow-y: auto !important;
            box-shadow: none !important;
            display: block !important;
            margin-left: 0 !important;
        }

        body.cinema-mode-entering * {
            transition: none !important;
        }

        body.cinema-mode-entering .sidebar {
            transition: none !important;
            transform: translateX(-200px) !important;
        }

        body.cinema-mode-entering .sidebar-item {
            transition: none !important;
        }

        body.cinema-mode-entering .sidebar-item svg {
            transition: none !important;
        }

        body.cinema-mode.sidebar-open .sidebar {
            transform: translateX(0) !important;
        }

        body.cinema-mode.dark-theme .sidebar {
        }

        body.cinema-mode .sidebar-item:hover {
            color: #c2185b !important;
            border-left-color: #ff85b4 !important;
            background: transparent !important;
        }

        body.cinema-mode .sidebar-item.active {
            color: #000 !important;
            border-left-color: #ff69b4 !important;
        }

        body.cinema-mode.dark-theme .sidebar-item:hover {
            color: #ffadcd !important;
            border-left-color: #ff85b4 !important;
            background: transparent !important;
        }

        body.cinema-mode.dark-theme .sidebar-item.active {
            color: #fff !important;
            border-left-color: #ff69b4 !important;
        }

        body.cinema-mode .sidebar .sidebar-item.nav-item svg {
            stroke: #666;
        }

        body.cinema-mode .sidebar .sidebar-item.nav-item:hover svg {
            stroke: #c2185b;
        }

        body.cinema-mode .sidebar .sidebar-item.nav-item.active svg {
            stroke: #ff69b4;
        }

        body.cinema-mode .sidebar .sidebar-item.library-item svg {
            stroke: #666;
        }

        body.cinema-mode .sidebar .sidebar-item.library-item:hover svg {
            stroke: #c2185b;
        }

        body.cinema-mode .sidebar .sidebar-item.library-item.active svg {
            stroke: #ff69b4;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.nav-item svg {
            stroke: #999;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.nav-item:hover svg {
            stroke: #ffadcd;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.nav-item.active svg {
            stroke: #ff69b4;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.library-item svg {
            stroke: #999;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.library-item:hover svg {
            stroke: #ffadcd;
        }

        body.cinema-mode.dark-theme .sidebar .sidebar-item.library-item.active svg {
            stroke: #ff69b4;
        }

        body.cinema-mode.sidebar-collapsed .sidebar {
            width: 200px !important;
        }

        body.cinema-mode.sidebar-collapsed .sidebar-title {
            display: block !important;
        }

        body.cinema-mode.sidebar-collapsed .sidebar-item {
            padding: 6px 0 !important;
            padding-left: 10px !important;
            justify-content: flex-start !important;
            gap: 8px !important;
            font-size: 13px !important;
            border-radius: 0 !important;
        }

        body.cinema-mode.sidebar-collapsed .sidebar-item span {
            display: inline !important;
        }

        body.cinema-mode.sidebar-collapsed .sidebar-item svg {
            width: 16px !important;
            height: 16px !important;
            margin: 0 !important;
        }

        body.cinema-mode.sidebar-collapsed .library-item,
        body.cinema-mode.sidebar-collapsed .nav-item {
            gap: 8px !important;
            justify-content: flex-start !important;
        }

        body.cinema-mode.sidebar-collapsed #autoplayToggle {
            padding: 6px 0 !important;
            padding-left: 10px !important;
            justify-content: flex-start !important;
            gap: 8px !important;
        }

        body.cinema-mode.sidebar-collapsed #autoplayToggle svg {
            width: 16px !important;
            height: 16px !important;
            margin: 0 !important;
        }

        body.cinema-mode.sidebar-collapsed #autoplayStatus {
            display: inline !important;
        }

        body.cinema-mode.sidebar-collapsed #subscribedChannelsContainer .sidebar-item {
            justify-content: flex-start !important;
            gap: 8px !important;
        }

        body.cinema-mode.sidebar-collapsed #subscribedChannelsContainer .sidebar-item span {
            display: inline !important;
        }

        body.cinema-mode.sidebar-collapsed #subscribedChannelsContainer .sidebar-item div {
            margin-right: 8px !important;
        }

        body.cinema-mode.sidebar-open::before {
            content: '';
            position: fixed;
            top: 40px;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1400;
        }

        body.cinema-mode .right-sidebar,
        body.cinema-mode .video-right-sidebar,
        body.cinema-mode .playlist-section-header,
        body.cinema-mode .video-carousel-wrapper {
            display: none !important;
        }

        body.cinema-mode .video-player-wrapper {
            margin: 0 !important;
            padding: 0 !important;
            width: 100vw !important;
            max-width: none !important;
            display: block !important;
        }

        body.cinema-mode .main-content {
            width: 100vw !important;
            max-width: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }

        body.cinema-mode .player-section {
            width: 100vw !important;
            max-width: none !important;
            margin: 0 !important;
            padding: 0 !important;
            border-radius: 0 !important;
        }

        body.cinema-mode #videoContainer,
        body.cinema-mode .video-container {
            width: 100vw !important;
            max-width: none !important;
            margin: 0 !important;
            padding: 0 !important;
            position: relative !important;
        }

        body.cinema-mode .video-player {
            width: 100vw !important;
            max-width: none !important;
            height: calc(100vh - 40px - var(--cin-form-height, 48px)) !important;
            max-height: calc(100vh - 40px - var(--cin-form-height, 48px)) !important;
            border-radius: 0 !important;
            aspect-ratio: auto !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        body.cinema-mode .video-container video {
            width: 100% !important;
            height: 100% !important;
        }

        body.cinema-mode .video-controls {
            width: 100% !important;
            max-width: 100% !important;
            left: 0 !important;
            right: 0 !important;
            padding: 10px 15px !important;
            box-sizing: border-box !important;
            margin: 0 !important;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        body.cinema-mode .progress-bar {
            flex: 1 !important;
            max-width: none !important;
            transition: opacity 0.3s ease, transform 0.3s ease, height 0.3s ease;
        }

        @media (max-width: 1200px) {
            body.cinema-mode .video-player {
                max-height: calc(100vh - 40px - 40px);
            }
        }

        @media (max-width: 768px) {
            body.cinema-mode .container {
                margin: 40px auto 0;
            }

            body.cinema-mode .video-player {
                max-height: calc(100vh - 40px - 40px);
            }
        }

        @media (max-width: 480px) {
            body.cinema-mode .container {
                margin: 40px auto 0;
            }

            body.cinema-mode .video-player {
                max-height: calc(100vh - 40px - 40px);
            }
        }

        body.cinema-mode .danmaku-content,
        body.cinema-mode #danmakuContent {
            display: block !important;
            width: 100vw;
            background: transparent !important;
            border-radius: 0;
            margin-top: 0;
            position: fixed !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            z-index: 100 !important;
        }

        body.cinema-mode .danmaku-header {
            display: none !important;
        }

        body.cinema-mode .danmaku-form {
            width: 100%;
            max-width: none;
            background: #f8f8f8 !important;
            border: none !important;
            border-radius: 0 !important;
            padding: 5px 10px !important;
            box-sizing: border-box;
            margin: 0 !important;
        }

        body.cinema-mode #commentsContainer,
        body.cinema-mode .comments-section {
            display: none !important;
        }

        body.cinema-mode .danmaku-input {
            margin: 0 !important;
        }

        body.cinema-mode .danmaku-input input {
            background: #fff !important;
            border: 1px solid #ddd !important;
            border-radius: 4px !important;
            padding: 5px 8px !important;
            margin: 0 !important;
        }

        body.cinema-mode .danmaku-input input::placeholder {
            color: #999 !important;
        }

        body.cinema-mode .danmaku-controls select:not(#danmakuColor),
        body.cinema-mode .danmaku-controls button {
            background: #fff !important;
            color: #111 !important;
            border: 1px solid #ddd !important;
        }

        body.cinema-mode .danmaku-controls #danmakuColor {
            background: #fff !important;
            border: 1px solid #ddd !important;
        }

        body.cinema-mode .danmaku-controls select option {
            color: #111;
            background: #fff;
        }

        body.cinema-mode.dark-theme .danmaku-form {
            background: rgba(0, 0, 0, 0.95) !important;
        }

        body.cinema-mode.dark-theme .danmaku-input input {
            background: #222 !important;
            border: 1px solid #444 !important;
        }

        body.cinema-mode.dark-theme .danmaku-input input::placeholder {
            color: #aaa !important;
        }

        body.cinema-mode.dark-theme .danmaku-controls select:not(#danmakuColor),
        body.cinema-mode.dark-theme .danmaku-controls button {
            background: #222 !important;
            color: #fff !important;
            border: 1px solid #444 !important;
        }

        body.cinema-mode.dark-theme .danmaku-controls #danmakuColor {
            background: #222 !important;
            border: 1px solid #444 !important;
        }

        body.cinema-mode.dark-theme .danmaku-controls select option {
            color: #fff;
            background: #222;
        }

        body.cinema-mode #sendDanmaku {
            background: #ff69b4 !important;
            color: #fff !important;
        }

        body.cinema-mode .video-info,
        body.cinema-mode .video-description,
        body.cinema-mode .video-tags,
        body.cinema-mode .footer,
        body.cinema-mode .video-section,
        body.cinema-mode .playlist-section-carousel {
            display: none !important;
        }

        body.cinema-mode .player-section {
            width: 100vw;
            margin: 0;
            border-radius: 0;
        }

        .video-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            z-index: 15;
            transition: opacity 0.3s ease;
            opacity: 1
        }

        .video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover
        }

        .big-play-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: #ff69b4;
            color: white;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: transform 0.15s ease
        }

        .big-play-btn:hover {
            transform: scale(1.05)
        }

        .video-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            align-items: center;
            justify-content: center;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 40px;
            font-weight: bold;
            z-index: 30;
            pointer-events: none;
            border: none;
            box-shadow: none
        }

        .autoplay-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            text-align: center
        }

        .autoplay-title {
            font-size: 16px;
            font-weight: bold;
            color: white;
            margin-bottom: 12px
        }

        .autoplay-circle {
            position: relative;
            width: 80px;
            height: 80px;
            margin-bottom: 12px
        }

        .fullscreen .autoplay-circle {
            width: 140px;
            height: 140px
        }

        .fullscreen .autoplay-play {
            width: 140px;
            height: 140px
        }

        .fullscreen .autoplay-play svg {
            width: 70px;
            height: 70px
        }

        .autoplay-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
            cursor: pointer
        }

        .autoplay-play svg {
            width: 44px;
            height: 44px;
            display: block
        }

        .autoplay-play svg polygon {
            fill: #fff
        }

        .video-container.fullscreen .autoplay-play svg,
        .cinema-mode .autoplay-play svg {
            width: 80px;
            height: 80px
        }

        .video-container.fullscreen .autoplay-play,
        .cinema-mode .autoplay-play {
            width: 160px;
            height: 160px
        }

        .autoplay-progress {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            pointer-events: none
        }

        .autoplay-progress circle {
            fill: none;
            stroke: rgba(255, 255, 255, 0.6);
            stroke-width: 4;
            stroke-dasharray: 150.8;
            stroke-dashoffset: 150.8;
            animation: autoplay-countdown 10s linear forwards
        }

        @keyframes autoplay-countdown {
            to {
                stroke-dashoffset: 0
            }
        }

        .autoplay-actions {
            display: flex;
            gap: 10px
        }

        .autoplay-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 6px 12px;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            cursor: pointer
        }

        .autoplay-btn:hover {
            background: rgba(255, 255, 255, 0.4)
        }

        .cinema-mode .autoplay-overlay,
        .video-container.fullscreen .autoplay-overlay {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important
        }

        .video-container.fullscreen .autoplay-circle,
        .cinema-mode .autoplay-circle {
            width: 160px !important;
            height: 160px !important
        }

        .video-container.fullscreen .autoplay-play,
        .cinema-mode .autoplay-play {
            font-size: 56px !important
        }

        .footer {
            background: #2c2c2c;
            color: #fff;
            padding: 25px 0 15px 0;
            margin-top: 0
        }

        .footer-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            gap: 30px;
            align-items: flex-start
        }

        .footer-logo {
            flex-shrink: 0;
            width: 200px
        }

        .footer-logo img {
            height: 40px;
            width: auto
        }

        .footer-logo p {
            margin-top: 8px;
            font-size: 11px;
            color: #ccc;
            line-height: 1.3
        }

        .footer-sections {
            display: flex;
            gap: 30px;
            flex: 1
        }

        .footer-main {
            display: flex;
            gap: 30px;
            flex: 1
        }

        .footer-right {
            display: flex;
            gap: 20px;
            align-items: flex-start
        }

        .footer-mascot {
            flex-shrink: 0
        }

        .footer-mascot img {
            height: 180px;
            width: auto
        }

        .footer-section {
            flex: 1
        }

        .footer-section h3 {
            font-size: 13px;
            margin-bottom: 10px;
            color: #fff;
            font-weight: 600
        }

        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0
        }

        .footer-section li {
            margin-bottom: 6px
        }

        .footer-section a {
            color: #ccc;
            text-decoration: none;
            font-size: 11px;
            transition: color 0.2s
        }

        .footer-section a:hover {
            color: #ff69b4
        }

        .footer-bottom {
            border-top: 1px solid #444;
            margin-top: 20px;
            padding-top: 15px;
            text-align: center;
            color: #999;
            font-size: 10px
        }

        @media(max-width:768px) {
            .footer-content {
                flex-direction: column;
                gap: 20px
            }

            .footer-sections {
                flex-direction: column;
                gap: 15px
            }

            .footer-section {
                text-align: center
            }
        }

        @media(max-width:480px) {
            .footer-content {
                flex-direction: column;
                gap: 30px
            }

            .footer-sections {
                flex-direction: column;
                gap: 20px
            }

            .footer-main {
                flex-direction: column;
                gap: 20px
            }

            .footer-right {
                width: 100%;
                flex-direction: column;
                align-items: center;
                gap: 15px;
                margin-top: 15px
            }

            .footer-mascot img {
                height: 120px
            }

            .footer-section {
                text-align: center
            }
        }


        .danmaku-comment-meta {
            display: none !important;
        }

        .danmaku-comment-text {
            overflow-wrap: anywhere;
            word-break: break-word;
            word-wrap: break-word;
        }

        .video-info a,
        .video-tags .video-tag,
        .related-info a,
        .video-carousel .video-info a {
            text-decoration: none;
        }

        .video-info a:hover,
        .related-info a:hover,
        .video-carousel .video-info a:hover {
            color: #ff69b4;
        }

        .related-meta-row {
            display: flex;
            align-items: flex-end;
            gap: 6px;
        }

        .channel-link {
            text-decoration: none;
            display: block;
        }

        .channel-avatar {
            width: 24px;
            height: 24px;
            background-color: #ff69b4;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            border: none !important;
            outline: none !important;
            box-shadow: none !important;
            -webkit-tap-highlight-color: transparent;
        }

        .channel-avatar.custom-avatar {
            background-color: transparent;
        }

        .related-channel-info {
            flex: 1;
            min-width: 0;
        }

        .related-channel {
            color: #ff69b4;
            text-decoration: none;
            font-size: 11px;
            line-height: 1.2;
            margin: 0;
            padding: 0;
        }

        .related-channel:hover {
            color: #ff1493;
        }

        .related-video:hover {
            box-shadow: none;
            transform: none;
            border-color: transparent;
        }

        .related-video:hover .related-title,
        .related-video:hover .related-meta,
        .related-video:hover .related-channel {
            color: #7a3c55;
        }

        .related-video:hover .related-title,
        .related-video:hover .related-meta,
        .related-video:hover .related-channel {
            color: #7a3c55;
        }

        .video-carousel .video-card:hover {
            transform: translateY(-2px);
        }

        .video-carousel .video-card:hover .video-card-title,
        .video-carousel .video-card:hover .video-playlist a {
            color: #7a3c55;
        }

        .video-container #danmakuOverlay,
        .video-container .danmaku-overlay {
            font-family: Arial, sans-serif !important;
        }

        .video-container .danmaku-item,
        .video-container .danmaku-text {
            font-size: 33px !important;
            line-height: 1.2 !important;
        }

        .video-container .danmaku-size-small {
            font-size: 33px !important;
        }

        .video-container .danmaku-size-normal {
            font-size: 33px !important;
        }

        .video-container .danmaku-size-big {
            font-size: 33px !important;
        }

        .video-container .danmaku-small {
            font-size: 33px !important;
        }

        .video-container .danmaku-normal {
            font-size: 33px !important;
        }

        .video-container .danmaku-big {
            font-size: 33px !important;
        }

        .video-container .danmaku-top,
        .video-container .danmaku-bottom,
        .video-container .danmaku-scroll {
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) !important;
        }



        .video-container .danmaku-item,
        .video-container .danmaku-text {
            white-space: nowrap !important;
            display: inline-block !important;
            line-height: 1.25 !important;
            padding: 2px 6px !important;
            box-sizing: content-box !important;
        }

        .video-container .danmaku-scroll {
            margin: 1px 0 !important;
            will-change: transform;
        }

        .video-container .danmaku-top,
        .video-container .danmaku-bottom {
            margin: 1px 0 !important;
        }

        .video-container #danmakuOverlay,
        .video-container .danmaku-overlay {
            font-family: inherit !important;
        }

        .video-container .danmaku-item,
        .video-container .danmaku-text {
            -webkit-text-stroke: 0.8px rgba(0, 0, 0, 0.75) !important;
            text-shadow: 0 1px 1.5px rgba(0, 0, 0, 0.5) !important;
            line-height: 1.35 !important;
            margin: 2px 0 !important;
            padding: 0 4px !important;
            font-weight: 400 !important;
        }

        .video-container.fullscreen .danmaku-item,
        .video-container.fullscreen .danmaku-text,
        body.cinema-mode .video-container .danmaku-item,
        body.cinema-mode .video-container .danmaku-text {
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.78) !important;
        }

        
        .multiview-overlay {
            z-index: 10000;
        }
        
        .multiview-search-panel {
            z-index: 10001;
        }
        
        .multiview-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 10000;
            display: none;
        }

        .multiview-backdrop.active {
            display: block;
        }

        .video-container.fullscreen .video-overlay,
        .video-container.fullscreen .danmaku-overlay {
            bottom: var(--fs-form-height, 0px) !important;
        }

        #danmakuToggleBtn {
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        #danmakuToggleBtn.active {
            color: #ffffff !important;
        }

        #danmakuToggleBtn:not(.active) {
            background: none;
            color: #ffffff;
        }

        #danmakuToggleBtn:hover {
            background: rgba(255, 255, 255, 0.2) !important;
        }

        .video-actions .action-btn {
            background: #fff;
            border: 1px solid #eee;
            color: #111;
            padding: 8px 14px;
        }

        .video-actions .action-btn:hover {
            border-color: #ff69b4;
            color: #ff69b4;
            background: #f9f9f9;
        }

        .video-actions .action-btn.favorite-active {
            background: #ff69b4;
            color: #fff;
            border-color: #ff69b4;
        }

        .video-actions .action-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 1.5;
        }

        .subscribe-btn {
            background: #ff69b4 !important;
            color: #fff !important;
            border: 1px solid #ff69b4 !important;
            padding: 8px 14px !important;
            border-radius: 4px !important;
            font-size: 13px !important;
            font-weight: 500 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }

        .subscribe-btn:hover {
            background: #d94b88 !important;
            border-color: #d94b88 !important;
        }

        .subscribe-btn.subscribed {
            background: #666 !important;
            border-color: #666 !important;
        }

        .subscribe-btn.subscribed:hover {
            background: #555 !important;
            border-color: #555 !important;
        }

        .ab-marker {
            position: absolute;
            top: -12px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 10px solid #ff69b4;
            z-index: 10;
            pointer-events: none;
            transform: translateX(-6px);
        }

        .ab-marker.a {
            border-top-color: #FF69B4;
        }

        .ab-marker.b {
            border-top-color: #FF1493;
        }

        body .player-section {
            margin-bottom: 0 !important;
        }

        .control-btn svg {
            width: 18px;
            height: 18px
        }

        .volume-btn svg {
            width: 18px;
            height: 18px
        }

        .play-btn svg {
            width: 18px;
            height: 18px
        }

        .fullscreen-btn svg {
            width: 18px;
            height: 18px
        }

        .control-btn,
        .volume-btn,
        .play-btn,
        .fullscreen-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn svg,
        .volume-btn svg,
        .play-btn svg,
        .fullscreen-btn svg {
            display: block;
            margin: 0;
        }

        .no-sidebar-transitions .sidebar,
        .no-sidebar-transitions .sidebar-item {
            transition: none !important;
        }

        /* Large screen adaptations - reduce empty space */
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1600px !important;
            }
            .right-sidebar {
                width: 360px;
            }
        }

        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1850px !important;
            }
            .right-sidebar {
                width: 400px;
            }
            .related-thumb {
                width: 180px !important;
                height: 101px !important;
            }
        }

        @media (min-width: 2400px) {
            .content-wrapper {
                max-width: 2200px !important;
            }
            .right-sidebar {
                width: 450px;
            }
            .related-thumb {
                width: 200px !important;
                height: 113px !important;
            }
        }

        @media (min-width: 2800px) {
            .content-wrapper {
                max-width: 2500px !important;
            }
            .right-sidebar {
                width: 500px;
            }
            .related-thumb {
                width: 220px !important;
                height: 124px !important;
            }
        }

        /* Sidebar collapsed - even wider content */
        @media (min-width: 1700px) {
            .sidebar-collapsed .content-wrapper {
                max-width: 1700px !important;
            }
        }

        @media (min-width: 2000px) {
            .sidebar-collapsed .content-wrapper {
                max-width: 1950px !important;
            }
        }

        @media (min-width: 2400px) {
            .sidebar-collapsed .content-wrapper {
                max-width: 2300px !important;
            }
        }

        @media (min-width: 2800px) {
            .sidebar-collapsed .content-wrapper {
                max-width: 2600px !important;
            }
        }
    </style>
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    <link rel="stylesheet" href="youvi/danmaku-counter.css">
    <link rel="stylesheet" href="youvi/timecode-loop/timecode-loop.css">
    <link rel="stylesheet" href="youvi/virtual-playlist/virtual-playlist.css">
    <link rel="stylesheet" href="youvi/multiview/multiview.css">

    <!-- Open Graph Meta Tags for Rich Bookmark Previews (100% local) -->
    <meta property="og:type" content="video.other">
    <meta property="og:site_name" content="Youvi">
    <meta property="og:title" content="">
    <meta property="og:description" content="">
    <meta property="og:image" content="">
    <meta property="og:url" content="">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="description" content="">

    <!-- Video Meta Tags Module -->
    <script src="youvi/meta/video-meta-tags.js"></script>
    
    <!-- Video ID System -->
    <script src="youvi/video-id.js"></script>
</head>
<link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">

<body>
    <script>
        if (window.__earlyClasses = document.documentElement.className) {
            document.body.className = window.__earlyClasses;
            document.documentElement.className = '';
        }
    </script>
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
            <a href="youvi_main.html" class="active" data-i18n="nav.video"></a>
            <a href="index.html" data-i18n="nav.management"></a>
            <a href="youvi_ch_list.html" data-i18n="nav.channels"></a>
            <a href="youvi_playlists_list.html" data-i18n="nav.playlists"></a>
            <a href="youvi_feed_all.html">Feed</a>
            <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
            <div class="lang-switcher" style="margin-left:auto;">
                <select id="langSwitcher" class="lang-select">
                    <option value="ru">RU</option>
                    <option value="en">EN</option>
                    <option value="uk">UK</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Header -->
    <!-- Header -->
    <header class="header">
        <div class="header-content-wrapper">
            <div class="header-left">
                <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle sidebar">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
                    </svg>
                </button>

                <div class="logo">
                    <a href="youvi_main.html">
                        <img src="images/logo_youvi_ind.png" alt="Youvi logo">
                    </a>
                </div>
            </div>

            <div class="header-center">
                <div class="search-area autocomplete-wrapper">
                    <input type="text" id="headerSearchInput" placeholder=" ..." class="search-input" data-i18n-placeholder="search.placeholder">
                    <button id="doSearch" class="search-btn" data-i18n="search.button"></button>
                </div>
            </div>

            <div class="header-right">
                <div class="user-actions">
                    <a href="#" id="multiviewHeaderBtn" title="Multiview (N)">Multiview</a>
                    <a href="#" id="hotkeysBtn" data-i18n="player.hotkeys" data-i18n-title="player.hotkeys" title="Hotkeys">Hotkeys</a>
                    <div class="settings-container">
                        <a href="#" class="settings-btn"></a>
                        <div class="theme-dropdown">
                            <button class="theme-dropdown-item" data-theme="light" data-i18n="themes.light"></button>
                            <button class="theme-dropdown-item" data-theme="dark" data-i18n="themes.dark"></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Early widescreen mode DOM rearrangement to prevent flash -->
        <script>
            (function () {
                if (localStorage.getItem('youvi_wide_mode') !== 'true') return;

                function rearrangeForWidescreen() {
                    const mainContent = document.querySelector('.main-content');
                    const rightSidebar = document.querySelector('.right-sidebar');
                    const playerSection = document.querySelector('.player-section');
                    const danmakuContent = document.querySelector('.danmaku-content');

                    if (!mainContent || !rightSidebar || !playerSection) {
                        setTimeout(rearrangeForWidescreen, 10);
                        return;
                    }

                    if (document.querySelector('.widescreen-bottom-layout')) return;

                    const bottomLayout = document.createElement('div');
                    bottomLayout.className = 'widescreen-bottom-layout';

                    const leftColumn = document.createElement('div');
                    leftColumn.className = 'widescreen-left-column';

                    const rightColumn = document.createElement('div');
                    rightColumn.className = 'widescreen-right-column';

                    const children = Array.from(mainContent.children);
                    children.forEach(child => {
                        if (child !== playerSection && child !== danmakuContent && child !== bottomLayout) {
                            leftColumn.appendChild(child);
                        }
                    });

                    rightColumn.appendChild(rightSidebar);

                    bottomLayout.appendChild(leftColumn);
                    bottomLayout.appendChild(rightColumn);

                    mainContent.appendChild(bottomLayout);
                }

                rearrangeForWidescreen();
            })();
        </script>
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation"></div>
                <a href="youvi_main.html" class="sidebar-item nav-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
                        <polyline points="9,22 9,12 15,12 15,22" />
                    </svg>
                    <span data-i18n="sidebar.home"></span>
                </a>
                <a href="youvi_feed_all.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 11a9 9 0 0 1 9 9" />
                        <path d="M4 4a16 16 0 0 1 16 16" />
                        <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z" />
                    </svg>
                    Feed
                </a>

                <a href="youvi_tags.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" />
                        <line x1="7" y1="7" x2="7.01" y2="7" />
                    </svg>
                    <span data-i18n="sidebar.allTags"> </span>
                </a>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library"></div>

                <a href="youvi_history.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10" />
                        <polyline points="12,6 12,12 16,14" />
                    </svg>
                    <span data-i18n="sidebar.history"></span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path
                            d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" />
                    </svg>
                    <span data-i18n="sidebar.favorites"></span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                        <line x1="8" y1="8" x2="16" y2="8" />
                        <line x1="8" y1="12" x2="16" y2="12" />
                        <line x1="8" y1="16" x2="16" y2="16" />
                        <circle cx="6" cy="8" r="1" />
                        <circle cx="6" cy="12" r="1" />
                        <circle cx="6" cy="16" r="1" />
                    </svg>
                    <span data-i18n="sidebar.playlists"></span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
                        <circle cx="9" cy="7" r="4" />
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87" />
                        <path d="M16 3.13a4 4 0 0 1 0 7.75" />
                    </svg>
                    <span data-i18n="sidebar.channels"></span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2" />
                        <polyline points="17,2 12,7 7,2" />
                    </svg>
                    <span data-i18n="sidebar.subscriptions"></span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle"></div>
                <div id="subscribedChannelsContainer"></div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.autoplay"></div>
                <div class="sidebar-item nav-item" id="autoplayToggle">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M5 3l14 9-14 9V3z" />
                        <path d="M19 3v18" />
                    </svg>
                    <span id="autoplayStatus" data-i18n="playerSettings.on"></span>
                </div>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="footer.pgc">PGC</div>
                <a href="youvi_main.html?tag=Anime (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M12 2l2.5 7.5H22l-6 4.5 2.5 7.5L12 17l-6.5 4.5L8 14 2 9.5h7.5z" />
                    </svg>
                    <span data-i18n="footer.categories.anime">Anime</span>
                </a>
                <a href="youvi_main.html?tag=Animation (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M23 7l-7 5 7 5V7z" />
                        <rect x="1" y="5" width="15" height="14" rx="2" ry="2" />
                    </svg>
                    <span data-i18n="footer.categories.animation">Animation</span>
                </a>
                <a href="youvi_main.html?tag=Movies (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18" />
                        <line x1="7" y1="2" x2="7" y2="22" />
                        <line x1="17" y1="2" x2="17" y2="22" />
                        <line x1="2" y1="12" x2="22" y2="12" />
                        <line x1="2" y1="7" x2="7" y2="7" />
                        <line x1="2" y1="17" x2="7" y2="17" />
                        <line x1="17" y1="17" x2="22" y2="17" />
                        <line x1="17" y1="7" x2="22" y2="7" />
                    </svg>
                    <span data-i18n="footer.categories.movies">Movies</span>
                </a>
                <a href="youvi_main.html?tag=Series (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="4" width="20" height="4" rx="1" />
                        <rect x="2" y="10" width="20" height="4" rx="1" />
                        <rect x="2" y="16" width="20" height="4" rx="1" />
                    </svg>
                    <span data-i18n="footer.categories.series">Series</span>
                </a>
                <a href="youvi_main.html?tag=Music (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M9 18V5l12-2v13" />
                        <circle cx="6" cy="18" r="3" />
                        <circle cx="18" cy="16" r="3" />
                    </svg>
                    <span data-i18n="footer.categories.music">Music</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="footer.ugc">UGC</div>
                <a href="youvi_main.html?tag=Games (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <line x1="6" y1="2" x2="6" y2="6" />
                        <line x1="18" y1="2" x2="18" y2="6" />
                        <line x1="6" y1="18" x2="6" y2="22" />
                        <line x1="18" y1="18" x2="18" y2="22" />
                        <rect x="2" y="6" width="20" height="12" rx="2" />
                        <circle cx="8" cy="12" r="2" />
                        <circle cx="16" cy="10" r="1" />
                        <circle cx="16" cy="14" r="1" />
                    </svg>
                    <span data-i18n="footer.categories.games">Games</span>
                </a>
                <a href="youvi_main.html?tag=Technology (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="3" width="20" height="14" rx="2" ry="2" />
                        <line x1="8" y1="21" x2="16" y2="21" />
                        <line x1="12" y1="17" x2="12" y2="21" />
                    </svg>
                    <span data-i18n="footer.categories.tech">Technology</span>
                </a>
                <a href="youvi_main.html?tag=Entertainment (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 14s1.5 2 4 2 4-2 4-2" />
                        <line x1="9" y1="9" x2="9.01" y2="9" />
                        <line x1="15" y1="9" x2="15.01" y2="9" />
                    </svg>
                    <span data-i18n="footer.categories.entertainment">Entertainment</span>
                </a>
                <a href="youvi_main.html?tag=IRL (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2" />
                        <circle cx="12" cy="7" r="4" />
                    </svg>
                    <span data-i18n="footer.categories.irl">IRL</span>
                </a>
                <a href="youvi_main.html?tag=TV (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2" />
                        <polyline points="17,2 12,7 7,2" /><text x="12" y="17" text-anchor="middle" font-size="8"
                            fill="#666" font-weight="bold" stroke="none">TV</text>
                    </svg>
                    <span data-i18n="footer.categories.tv">TV</span>
                </a>
                <a href="youvi_main.html?tag=Education (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20" />
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z" />
                    </svg>
                    <span data-i18n="footer.categories.education">Education</span>
                </a>
                <a href="youvi_main.html?tag=Other (ct)" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polyline points="16 3 21 3 21 8" />
                        <line x1="4" y1="20" x2="21" y2="3" />
                        <polyline points="21 16 21 21 16 21" />
                        <line x1="15" y1="15" x2="21" y2="21" />
                        <line x1="4" y1="4" x2="9" y2="9" />
                    </svg>
                    <span data-i18n="footer.categories.other">Other</span>
                </a>
            </div>

        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
            <!-- Main Content -->
            <main class="main-content">
                <!-- Video Player -->
                <div class="player-section">
                    <div class="video-player">
                        <div class="video-container" id="videoContainer">
                            <!--       Play -->
                            <div id="videoOverlay" class="video-overlay">
                                <img id="videoPreview" class="video-preview" alt="Preview">
                                <button id="bigPlayBtn" class="big-play-btn">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 24 24"
                                        fill="white" stroke="white" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-play-icon lucide-play">
                                        <path
                                            d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z" />
                                    </svg>
                                </button>
                            </div>
                            <!-- Loading spinner while video is loading/buffering -->
                            <div id="videoSpinner" class="loading-spinner"></div>

                            <video id="video" preload="auto" muted width="100%" height="100%" playsinline
                                webkit-playsinline></video>
                            <div id="videoClock" class="video-clock">00:00</div>
                            <img id="videoLogo" src="images/8site_mini_white.png" alt="8Site! logo" class="video-logo">
                            <div id="seekHud" class="speed-hud"></div>
                            <div id="volumeHud" class="volume-hud"></div>
                            <div id="videoHud" class="video-hud"></div> <!-- HUD   -->

                            <!-- Danmaku Panel Button (visible in theater/fullscreen) -->
                            <button id="danmakuPanelBtn" class="danmaku-panel-btn" data-i18n-title="comments.danmakuList" title="Danmaku list">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                                    <line x1="9" y1="10" x2="15" y2="10"/>
                                    <line x1="9" y1="14" x2="13" y2="14"/>
                                </svg>
                            </button>

                            <!-- Danmaku Panel Overlay -->
                            <div id="danmakuPanelOverlay" class="danmaku-panel-overlay">
                                <div class="danmaku-panel-header">
                                    <div class="danmaku-panel-title-wrap">
                                        <span class="danmaku-panel-title" data-i18n="comments.danmaku"></span>
                                        <span class="danmaku-panel-count" id="danmakuPanelCount">(0)</span>
                                    </div>
                                    <div class="danmaku-panel-controls">
                                        <button class="danmaku-panel-follow active" id="danmakuPanelFollow" data-i18n-title="comments.followDanmaku" title="Follow danmaku">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="10"/>
                                                <circle cx="12" cy="12" r="3"/>
                                            </svg>
                                        </button>
                                        <button class="danmaku-panel-close" id="danmakuPanelClose" data-i18n-title="player.close" title="Close">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <line x1="18" y1="6" x2="6" y2="18"/>
                                                <line x1="6" y1="6" x2="18" y2="18"/>
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                                <div class="danmaku-panel-list" id="danmakuPanelList">
                                    <div class="danmaku-panel-empty" data-i18n="comments.noDanmaku"> </div>
                                </div>
                            </div>

                            <!-- Danmaku Overlay -->
                            <div id="danmakuOverlay" class="danmaku-overlay"></div>
                            <div id="fullscreen-danmaku-overlay" class="danmaku-overlay"></div>
                            <!-- The original video element is already present above, so this line is redundant and removed. -->
                            <!-- The original video clock is already present above, so this line is redundant and removed. -->
                            <!-- The original fullscreenDanmakuFormOverlay is already present below, so this line is redundant and removed. -->
                            <!-- Fullscreen Danmaku Input Overlay (hidden by default) -->
                            <div id="fullscreenDanmakuFormOverlay"
                                style="display:none;position:absolute;left:0;right:0;bottom:0;padding:12px;pointer-events:none;z-index:10001;">
                            </div>


                            <!-- Danmaku Density Graph - Above progress bar -->
                            <div id="danmakuDensity" class="danmaku-density"></div>

                            <!-- Progress Bar - Above controls -->
                            <div class="progress-bar" id="progressBar">
                                <div class="progress-filled" id="progressBarFilled"></div>
                                <div class="progress-handle" id="progressHandle" role="slider" aria-label="Progress">
                                </div>
                                <div id="progressPreview" class="progress-preview">
                                    <canvas id="previewCanvas" width="160" height="90"></canvas>
                                    <span id="previewTime">0:00</span>
                                </div>
                            </div>

                            <div class="video-controls show">
                                <button class="play-btn" id="playPauseBtn">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="white" stroke="white" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-play-icon lucide-play">
                                        <path
                                            d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z" />
                                    </svg>
                                </button>
                                <span class="time-display" id="timeDisplay">0:00 / 0:00</span>
                                <div class="volume-container">
                                    <button class="volume-btn" id="volumeBtn">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                            stroke-linecap="round" stroke-linejoin="round"
                                            class="lucide lucide-volume2-icon lucide-volume-2">
                                            <path
                                                d="M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z" />
                                            <path d="M16 9a5 5 0 0 1 0 6" />
                                            <path d="M19.364 18.364a9 9 0 0 0 0-12.728" />
                                        </svg>
                                    </button>
                                    <input type="range" id="volumeSlider" min="0" max="100" step="0.01" value="100"
                                        class="volume-slider">
                                </div>
                                <div class="controls-spacer"></div>

                                <div class="settings-container">
                                    <button class="control-btn" id="settingsBtn" data-i18n-title="player.settings" title="Settings">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                            viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                            stroke-linecap="round" stroke-linejoin="round"
                                            class="lucide lucide-bolt-icon lucide-bolt">
                                            <path
                                                d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />
                                            <circle cx="12" cy="12" r="4" />
                                        </svg>
                                    </button>
                                    <div class="settings-menu" id="settingsMenu">
                                        <!-- Main Menu -->
                                        <div class="settings-main-menu" id="settingsMainMenu">
                                            <button class="settings-tab" data-tab="logo">
                                                <span data-i18n="playerSettings.logo"></span>
                                                <span class="settings-tab-value" id="logoTabValue" data-i18n="playerSettings.on"></span>
                                            </button>
                                            <button class="settings-tab" data-tab="clock">
                                                <span data-i18n="playerSettings.clock"></span>
                                                <span class="settings-tab-value" id="clockTabValue" data-i18n="playerSettings.off"></span>
                                            </button>
                                            <button class="settings-tab" data-tab="speed">
                                                <span data-i18n="playerSettings.speed"></span>
                                                <span class="settings-tab-value" id="speedTabValue">1x</span>
                                            </button>
                                            <button class="settings-tab" data-tab="dragseek">
                                                <span data-i18n="playerSettings.rewind"></span>
                                                <span class="settings-tab-value" id="dragSeekTabValue" data-i18n="playerSettings.on"></span>
                                            </button>
                                        </div>

                                        <!-- Logo Sub-menu -->
                                        <div class="settings-sub-menu" id="logoSettingsSubMenu">
                                            <div class="settings-sub-header">
                                                <button class="settings-back-btn" id="logoBackBtn">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M19 12H5" />
                                                        <path d="M12 19l-7-7 7-7" />
                                                    </svg>
                                                </button>
                                                <span class="settings-sub-title" data-i18n="playerSettings.logo"></span>
                                            </div>
                                            <div class="settings-sub-separator"></div>
                                            <div class="settings-sub-options">
                                                <button class="settings-option" id="toggleLogoBtn" data-i18n="playerSettings.off"></button>
                                                <button class="settings-option" id="toggleLogoTypeBtn" data-i18n="playerSettings.default">
                                                    </button>
                                            </div>
                                        </div>

                                        <!-- Clock Sub-menu -->
                                        <div class="settings-sub-menu" id="clockSettingsSubMenu">
                                            <div class="settings-sub-header">
                                                <button class="settings-back-btn" id="clockBackBtn">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M19 12H5" />
                                                        <path d="M12 19l-7-7 7-7" />
                                                    </svg>
                                                </button>
                                                <span class="settings-sub-title" data-i18n="playerSettings.clock"></span>
                                            </div>
                                            <div class="settings-sub-separator"></div>
                                            <div class="settings-sub-options">
                                                <button class="settings-option" id="toggleClockBtn" data-i18n="playerSettings.on"></button>
                                                <button class="settings-option"
                                                    id="toggleClockModeBtn" data-i18n="playerSettings.static"></button>
                                            </div>
                                        </div>

                                        <!-- Speed Sub-menu -->
                                        <div class="settings-sub-menu" id="speedSettingsSubMenu">
                                            <div class="settings-sub-header">
                                                <button class="settings-back-btn" id="speedBackBtn">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M19 12H5" />
                                                        <path d="M12 19l-7-7 7-7" />
                                                    </svg>
                                                </button>
                                                <span class="settings-sub-title" data-i18n="playerSettings.speed"></span>
                                            </div>
                                            <div class="settings-sub-separator"></div>
                                            <div class="settings-sub-options">
                                                <div style="padding: 12px; text-align: center;">
                                                    <div style="color: #fff; font-size: 14px; margin-bottom: 8px;">
                                                        <span id="speedSliderValue">1.00</span>x
                                                    </div>
                                                    <input type="range" id="speedSlider" min="0.25" max="3" step="0.25"
                                                        value="1" style="width: 100%; cursor: pointer;">
                                                    <div style="color: #999; font-size: 10px; margin-top: 6px;">
                                                        0.25 - 3.00
                                                    </div>
                                                </div>
                                                <button class="settings-option" data-speed="0.5">0.5x</button>
                                                <button class="settings-option" data-speed="0.75">0.75x</button>
                                                <button class="settings-option active" data-speed="1" data-i18n="playerSettings.normal">Normal</button>
                                                <button class="settings-option" data-speed="1.25">1.25x</button>
                                                <button class="settings-option" data-speed="1.5">1.5x</button>
                                                <button class="settings-option" data-speed="2">2x</button>
                                            </div>
                                        </div>

                                        <!-- Drag-to-Seek Sub-menu -->
                                        <div class="settings-sub-menu" id="dragseekSettingsSubMenu">
                                            <div class="settings-sub-header">
                                                <button class="settings-back-btn" id="dragseekBackBtn">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                                        viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                                        stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M19 12H5" />
                                                        <path d="M12 19l-7-7 7-7" />
                                                    </svg>
                                                </button>
                                                <span class="settings-sub-title" data-i18n="playerSettings.dragSeek"> </span>
                                            </div>
                                            <div class="settings-sub-separator"></div>
                                            <div class="settings-sub-options">
                                                <button class="settings-option active"
                                                    id="toggleDragSeekBtn" data-i18n="playerSettings.on"></button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <button class="control-btn" id="danmakuToggleBtn" data-i18n-title="comments.danmaku" title="Danmaku"
                                    style="display:inline-flex;align-items:center;justify-content:center;line-height:1">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round"
                                        class="lucide lucide-message-square-icon lucide-message-square">
                                        <path
                                            d="M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z" />
                                    </svg>
                                </button>
                                <button class="control-btn fs-danmaku-toggle" id="fsDanmakuToggleBtn"
                                    data-i18n-title="comments.toggleDanmakuForm" title="Show/hide danmaku form"
                                    style="display:none;align-items:center;justify-content:center;line-height:1">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-keyboard-icon lucide-keyboard">
                                        <path d="M10 8h.01" />
                                        <path d="M12 12h.01" />
                                        <path d="M14 8h.01" />
                                        <path d="M16 12h.01" />
                                        <path d="M18 8h.01" />
                                        <path d="M6 8h.01" />
                                        <path d="M7 16h10" />
                                        <path d="M8 12h.01" />
                                        <rect width="20" height="16" x="2" y="4" rx="2" />
                                    </svg>
                                </button>
                                <!--      -->
                                <button class="control-btn" id="resizeVideoBtn"
                                    data-i18n-title="player.resizeVideo" title="Fit / crop / stretch">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-scissors-icon lucide-scissors">
                                        <circle cx="6" cy="6" r="3" />
                                        <path d="M8.12 8.12 12 12" />
                                        <path d="M20 4 8.12 15.88" />
                                        <circle cx="6" cy="18" r="3" />
                                        <path d="M14.8 14.8 20 20" />
                                    </svg>
                                </button>
                                <!-- Picture-in-Picture button -->
                                <button class="control-btn" id="pipBtn" title="Picture-in-Picture"
                                    style="display:inline-flex;align-items:center;justify-content:center;line-height:1">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round"
                                        class="lucide lucide-picture-in-picture-icon lucide-picture-in-picture">
                                        <path d="M2 10h6V4" />
                                        <path d="m2 4 6 6" />
                                        <path d="M21 10V7a2 2 0 0 0-2-2h-7" />
                                        <path d="M3 14v2a2 2 0 0 0 2 2h3" />
                                        <rect x="12" y="14" width="10" height="7" rx="1" />
                                    </svg>
                                </button>
                                <button class="control-btn" id="cinemaModeBtn" data-i18n-title="player.cinemaMode" title="Cinema mode (T)"
                                    style="display:inline-flex;align-items:center;justify-content:center;line-height:1">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-theater-icon lucide-theater">
                                        <path d="M2 10s3-3 3-8" />
                                        <path d="M22 10s-3-3-3-8" />
                                        <path d="M10 2c0 4.4-3.6 8-8 8" />
                                        <path d="M14 2c0 4.4 3.6 8 8 8" />
                                        <path d="M2 10s2 2 2 5" />
                                        <path d="M22 10s-2 2-2 5" />
                                        <path d="M8 15h8" />
                                        <path d="M2 22v-1a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1" />
                                        <path d="M14 22v-1a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v1" />
                                    </svg>
                                </button>
                                <button class="control-btn hide-in-fullscreen" id="multiviewBtn" title="Multiview (N)"
                                    style="display:none;align-items:center;justify-content:center;line-height:1">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round">
                                        <rect x="2" y="3" width="9" height="8" rx="1"/>
                                        <rect x="13" y="3" width="9" height="8" rx="1"/>
                                        <rect x="2" y="13" width="9" height="8" rx="1"/>
                                        <rect x="13" y="13" width="9" height="8" rx="1"/>
                                    </svg>
                                </button>
                                <button class="fullscreen-btn" id="fullscreenBtn">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round" class="lucide lucide-maximize-icon lucide-maximize">
                                        <path d="M8 3H5a2 2 0 0 0-2 2v3" />
                                        <path d="M21 8V5a2 2 0 0 0-2-2h-3" />
                                        <path d="M3 16v3a2 2 0 0 0 2 2h3" />
                                        <path d="M16 21h3a2 2 0 0 0 2-2v-3" />
                                    </svg>
                                </button>
                            </div>

                            <!-- Mini-player style progress bar for normal/theater modes -->
                            <div class="mini-progress-bar" id="miniProgressBar">
                                <div class="mini-progress-track"></div>
                                <div class="mini-progress-fill" id="miniProgressFill"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Danmaku Section -->
                <div class="danmaku-content" id="danmakuContent">
                    <div class="danmaku-form">
                        <div class="danmaku-controls">
                            <select id="danmakuColor">
                                <option value="#ffffff" data-i18n="comments.white"></option>
                                <option value="#ff0000" data-i18n="comments.red"></option>
                                <option value="#00ff00" data-i18n="comments.green"></option>
                                <option value="#0000ff" data-i18n="comments.blue"></option>
                                <option value="#ffff00" data-i18n="comments.yellow"></option>
                                <option value="#ff69b4" data-i18n="comments.pink"></option>
                            </select>
                            <select id="danmakuSize" style="display: none;">
                                <option value="small" data-i18n="comments.small"></option>
                                <option value="normal" selected data-i18n="comments.normal"></option>
                                <option value="large" data-i18n="comments.large"></option>
                            </select>
                            <select id="danmakuPos">
                                <option value="scroll" selected data-i18n="comments.scroll"></option>
                                <option value="top" data-i18n="comments.top"></option>
                            </select>
                        </div>
                        <div class="danmaku-input">
                            <input type="text" id="danmakuText" data-i18n-placeholder="comments.placeholder" placeholder=" ..." maxlength="50">
                            <button type="button" id="danmakuKaomojiBtn" class="kaomoji-picker-btn compact"
                                data-i18n-title="comments.insertKaomoji" title="Insert kaomoji"
                                style="background: none; border: 1px solid #ddd; padding: 5px 8px; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 14px; width: 40px; height: 26px; flex-shrink: 0;">
                                (^^)
                            </button>
                        </div>
                        <button id="sendDanmaku" data-i18n-title="comments.send" title="Send">
                            <svg viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="1.8"
                                stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <path d="M22 2L11 13" />
                                <path d="M22 2L15 22L11 13L2 9L22 2Z" />
                            </svg>
                        </button>
                    </div>
                </div>
                <!-- Anchor to restore danmaku form after exiting fullscreen -->
                <div id="danmakuFormAnchor" style="display:none"></div>

                <!-- Video Info -->
                <div class="video-info">
                    <h1 class="video-title" id="videoTitle" data-i18n="video.skeletonTitle"> </h1>
                    <div class="video-meta">
                        <span id="videoViews">0 <span data-i18n="video.views"></span></span>
                        <span></span>
                        <span id="videoLikes">0 <span data-i18n="video.likes"></span></span>
                        <span></span>
                        <span id="videoDislikes">0 <span data-i18n="video.dislikes"></span></span>
                        <span></span>
                        <span id="videoDate"></span>
                        <span></span>
                        <span id="videoCategory"></span>
                    </div>
                    <div class="video-actions">
                        <!-- Channel Info (left side) -->
                        <div class="channel-info-left">
                            <div class="uploader-avatar" id="uploaderAvatar">U</div>
                            <div class="uploader-name" id="uploaderName">...</div>
                            <button class="subscribe-btn" id="subscribeBtn" data-i18n="video.subscribe"></button>
                        </div>

                        <div class="actions-right">
                            <button class="action-btn" id="likeBtn" data-i18n-title="video.like">
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                </svg>
                                <span data-i18n="video.like">.</span>
                            </button>
                            <button class="action-btn" id="dislikeBtn" data-i18n-title="video.dislike">
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                </svg>
                                <span data-i18n="video.dislike"> .</span>
                            </button>
                            <button class="action-btn" id="favoriteBtn" data-i18n-title="favorites.addToFavorites">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" />
                                </svg>
                                <span data-i18n="favorites.addToFavorites">Add to favorites</span>
                            </button>
                            <button class="action-btn" id="downloadBtn" data-i18n-title="video.download">
                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 3v12m0 0l-4-4m4 4l4-4M5 21h14" />
                                </svg>
                                <span data-i18n="video.download"></span>
                            </button>
                        </div>
                    </div>

                    <div class="video-tags" id="videoTags"></div>

                    <!-- Tags Edit Form -->
                    <div class="tags-edit-form" id="tagsEditForm" style="display: none;">
                        <div class="tags-edit-controls">
                            <input type="text" id="tagsEditInput" data-i18n-placeholder="video.enterTagsPlaceholder" placeholder="Enter tags separated by commas..." value="">
                            <div class="tag-type-hint">
                                <strong>Format:</strong> Name (type). Types: (ka)=channel, (gt)=general, (ch)=character,
                                (au)=author, (ge)=genre, (tp)=type, (yr)=year, (st)=studio, (ct)=category, (ra)=rating,
                                (at)=anime, (ser)=series, (mt)=movie, (nat)=animation
                            </div>
                        </div>
                        <div class="tags-edit-actions">
                            <button class="tags-edit-cancel" id="tagsEditCancel" data-i18n="video.cancel"></button>
                            <button class="tags-edit-save" id="tagsEditSave" data-i18n="video.save"></button>
                        </div>
                    </div>
                </div>

                <!-- Video Description (Collapsible) -->
                <div class="video-description">
                    <div class="description-header" id="descriptionHeader">
                        <h3 data-i18n="video.description"></h3>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <a href="#" class="edit-description-btn" id="editDescriptionBtn" data-i18n-title="video.editDescription">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                                </svg>
                            </a>
                            <button class="description-toggle" id="descriptionToggle">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6,9 12,15 18,9" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="description-content" id="descriptionContent">
                        <div class="description-text" id="descriptionText">
                             .        ,   
                            .

                             
                        </div>

                        <!-- Description Edit Form -->
                        <div class="description-edit-form" id="descriptionEditForm">
                            <div class="description-edit-controls">
                                <textarea id="descriptionEditInput" data-i18n-placeholder="video.enterDescriptionPlaceholder" placeholder="  ..."> .        ,    .
 </textarea>
                            </div>
                            <div class="description-edit-actions">
                                <button class="description-edit-cancel" id="descriptionEditCancel" data-i18n="video.cancel"></button>
                                <button class="description-edit-save" id="descriptionEditSave" data-i18n="video.save"></button>
                            </div>
                        </div>

                    </div>
                </div>

                <style>
                    .parent-child-section {
                        position: relative;
                        background: white;
                        border-radius: 4px;
                        padding: 6px;
                        margin-bottom: 8px;
                        border: 1px solid #eee;
                        min-width: 0;
                        box-sizing: border-box;
                        overflow: visible;
                    }

                    .pc-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 6px;
                        padding: 0 8px;
                    }

                    .pc-header h3 {
                        font-size: 16px;
                        font-weight: 500;
                        color: #333;
                        margin: 0;
                        line-height: 1.2;
                        flex: 1
                    }

                    .pc-add-btn-wrapper {
                        position: relative;
                    }

                    .pc-carousel-container {
                        margin-bottom: 10px;
                        min-width: 0;
                        overflow: hidden;
                    }

                    .pc-carousel-container:last-child {
                        margin-bottom: 0;
                    }

                    .pc-carousel-container h4 {
                        font-size: 11px;
                        color: #666;
                        margin-bottom: 6px;
                        margin-left: 8px;
                        font-weight: 500;
                        text-transform: uppercase;
                        letter-spacing: 0.5px;
                    }

                    .pc-carousel-wrapper {
                        position: relative;
                        min-width: 0;
                        max-width: 100%;
                        overflow: hidden;
                        padding: 0 20px;
                        display: flex;
                        align-items: center;
                    }

                    .pc-carousel {
                        display: flex;
                        gap: 10px;
                        overflow-x: auto;
                        overflow-y: hidden;
                        padding-bottom: 8px;
                        padding-left: 2px;
                        padding-right: 2px;
                        scroll-behavior: smooth;
                        scrollbar-width: none;
                        -ms-overflow-style: none;
                        min-width: 0;
                        flex-wrap: nowrap;
                        width: 0;
                        flex: 1;
                    }

                    .pc-carousel::-webkit-scrollbar {
                        display: none;
                    }

                    .pc-nav-btn {
                        position: absolute;
                        top: 50%;
                        transform: translateY(-70%);
                        width: 28px;
                        height: 28px;
                        border-radius: 50%;
                        background: rgba(255, 255, 255, 0.95);
                        border: 1px solid #ddd;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        color: #333;
                        z-index: 10;
                        transition: all 0.2s;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                    }

                    .pc-nav-btn:hover {
                        background: #ff69b4;
                        color: white;
                        border-color: #ff69b4;
                    }

                    .pc-nav-btn.prev {
                        left: 0;
                    }

                    .pc-nav-btn.next {
                        right: 0;
                    }

                    .pc-nav-btn:disabled {
                        opacity: 0.3;
                        cursor: default;
                        pointer-events: none;
                    }

                    .pc-video-card {
                        width: 160px;
                        flex-shrink: 0;
                        cursor: pointer;
                        position: relative;
                        display: flex;
                        flex-direction: column;
                    }

                    .pc-video-card:hover .pc-video-thumb {
                        opacity: 0.9;
                    }

                    .pc-video-thumb {
                        width: 100%;
                        aspect-ratio: 16/9;
                        background: #eee;
                        border-radius: 6px;
                        margin-bottom: 7px;
                        position: relative;
                        overflow: hidden;
                    }

                    .pc-video-thumb img {
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                        border-radius: 6px;
                    }

                    .pc-video-thumb.loading {
                        background: linear-gradient(90deg, #eee 25%, #f5f5f5 50%, #eee 75%);
                        background-size: 200% 100%;
                        animation: pc-skeleton 1.5s infinite;
                    }

                    @keyframes pc-skeleton {
                        0% { background-position: 200% 0; }
                        100% { background-position: -200% 0; }
                    }

                    .pc-video-duration {
                        position: absolute;
                        bottom: 5px;
                        right: 5px;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 2px 4px;
                        font-size: 11px;
                        border-radius: 2px;
                    }

                    .pc-video-title {
                        font-size: 13px;
                        color: #111;
                        line-height: 1.3;
                        margin-bottom: 3px;
                        display: -webkit-box;
                        -webkit-line-clamp: 2;
                        -webkit-box-orient: vertical;
                        overflow: hidden;
                        word-wrap: break-word;
                    }

                    .pc-video-title a {
                        color: inherit;
                        text-decoration: none;
                    }

                    .pc-video-title a:hover {
                        color: #ff69b4;
                    }

                    .pc-video-info {
                        min-width: 0;
                    }

                    .pc-video-channel {
                        font-size: 11px;
                        color: #ff69b4;
                        margin-bottom: 2px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                        cursor: pointer;
                        transition: opacity 0.2s;
                    }

                    .pc-video-channel:hover {
                        opacity: 0.8;
                        text-decoration: underline;
                    }

                    .pc-video-views {
                        font-size: 11px;
                        color: #666;
                    }

                    .pc-remove-btn {
                        position: absolute;
                        top: 5px;
                        right: 5px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        border: none;
                        border-radius: 4px;
                        width: 22px;
                        height: 22px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        opacity: 0;
                        transition: all 0.2s;
                        font-size: 14px;
                        line-height: 1;
                        z-index: 10;
                    }

                    .pc-remove-btn:hover {
                        background: #ff69b4;
                    }

                    .pc-video-card:hover .pc-remove-btn {
                        opacity: 1;
                    }

                    .pc-search-panel {
                        position: absolute;
                        top: 100%;
                        right: 0;
                        margin-top: 5px;
                        width: 350px;
                        background: white;
                        border: 1px solid #ddd;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
                        border-radius: 6px;
                        z-index: 1000;
                        padding: 15px;
                        display: flex;
                        flex-direction: column;
                        max-height: 500px;
                    }

                    .pc-search-title {
                        margin: 0 0 10px 0;
                        font-size: 14px;
                        color: #333;
                    }

                    .dark-theme .pc-search-panel {
                        background: #2a2a2a;
                        border-color: #444;
                        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
                    }

                    .dark-theme .pc-search-title {
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-search-input-wrapper input {
                        background: #333;
                        border-color: #555;
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-search-input-wrapper input::placeholder {
                        color: #888;
                    }

                    .dark-theme .pc-search-results {
                        border-color: #444;
                        background: #252525;
                    }

                    .dark-theme .pc-search-item {
                        border-bottom-color: #333;
                    }

                    .dark-theme .pc-search-item:hover {
                        background: #333;
                    }

                    .dark-theme .pc-search-item.selected {
                        background: #3d2a35;
                    }

                    .dark-theme .pc-search-item-thumb {
                        background: #333;
                    }

                    .dark-theme .pc-search-item-thumb.loading {
                        background: linear-gradient(90deg, #333 25%, #3a3a3a 50%, #333 75%);
                        background-size: 200% 100%;
                    }

                    .dark-theme .pc-search-item div {
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-btn-secondary {
                        background: #444;
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-btn-secondary:hover {
                        background: #555;
                    }

                    .dark-theme .pc-empty-state {
                        background: #252525;
                        color: #888;
                        border-color: #444;
                    }

                    .dark-theme .pc-video-card {
                        background: transparent;
                    }

                    .dark-theme .pc-video-card:hover {
                        background: transparent;
                    }

                    .dark-theme .pc-video-thumb {
                        background: #333;
                    }

                    .dark-theme .pc-video-thumb.loading {
                        background: linear-gradient(90deg, #333 25%, #3a3a3a 50%, #333 75%);
                        background-size: 200% 100%;
                    }

                    .dark-theme .pc-video-title a {
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-video-channel {
                        color: #ff69b4;
                    }

                    .dark-theme .pc-video-views {
                        color: #888;
                    }

                    .dark-theme .pc-remove-btn {
                        background: #444;
                        color: #ccc;
                    }

                    .dark-theme .pc-remove-btn:hover {
                        background: #c0392b;
                        color: white;
                    }

                    .dark-theme .parent-child-section {
                        background: #1e1e1e;
                        border-color: #333;
                    }

                    .dark-theme .pc-header h3 {
                        color: #e0e0e0;
                    }

                    .dark-theme .pc-carousel-label {
                        color: #aaa;
                    }

                    .dark-theme .pc-nav-btn {
                        background: #333;
                        color: #ccc;
                        border-color: #444;
                    }

                    .dark-theme .pc-nav-btn:hover:not(:disabled) {
                        background: #444;
                    }

                    .pc-search-input-wrapper {
                        margin-bottom: 10px;
                    }

                    .pc-search-input-wrapper input {
                        width: 100%;
                        padding: 8px 10px;
                        border: 1px solid #ddd;
                        border-radius: 4px;
                        font-size: 13px;
                        box-sizing: border-box;
                    }

                    .pc-search-input-wrapper input:focus {
                        outline: none;
                        border-color: #ff69b4;
                    }

                    .pc-search-results {
                        flex: 1;
                        overflow-y: auto;
                        border: 1px solid #f0f0f0;
                        margin-bottom: 10px;
                        min-height: 150px;
                        max-height: 300px;
                        border-radius: 4px;
                    }

                    .pc-search-item {
                        padding: 8px;
                        border-bottom: 1px solid #f9f9f9;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        transition: background 0.1s;
                    }

                    .pc-search-item:last-child {
                        border-bottom: none;
                    }

                    .pc-search-item:hover {
                        background: #f5f5f5;
                    }

                    .pc-search-item.selected {
                        background: #fff0f7;
                    }

                    .pc-search-item-thumb {
                        width: 100px;
                        height: 56px;
                        background: #eee;
                        border-radius: 4px;
                        flex-shrink: 0;
                        background-size: cover;
                        background-position: center;
                        position: relative;
                    }

                    .pc-search-item-thumb.loading {
                        background: linear-gradient(90deg, #eee 25%, #f5f5f5 50%, #eee 75%);
                        background-size: 200% 100%;
                        animation: pc-skeleton 1.5s infinite;
                    }

                    .pc-search-item-thumb img {
                        width: 100%;
                        height: 100%;
                        object-fit: cover;
                        border-radius: 4px;
                    }

                    .pc-search-item-duration {
                        position: absolute;
                        bottom: 2px;
                        right: 2px;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 1px 3px;
                        font-size: 9px;
                        border-radius: 2px;
                    }

                    .pc-search-actions {
                        display: flex;
                        gap: 8px;
                        justify-content: flex-end;
                        flex-wrap: wrap;
                    }

                    .pc-search-actions button {
                        padding: 6px 12px;
                        border-radius: 4px;
                        border: none;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 500;
                        transition: background 0.2s;
                    }

                    .pc-btn-primary {
                        background: #ff69b4;
                        color: white;
                    }

                    .pc-btn-primary:hover {
                        background: #d94b88;
                    }

                    .pc-btn-secondary {
                        background: #f5f5f5;
                        color: #333;
                    }

                    .pc-btn-secondary:hover {
                        background: #e5e5e5;
                    }

                    .pc-empty-state {
                        padding: 30px;
                        text-align: center;
                        color: #999;
                        font-size: 13px;
                        width: 100%;
                        background: #fafafa;
                        border-radius: 4px;
                        border: 1px dashed #eee;
                    }

                    @media (max-width: 1200px) {
                        .pc-video-card {
                            width: 150px;
                        }
                        
                        .pc-search-panel {
                            width: 320px;
                        }
                    }

                    @media (max-width: 992px) {
                        .pc-video-card {
                            width: 140px;
                        }
                        
                        .pc-carousel-wrapper {
                            padding: 0 15px;
                        }
                    }

                    @media (max-width: 768px) {
                        .parent-child-section {
                            padding: 8px;
                        }
                        
                        .pc-header h3 {
                            font-size: 14px;
                        }
                        
                        .pc-video-card {
                            width: 130px;
                        }
                        
                        .pc-carousel-wrapper {
                            padding: 0 10px;
                        }
                        
                        .pc-nav-btn {
                            width: 24px;
                            height: 24px;
                            font-size: 10px;
                        }
                        
                        .pc-search-panel {
                            width: 280px;
                            max-height: 400px;
                        }
                    }

                    @media (max-width: 576px) {
                        .parent-child-section {
                            padding: 6px;
                            margin-bottom: 6px;
                        }
                        
                        .pc-header {
                            padding: 0 4px;
                        }
                        
                        .pc-video-card {
                            width: 120px;
                        }
                        
                        .pc-video-title {
                            font-size: 12px;
                        }
                        
                        .pc-video-channel,
                        .pc-video-views {
                            font-size: 10px;
                        }
                        
                        .pc-carousel {
                            gap: 8px;
                        }
                        
                        .pc-search-panel {
                            width: calc(100vw - 40px);
                            right: -10px;
                        }
                    }

                    @media (max-width: 480px) {
                        .pc-header h3 {
                            font-size: 13px;
                        }
                        
                        .pc-video-card {
                            width: 110px;
                        }
                        
                        .pc-carousel-wrapper {
                            padding: 0 8px;
                        }
                        
                        .pc-nav-btn {
                            width: 20px;
                            height: 20px;
                            font-size: 9px;
                        }
                        
                        .action-btn {
                            padding: 6px 12px;
                            font-size: 11px;
                        }
                    }

                    @media (max-width: 400px) {
                        .parent-child-section {
                            margin: 0 0 6px 0;
                            padding: 4px;
                        }
                        
                        .pc-video-card {
                            width: 100px;
                        }
                        
                        .pc-video-title {
                            font-size: 11px;
                        }
                        
                        .pc-carousel {
                            gap: 6px;
                        }
                    }
                </style>

                <div class="parent-child-section" id="parentChildSection">
                    <div class="pc-header">
                        <h3 data-i18n="video.relatedVideosSection"> </h3>
                        <div class="pc-add-btn-wrapper">
                            <button id="addRelatedVideoBtn" class="action-btn">
                                <svg viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2"
                                    fill="none">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                <span data-i18n="video.add"></span>
                            </button>
                            <!-- Search Panel - positioned relative to button -->
                            <div id="relatedVideoSearchPanel" class="pc-search-panel" style="display:none;">
                                <h4 class="pc-search-title" data-i18n="video.addRelatedVideo">  </h4>
                                <div class="pc-search-input-wrapper">
                                    <input type="text" id="relatedSearchInput" data-i18n-placeholder="video.searchByTitleOrTag" placeholder="Search by title or tag..."
                                        autocomplete="off">
                                </div>
                                <div id="relatedSearchResults" class="pc-search-results">
                                    <!-- Results populated via JS -->
                                </div>
                                <div class="pc-search-actions">
                                    <button id="addSelectedToChildrenBtn" class="pc-btn-primary">Child</button>
                                    <button id="addSelectedToParentsBtn" class="pc-btn-primary">Parent</button>
                                    <button id="closeRelatedSearchBtn" class="pc-btn-secondary" data-i18n="video.cancel"></button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Child Videos (Top) -->
                    <div class="pc-carousel-container">
                        <h4 data-i18n="video.childVideos">Child </h4>
                        <div class="pc-carousel-wrapper">
                            <button class="pc-nav-btn prev" data-carousel="childVideosCarousel"></button>
                            <div class="pc-carousel" id="childVideosCarousel">
                                <div class="pc-empty-state" data-i18n="video.childVideosEmpty">Child   </div>
                            </div>
                            <button class="pc-nav-btn next" data-carousel="childVideosCarousel"></button>
                        </div>
                    </div>

                    <!-- Parent Videos (Bottom) -->
                    <div class="pc-carousel-container">
                        <h4 data-i18n="video.parentVideos">Parent </h4>
                        <div class="pc-carousel-wrapper">
                            <button class="pc-nav-btn prev" data-carousel="parentVideosCarousel"></button>
                            <div class="pc-carousel" id="parentVideosCarousel">
                                <div class="pc-empty-state" data-i18n="video.parentVideosEmpty">Parent   </div>
                            </div>
                            <button class="pc-nav-btn next" data-carousel="parentVideosCarousel"></button>
                        </div>
                    </div>
                </div>


                <!-- Comments Section -->
                <div id="commentsContainer"></div>

                <div class="playlist-section-header">
                    <h2 class="playlist-section-title" data-i18n="video.currentPlaylist"> </h2>
                    <a href="#" class="playlist-section-all-link" id="currentPlaylistAllLink" data-i18n="main.openAll"> </a>
                </div>
                <div class="video-carousel-wrapper">
                    <button class="carousel-nav-btn prev-btn" id="currentPlaylistPrev" data-playlist-type="current"
                        data-playlist-id="currentPlaylistCarousel">&#9664;</button>
                    <div class="video-carousel" id="currentPlaylistCarousel"></div>
                    <button class="carousel-nav-btn next-btn" id="currentPlaylistNext" data-playlist-type="current"
                        data-playlist-id="currentPlaylistCarousel">&#9654;</button>
                </div>

                <div class="playlist-section-header">
                    <h2 class="playlist-section-title" data-i18n="video.folderPlaylist">  </h2>
                    <a href="#" class="playlist-section-all-link" id="folderPlaylistAllLink" data-i18n="main.openAll"> </a>
                </div>
                <div class="video-carousel-wrapper">
                    <button class="carousel-nav-btn prev-btn" id="folderPlaylistPrev"
                        data-playlist-type="folder">&#9664;</button>
                    <div class="video-carousel" id="folderPlaylistCarousel"></div>
                    <button class="carousel-nav-btn next-btn" id="folderPlaylistNext"
                        data-playlist-type="folder">&#9654;</button>
                </div>

            </main>

            <!-- Right Sidebar -->
            <aside class="right-sidebar">
                <!-- Combined Danmaku & Playlist Panel -->
                <div class="sidebar-panel-combined" id="sidebarPanelCombined">
                    <!-- Tabs Header -->
                    <div class="sidebar-panel-tabs">
                        <div class="sidebar-tabs-left">
                            <button class="sidebar-panel-tab active" data-tab="danmaku">
                                <span data-i18n="comments.danmaku"></span> <span id="danmakuCommentsCount">0</span>
                            </button>
                            <button class="sidebar-panel-tab" data-tab="playlist">
                                <span data-i18n="video.playlist"></span>
                            </button>
                        </div>
                        <div class="sidebar-panel-controls" id="danmakuControls">
                            <button class="sidebar-panel-btn" id="sidebarFollowBtn" data-i18n-title="comments.followDanmaku" title="Follow danmaku">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <circle cx="12" cy="12" r="3"/>
                                </svg>
                            </button>
                            <button class="sidebar-panel-btn" id="clearDanmakuBtn" data-i18n-title="comments.clearDanmaku" title="Clear danmaku">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"/>
                                    <line x1="6" y1="6" x2="18" y2="18"/>
                                </svg>
                            </button>
                            <button class="right-sidebar-collapse-btn" id="rightSidebarCollapseBtn" data-i18n-title="player.collapsePanel" title="Collapse/expand panel">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="9 18 15 12 9 6"/>
                                </svg>
                            </button>
                        </div>
                        <div class="sidebar-panel-controls" id="playlistControls" style="display:none;">
                            <button class="sidebar-panel-btn" id="playlistToggle" data-i18n-title="video.togglePlaylist" title="Toggle playlist">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M3 6h18M3 12h18M3 18h18"/>
                                </svg>
                            </button>
                            <button class="right-sidebar-collapse-btn" id="rightSidebarCollapseBtnPlaylist" data-i18n-title="player.collapsePanel" title="Collapse/expand panel">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="9 18 15 12 9 6"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <!-- Tab Content -->
                    <div class="sidebar-panel-content">
                        <!-- Danmaku Tab -->
                        <div class="sidebar-tab-content active" id="danmakuTabContent">
                            <div id="danmakuCommentsList"></div>
                        </div>
                        <!-- Playlist Tab -->
                        <div class="sidebar-tab-content" id="playlistTabContent">
                            <div id="playlistHeader" style="display:none;padding:6px 10px;border-bottom:1px solid #eee;background:#fafafa;">
                                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                                    <span id="playlistTitle" style="font-size:12px;font-weight:600;color:#666;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
                                    <a id="playlistOpenLink" href="#" target="_blank" data-i18n-title="playlists.openPlaylist" title="Open playlist" style="color:#999;display:flex;align-items:center;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                                            <polyline points="15 3 21 3 21 9"/>
                                            <line x1="10" y1="14" x2="21" y2="3"/>
                                        </svg>
                                    </a>
                                </div>
                                <div id="playlistControls2" style="display:flex;gap:4px;margin-top:6px;">
                                    <button id="playlistInvertBtn" class="playlist-control-btn" data-i18n-title="playlists.invert" title="Invert">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="12" y1="5" x2="12" y2="19"/>
                                            <polyline points="19 12 12 19 5 12"/>
                                            <line x1="12" y1="5" x2="12" y2="5"/>
                                            <polyline points="5 8 12 1 19 8"/>
                                        </svg>
                                    </button>
                                    <button id="playlistLoopBtn" class="playlist-control-btn" data-i18n-title="playlists.loopPlaylist" title="Loop playlist">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <polyline points="17 1 21 5 17 9"/>
                                            <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                                            <polyline points="7 23 3 19 7 15"/>
                                            <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                                        </svg>
                                    </button>
                                    <button id="playlistShuffleBtn" class="playlist-control-btn" data-i18n-title="playlists.shuffle" title="Shuffle">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <polyline points="16 3 21 3 21 8"/>
                                            <line x1="4" y1="20" x2="21" y2="3"/>
                                            <polyline points="21 16 21 21 16 21"/>
                                            <line x1="15" y1="15" x2="21" y2="21"/>
                                            <line x1="4" y1="4" x2="9" y2="9"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="playlistContent"></div>
                        </div>
                    </div>
                </div>

                <!-- Recommendations -->
                <div class="sidebar-section-right" id="recommendationsSidebar">
                    <div class="section-title-right" data-i18n="video.relatedVideos"> </div>
                </div>
            </aside>
        </div><!-- /content-wrapper -->
    </div>

    <script src="youvi/comments/paginator.js"></script>
    <script>
        (function () {
            const s = document.createElement('script');
            s.src = 'player/mini-player/mini-player.js';
            s.defer = true;
            document.head.appendChild(s);
        })();
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const throttle = (func, limit) => {
            let inThrottle;
            return function (...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        };

        const lazyLoadObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                        observer.unobserve(img);
                    }
                }
            });
        }, {
            rootMargin: '50px 0px',
            threshold: 0.01
        });

        window.requestIdleCallback = window.requestIdleCallback || function (cb) {
            const start = Date.now();
            return setTimeout(() => {
                cb({
                    didTimeout: false,
                    timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
                });
            }, 1);
        };

        window.cancelIdleCallback = window.cancelIdleCallback || function (id) {
            clearTimeout(id);
        };

        const batchDOMUpdates = (() => {
            let scheduled = false;
            const updates = [];

            return (updateFn) => {
                updates.push(updateFn);

                if (!scheduled) {
                    scheduled = true;
                    requestAnimationFrame(() => {
                        const fragment = document.createDocumentFragment();
                        updates.forEach(fn => fn(fragment));
                        updates.length = 0;
                        scheduled = false;
                    });
                }
            };
        })();

        const delegateEvent = (selector, eventType, handler) => {
            document.addEventListener(eventType, (e) => {
                const target = e.target.closest(selector);
                if (target) {
                    handler.call(target, e);
                }
            }, { passive: true });
        };

        const preloadResource = (url, as = 'fetch') => {
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = url;
            link.as = as;
            document.head.appendChild(link);
        };

        const optimizeVideoBuffer = (videoElement) => {
            if (!videoElement) return;

            if (videoElement.buffered && videoElement.buffered.length > 0) {
                const bufferedEnd = videoElement.buffered.end(0);
                const currentTime = videoElement.currentTime;

                if (bufferedEnd - currentTime > 30) {
                    videoElement.preload = 'none';
                } else {
                    videoElement.preload = 'metadata';
                }
            }
        };

        const deferInit = (initFn, delay = 100) => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(initFn, { timeout: delay + 1000 });
            } else {
                setTimeout(initFn, delay);
            }
        };

        const loadImageOptimized = (src, callback) => {
            const img = new Image();
            img.decoding = 'async';
            img.loading = 'lazy';
            img.onload = () => callback(img);
            img.onerror = () => callback(null);
            img.src = src;
        };


        function toggleSidebar() {
            const body = document.body;
            const isCinemaMode = body.classList.contains('cinema-mode');

            if (isCinemaMode) {
                body.classList.toggle('sidebar-open');
            } else {
                const isCollapsed = body.classList.contains('sidebar-collapsed');

                if (isCollapsed) {
                    body.classList.remove('sidebar-collapsed');
                    localStorage.setItem('sidebarCollapsed', 'false');
                } else {
                    body.classList.add('sidebar-collapsed');
                    localStorage.setItem('sidebarCollapsed', 'true');
                }
            }
        }

        function initializeSidebarState() {
            const sidebarCollapsed = localStorage.getItem('sidebarCollapsed');
            if (sidebarCollapsed === 'true') {
                document.body.classList.add('sidebar-collapsed');
            }
        }

        document.addEventListener('click', (e) => {
            const body = document.body;
            const isCinemaMode = body.classList.contains('cinema-mode');
            const isSidebarOpen = body.classList.contains('sidebar-open');

            if (isCinemaMode && isSidebarOpen) {
                const sidebar = document.querySelector('.sidebar');
                const sidebarToggle = document.getElementById('sidebarToggle');

                if (sidebar && !sidebar.contains(e.target) && e.target !== sidebarToggle && !sidebarToggle.contains(e.target)) {
                    body.classList.remove('sidebar-open');
                }
            }
        });

        const supportsFS = 'showDirectoryPicker' in window;

        const DEBUG = false;
        const debug = {
            log: (...args) => { if (DEBUG) console.log(...args); },
            warn: (...args) => { if (DEBUG) console.warn(...args); },
            error: (...args) => { if (DEBUG) console.error(...args); }
        };
        window.debug = debug;


        window.videoDirectoryHandle = null;
        let allVideos = [];
        window.allVideos = allVideos;
        let allPlaylists = [];
        let db = null;
        let currentVideo = null;
        let carouselVideoPages = new Map();
        const videosPerPage = 5;
        let allPlaylistCategories = new Map();
        let currentFilter = 'all';

        let logoEnabled = localStorage.getItem("video_logo_enabled") === "true";
        let logoType = localStorage.getItem("video_logo_type") || "red";
        let clockEnabled = localStorage.getItem("video_clock_enabled") !== "false";
        let clockBlinkingMode = localStorage.getItem("video_clock_blinking") !== "false";
        let hasStarted = false;

        window.abSegmentA = null;
        window.abSegmentB = null;
        window.abSegmentMode = 0;

        window.updateABMarkers = function updateABMarkers() {
            const progressBar = document.querySelector('.progress-bar');
            if (!progressBar) return;

            const existingMarkers = progressBar.querySelectorAll('.ab-marker');
            existingMarkers.forEach(marker => marker.remove());

            if (window.abSegmentA !== null && video.duration > 0) {
                const aMarker = document.createElement('div');
                aMarker.className = 'ab-marker a';
                aMarker.style.left = `${(window.abSegmentA / video.duration) * 100}%`;
                progressBar.appendChild(aMarker);
            }

            if (window.abSegmentB !== null && video.duration > 0) {
                const bMarker = document.createElement('div');
                bMarker.className = 'ab-marker b';
                bMarker.style.left = `${(window.abSegmentB / video.duration) * 100}%`;
                progressBar.appendChild(bMarker);
            }
        }

        const availableSpeeds = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
        let speedHudTimer = null;
        let volumeHudTimer = null;
        let lastVolume = 1;
        let lmbActive = false;
        let pressStartedOnVideo = false;
        let holdTimer = null;
        let suppressNextClick = false;
        let pressStartTime = 0;
        let seekInterval = null;
        let seekDirection = 0;
        let seekHud = null;
        let seekHudTimer = null;

        let preloadQueue = [];
        let preloadIndex = 0;
        let isPreloading = false;

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isLowEndDevice = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;

        async function preloadNextVideos(currentVideoIndex, playlist) {
            if (isPreloading) return;
            isPreloading = true;

            try {
                const nextVideos = [];
                const preloadCount = isMobile || isLowEndDevice ? 1 : 3;

                for (let i = 1; i <= preloadCount; i++) {
                    const nextIndex = currentVideoIndex + i;
                    if (nextIndex < playlist.length) {
                        nextVideos.push(playlist[nextIndex]);
                    }
                }

                for (const video of nextVideos) {
                    requestIdleCallback(() => {
                        if (video.file) {
                            const preloadVideo = document.createElement('video');
                            preloadVideo.preload = 'metadata';
                            preloadVideo.muted = true;
                            preloadVideo.src = URL.createObjectURL(video.file);
                            preloadVideo.addEventListener('loadedmetadata', () => {
                                URL.revokeObjectURL(preloadVideo.src);
                            });
                        }
                    });
                }
            } catch (error) {
                debug.warn('Preloading failed:', error);
            } finally {
                isPreloading = false;
            }
        }

        let controlsTimeout = null;

        const videoContainer = document.getElementById('videoContainer');


        class LazyVideoLoader {
            constructor() {
                this.observer = null;
                this.pendingVideos = new Map();
                this.initObserver();
            }

            initObserver() {
                if ('IntersectionObserver' in window) {
                    this.observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const videoName = entry.target.dataset.videoName;
                                const videoData = this.pendingVideos.get(videoName);
                                if (videoData) {
                                    this.loadVideoPreview(videoData.video, videoData.thumbnailElement, videoData.priority);
                                    this.pendingVideos.delete(videoName);
                                    this.observer.unobserve(entry.target);
                                }
                            }
                        });
                    }, {
                        rootMargin: '50px',
                        threshold: 0.1
                    });
                }
            }

            addVideo(video, thumbnailElement, priority = 0) {
                if (!this.observer) {
                    this.loadVideoPreview(video, thumbnailElement, priority);
                    return;
                }

                thumbnailElement.dataset.videoName = video.name;

                this.pendingVideos.set(video.name, { video, thumbnailElement, priority });

                this.observer.observe(thumbnailElement);
            }

            async loadVideoPreview(video, thumbnailElement, priority = 0) {
                const task = async () => {
                    try {
                        debug.log(`Loading preview for video: ${video.name}`, {
                            hasFile: !!video.file,
                            hasHandle: !!video.handle,
                            hasDirHandle: !!video.dirHandle
                        });

                        const { preview, duration } = await getPreviewAndDuration(video);
                        if (preview) {
                            thumbnailElement.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;">`;
                            debug.log(`Successfully loaded preview for: ${video.name}`);
                        }
                        const newDurationElement = document.createElement('div');
                        newDurationElement.className = 'video-duration';
                        newDurationElement.textContent = duration;
                        thumbnailElement.appendChild(newDurationElement);
                    } catch (e) {
                        debug.error('Error loading preview for', video.name, e);
                        thumbnailElement.innerHTML = `
                            <div class="video-duration">0:00</div>
                            <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                                ${escapeHtml(getFileNameWithoutExtension(video.name))}
                            </div>`;
                    }
                };

                taskQueue.add(task, priority);
            }

            forceLoadAll() {
                this.pendingVideos.forEach((videoData, videoName) => {
                    this.loadVideoPreview(videoData.video, videoData.thumbnailElement, videoData.priority);
                    this.observer.unobserve(videoData.thumbnailElement);
                });
                this.pendingVideos.clear();
            }

            getStats() {
                return {
                    pending: this.pendingVideos.size,
                    observerActive: !!this.observer
                };
            }
        }

        const lazyLoader = new LazyVideoLoader();

        document.addEventListener('DOMContentLoaded', () => {
            debug.log('LazyVideoLoader initialized');
        });

        let clockTimer = null;

        function updateClockOverlay() {
            const videoClock = document.getElementById("videoClock");
            if (!videoClock) return;
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');

            videoClock.innerHTML = `${h}<span class="clock-colon">:</span>${m}`;

            if (clockBlinkingMode) {
                videoClock.classList.add('blinking');
            } else {
                videoClock.classList.remove('blinking');
            }
        }

        clockTimer = setInterval(updateClockOverlay, 1000);
        updateClockOverlay();

        async function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open('8SiteDB', 1);
                req.onupgradeneeded = () => {
                    const db = req.result;
                    if (!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
                    if (!db.objectStoreNames.contains('videos')) db.createObjectStore('videos', { keyPath: 'name' });
                    if (!db.objectStoreNames.contains('playlists')) db.createObjectStore('playlists', { keyPath: 'id' });
                    if (!db.objectStoreNames.contains('subscriptions')) db.createObjectStore('subscriptions');
                };
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }
        async function getFromDB(db, key) {
            const storeName = key === 'subscriptions' ? 'subscriptions' : 'handles';

            if (!db.objectStoreNames.contains(storeName)) {
                return null;
            }

            const tx = db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            return new Promise((resolve) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => resolve(null);
            });
        }
        async function saveToDB(db, storeName, key, value) {
            try {
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }

                if (db && db.objectStoreNames.contains(storeName)) {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.put(value, key);
                    debug.log('Saved to IndexedDB successfully');
                } else {
                    debug.warn(`IndexedDB store '${storeName}' does not exist, but data saved to localStorage`);
                }
            } catch (e) {
                debug.error('Error saving to IndexedDB:', e);
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
            }
        }

        async function saveSubscriptionsToFile(subscriptions) {
            try {
                localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));

                if (videoDirectoryHandle) {
                    try {
                        const subsDir = await videoDirectoryHandle.getDirectoryHandle('.subscriptions', { create: true });
                        const fileHandle = await subsDir.getFileHandle('subscriptions.json', { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(subscriptions, null, 2));
                        await writable.close();
                    } catch (fileError) {
                        debug.warn('Could not save to .subscriptions, but localStorage saved:', fileError);
                    }
                }

                window.dispatchEvent(new CustomEvent('subscriptionChanged'));
            } catch (e) {
                debug.error('Error saving subscriptions to file:', e);
            }
        }

        async function saveVideoToDB(video) {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('videos', 'readwrite');
            const store = tx.objectStore('videos');
            await store.put(video);
        }

        async function getVideosFromDB() {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('videos', 'readonly');
            const store = tx.objectStore('videos');
            return new Promise((resolve) => {
                const r = store.getAll();
                r.onsuccess = () => resolve(r.result);
                r.onerror = () => resolve([]);
            });
        }

        async function deleteVideoFromDB(videoName) {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('videos', 'readwrite');
            const store = tx.objectStore('videos');
            await store.delete(videoName);
        }

        async function savePlaylistToDB(playlist) {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('playlists', 'readwrite');
            const store = tx.objectStore('playlists');
            await store.put(playlist);
        }

        async function getPlaylistsFromDB() {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('playlists', 'readonly');
            const store = tx.objectStore('playlists');
            return new Promise((resolve) => {
                const r = store.getAll();
                r.onsuccess = () => resolve(r.result);
                r.onerror = () => resolve([]);
            });
        }

        async function deletePlaylistFromDB(playlistId) {
            if (!db) {
                db = await openDB();
            }
            const tx = db.transaction('playlists', 'readwrite');
            const store = tx.objectStore('playlists');
            await store.delete(playlistId);
        }

        async function checkStorageQuota() {
            try {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    const estimate = await navigator.storage.estimate();
                    const usedMB = Math.round(estimate.usage / (1024 * 1024));
                    const quotaMB = Math.round(estimate.quota / (1024 * 1024));

                    debug.log(`Storage usage: ${usedMB}/${quotaMB}MB (${Math.round((estimate.usage / estimate.quota) * 100)}%)`);

                    if (estimate.usage > estimate.quota * 0.8) {
                        debug.warn(`Storage usage high: ${usedMB}/${quotaMB}MB - cleaning up...`);
                        await cleanupOldIndexedDBEntries();
                    }
                }
            } catch (error) {
                debug.warn('Failed to check storage quota:', error);
            }
        }

        async function cleanupOldIndexedDBEntries() {
            try {
                if (!db) {
                    db = await openDB();
                }

                const videoTx = db.transaction('videos', 'readwrite');
                const videoStore = videoTx.objectStore('videos');
                const allVideos = await new Promise((resolve) => {
                    const request = videoStore.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => resolve([]);
                });

                if (allVideos.length > 500) {
                    allVideos.sort((a, b) => (b.created || 0) - (a.created || 0));
                    const toDelete = allVideos.slice(500);

                    for (const video of toDelete) {
                        try {
                            await videoStore.delete(video.name);
                        } catch (e) {
                            debug.warn('Failed to delete video entry:', video.name);
                        }
                    }
                    debug.log(`Cleaned up ${toDelete.length} old video entries`);
                }

            } catch (error) {
                debug.warn('Failed to cleanup IndexedDB entries:', error);
            }
        }

        async function readJSONFile(dirHandle, fileName, def = null) {
            if (!dirHandle) return def;
            try {
                let exists = false;
                for await (const [name] of dirHandle.entries()) {
                    if (name === fileName) {
                        exists = true;
                        break;
                    }
                }
                if (!exists) return def;
                const fh = await dirHandle.getFileHandle(fileName);
                const f = await fh.getFile();
                return JSON.parse(await f.text());
            } catch (e) { return def; }
        }
        async function writeJSONFile(dirHandle, fileName, data) {
            const fh = await dirHandle.getFileHandle(fileName, { create: true });
            const w = await fh.createWritable();
            await w.write(JSON.stringify(data, null, 2));
            await w.close();
        }

        async function loadImageFile(dirHandle, fileName) {
            const cacheKey = `${dirHandle.name}_${fileName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
            }

            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const url = URL.createObjectURL(file);

                avatarCache.set(cacheKey, {
                    url,
                    timestamp: Date.now()
                });

                return url;
            } catch (e) {
                debug.log('Error loading image file:', fileName, e);
                return null;
            }
        }

        async function getVideoMetadata(dirHandle, fileName) {
            const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
            const metaFileName = fileName + '.meta.json';
            const metadata = await readJSONFile(metaDir, metaFileName, {
                views: 0,
                likes: 0,
                dislikes: 0,
                tags: [],
                created: Date.now(),
                description: ""
            });

            if (metadata.tags && Array.isArray(metadata.tags) && metadata.tags.length > 0) {
                if (window.applyTagImplications && window.tagDatabaseManager?.isLoaded) {
                    try {
                        const originalTags = [...metadata.tags];
                        const expandedTags = window.applyTagImplications(metadata.tags);

                        if (expandedTags && expandedTags.length >= originalTags.length) {
                            if (expandedTags.length > originalTags.length) {
                                const addedCount = expandedTags.length - originalTags.length;
                                debug.log(`[TagImplication]  Auto-applied ${addedCount} implications on load`);
                                metadata.tags = expandedTags;
                                await saveVideoMetadata(dirHandle, fileName, metadata);
                            }
                        } else {
                            debug.warn('[TagImplication]  Implication result invalid, keeping original tags');
                        }
                    } catch (error) {
                        debug.error('[TagImplication]  Error applying implications on load:', error);
                    }
                }
            }

            return metadata;
        }

        async function saveVideoMetadata(dirHandle, fileName, metadata) {
            try {
                const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                const metaFileName = fileName + '.meta.json';
                await writeJSONFile(metaDir, metaFileName, metadata);
            } catch (e) {
                debug.error('Error saving video metadata:', e);
            }
        }

        async function getPreviewAndDuration(video) {
            const dirHandle = video.dirHandle || videoDirectoryHandle;

            try {
                const db = await openDB();
                const cached = await getFromDB(db, `preview_${video.name}`);
                if (cached && cached.preview && cached.duration &&
                    cached.size === video.file.size && cached.modified === video.file.lastModified) {
                    video.preview = cached.preview;
                    video.duration = cached.duration;
                    return { preview: cached.preview, duration: cached.duration };
                }
            } catch (e) {
                debug.warn('IndexedDB cache miss:', e);
            }

            const meta = await getVideoMetadata(dirHandle, video.name);

            const fileChanged = meta.size !== video.file.size || meta.modified !== video.file.lastModified;

            if (meta.preview && meta.duration && !fileChanged) {
                if (!video.preview || !video.duration) {
                    video.preview = meta.preview;
                    video.duration = meta.duration;
                    requestIdleCallback(() => {
                        saveVideoToDB({
                            name: video.name,
                            preview: meta.preview,
                            duration: meta.duration,
                            size: video.file.size,
                            modified: video.file.lastModified,
                            tags: video.tags || [],
                            created: meta.created || Date.now(),
                            description: meta.description || ''
                        }).catch(debug.warn);
                    });
                }
                return { preview: meta.preview, duration: meta.duration };
            }

            if (!video.file) {
                debug.warn('No file available for video:', video.name);
                return { preview: '', duration: '0:00' };
            }

            requestIdleCallback(() => {
                generatePreviewInBackground(video, dirHandle, meta).catch(debug.warn);
            });

            return {
                preview: meta.preview || '',
                duration: meta.duration || '0:00'
            };
        }
        async function generatePreviewInBackground(video, dirHandle, meta) {
            try {
                const el = document.createElement('video');
                el.muted = true;
                el.playsInline = true;
                el.preload = 'metadata';
                el.crossOrigin = 'anonymous';

                const url = URL.createObjectURL(video.file);

                const cleanup = () => {
                    URL.revokeObjectURL(url);
                    el.remove();
                };

                const timeout = setTimeout(() => {
                    cleanup();
                    throw new Error('Timeout generating preview');
                }, 15000);

                return new Promise((resolve, reject) => {
                    el.addEventListener('loadedmetadata', async () => {
                        try {
                            if (!isFinite(el.duration) || el.duration <= 0) {
                                clearTimeout(timeout);
                                cleanup();
                                resolve({ preview: '', duration: '0:00' });
                                return;
                            }

                            const duration = formatDuration(el.duration);
                            el.currentTime = Math.max(0, el.duration / 2);

                            el.addEventListener('seeked', async () => {
                                try {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = 240;
                                    canvas.height = 140;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(el, 0, 0, canvas.width, canvas.height);
                                    const preview = canvas.toDataURL('image/jpeg', 0.7);

                                    clearTimeout(timeout);
                                    cleanup();

                                    const updatedMeta = {
                                        ...meta,
                                        preview,
                                        duration,
                                        size: video.file.size,
                                        modified: video.file.lastModified
                                    };
                                    await saveVideoMetadata(dirHandle, video.name, updatedMeta);

                                    video.preview = preview;
                                    video.duration = duration;
                                    await saveVideoToDB({
                                        name: video.name,
                                        preview,
                                        duration,
                                        size: video.file.size,
                                        modified: video.file.lastModified,
                                        tags: video.tags || [],
                                        created: meta.created || Date.now(),
                                        description: meta.description || ''
                                    });

                                    updateVideoPreviewInUI(video.name, preview, duration);

                                    resolve({ preview, duration });
                                } catch (e) {
                                    clearTimeout(timeout);
                                    cleanup();
                                    reject(e);
                                }
                            });

                            el.addEventListener('error', () => {
                                clearTimeout(timeout);
                                cleanup();
                                reject(new Error('Video error'));
                            });
                        } catch (e) {
                            clearTimeout(timeout);
                            cleanup();
                            reject(e);
                        }
                    });

                    el.addEventListener('error', () => {
                        clearTimeout(timeout);
                        cleanup();
                        reject(new Error('Video error'));
                    });

                    el.src = url;
                });
            } catch (e) {
                debug.error('Background preview generation failed:', e);
            }
        }


        async function parallelLimit(tasks, limit = 2) {
            const results = [];
            const executing = new Set();

            for (const task of tasks) {
                const p = Promise.resolve().then(() => task());
                results.push(p);
                executing.add(p);
                p.finally(() => executing.delete(p));

                if (executing.size >= limit) {
                    await Promise.race(executing);
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
            return Promise.all(results);
        }

        async function loadAllPlaylists() {
            debug.log('Loading all playlists...');
            allPlaylists.length = 0;
            const cachedPlaylists = await getPlaylistsFromDB();
            const playlistMap = new Map(cachedPlaylists.map(pl => [pl.id, pl]));
            const currentPlaylistIds = new Set();

            try {
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                window.channelsDir = channelsDir;

                renderSubscribedChannelsList();

                if (typeof window.renderComments === 'function' && comments && comments.length > 0) {
                    window.renderComments();
                }

                if (window.currentChannelName) {
                    const av = document.getElementById('uploaderAvatar');
                    if (av) {
                        loadChannelAvatar(window.currentChannelName).then(avatarUrl => {
                            if (avatarUrl) {
                                av.style.backgroundImage = `url(${avatarUrl})`;
                                av.textContent = '';
                            }
                        }).catch(() => {
                        });
                    }
                }
                for await (const [name, handle] of channelsDir.entries()) {
                    if (handle.kind === 'directory') {
                        const channelData = await readJSONFile(handle, 'channel.json', { playlists: [] });
                        for (const pl of (channelData.playlists || [])) {
                            const playlistId = pl.id;
                            currentPlaylistIds.add(playlistId);
                            const cachedPlaylist = playlistMap.get(playlistId);

                            let playlistToPush = null;

                            if (!cachedPlaylist ||
                                cachedPlaylist.title !== pl.title ||
                                (cachedPlaylist.videos ? cachedPlaylist.videos.length : 0) !== (pl.videos ? pl.videos.length : 0)) {
                                const videosWithHandles = (pl.videos || []).map(video => {
                                    const foundVideo = allVideos.find(av => av.name === video.name);
                                    if (foundVideo) {
                                        return { ...video, handle: foundVideo.handle, file: foundVideo.file, dirHandle: foundVideo.dirHandle };
                                    }
                                    return video;
                                });
                                playlistToPush = { ...pl, videos: videosWithHandles, channelName: name, channelHandle: handle, isChannelPlaylist: true };
                                await savePlaylistToDB({ ...playlistToPush, handle: null, dirHandle: null, videos: videosWithHandles.map(v => ({ name: v.name, tags: v.tags })) });
                            } else {
                                const videosWithHandles = (cachedPlaylist.videos || []).map(video => {
                                    const foundVideo = allVideos.find(av => av.name === video.name);
                                    if (foundVideo) {
                                        return { ...video, handle: foundVideo.handle, file: foundVideo.file, dirHandle: foundVideo.dirHandle };
                                    }
                                    return video;
                                });
                                playlistToPush = { ...cachedPlaylist, videos: videosWithHandles, channelName: name, channelHandle: handle, isChannelPlaylist: true };
                            }
                            if (playlistToPush) allPlaylists.push(playlistToPush);
                        }
                    }
                }
                const globalPlaylists = await readJSONFile(videoDirectoryHandle, '.global_playlists.json', []);
                for (const pl of (globalPlaylists || [])) {
                    const playlistId = pl.id;
                    currentPlaylistIds.add(playlistId);
                    const cachedPlaylist = playlistMap.get(playlistId);

                    let playlistToPush = null;

                    if (!cachedPlaylist ||
                        cachedPlaylist.title !== pl.title ||
                        (cachedPlaylist.videos ? cachedPlaylist.videos.length : 0) !== (pl.videos ? pl.videos.length : 0)) {
                        const videosWithHandles = (pl.videos || []).map(video => {
                            const foundVideo = allVideos.find(av => av.name === video.name);
                            if (foundVideo) {
                                return { ...video, handle: foundVideo.handle, file: foundVideo.file, dirHandle: foundVideo.dirHandle };
                            }
                            return video;
                        });
                        playlistToPush = { ...pl, videos: videosWithHandles, channelName: null, isChannelPlaylist: false };
                        await savePlaylistToDB({ ...playlistToPush, handle: null, dirHandle: null, videos: videosWithHandles.map(v => ({ name: v.name, tags: v.tags })) });
                    } else {
                        const videosWithHandles = (cachedPlaylist.videos || []).map(video => {
                            const foundVideo = allVideos.find(av => av.name === video.name);
                            if (foundVideo) {
                                return { ...video, handle: foundVideo.handle, file: foundVideo.file, dirHandle: foundVideo.dirHandle };
                            }
                            return video;
                        });
                        playlistToPush = { ...cachedPlaylist, videos: videosWithHandles, channelName: null, isChannelPlaylist: false };
                    }
                    if (playlistToPush) allPlaylists.push(playlistToPush);
                }

                for (const cachedPlaylist of cachedPlaylists) {
                    if (!currentPlaylistIds.has(cachedPlaylist.id)) {
                        await deletePlaylistFromDB(cachedPlaylist.id);
                    }
                }

                allPlaylists.sort((a, b) => (b.created || 0) - (a.created || 0));

                allPlaylistCategories.clear();
                allPlaylists.forEach(playlist => {
                    (playlist.categories || []).forEach(category => {
                        const trimmedCategory = category.trim();
                        if (trimmedCategory) {
                            allPlaylistCategories.set(trimmedCategory, (allPlaylistCategories.get(trimmedCategory) || 0) + 1);
                        }
                    });
                });
            } catch (e) {
                debug.error('loadAllPlaylists error', e);
            }
        }

        async function loadCurrentPlaylistVideos() {
            debug.log(' Quick loading current playlist videos...');
            allVideos = [];
            window.allVideos = allVideos;
            const exts = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];

            if (!videoDirectoryHandle) {
                debug.error('No videoDirectoryHandle available');
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            let videoName = null;
            const videoId = urlParams.get('v');
            if (videoId && window.VideoID && window.VideoID.isVideoId(videoId)) {
                videoName = window.VideoID.getFilename(videoId);
            }
            if (!videoName) {
                videoName = urlParams.get('name');
            }
            if (!videoName) return;

            let foundDir = null;
            let foundInRoot = false;

            try {
                const rootFile = await videoDirectoryHandle.getFileHandle(videoName);
                if (rootFile) {
                    foundInRoot = true;
                    foundDir = videoDirectoryHandle;
                }
            } catch (e) {
            }

            if (!foundInRoot) {
                for await (const [name, handle] of videoDirectoryHandle.entries()) {
                    if (handle.kind === 'directory' && !name.startsWith('.')) {
                        try {
                            const file = await handle.getFileHandle(videoName);
                            if (file) {
                                foundDir = handle;
                                break;
                            }
                        } catch (e) {
                        }
                    }
                }
            }

            if (!foundDir) {
                debug.warn('Current playlist directory not found, loading all videos instead');
                await loadAllVideos();
                return;
            }

            for await (const [name, handle] of foundDir.entries()) {
                if (handle.kind === 'file') {
                    const lower = name.toLowerCase();
                    if (exts.some(ext => lower.endsWith(ext))) {
                        try {
                            const file = await handle.getFile();
                            const meta = await getVideoMetadata(foundDir, name);

                            allVideos.push({
                                name,
                                size: file.size,
                                modified: file.lastModified,
                                views: meta.views || 0,
                                likes: meta.likes || 0,
                                dislikes: meta.dislikes || 0,
                                tags: meta.tags || [],
                                created: meta.created || Date.now(),
                                description: meta.description || '',
                                handle: handle,
                                file: file,
                                dirHandle: foundDir
                            });
                        } catch (e) {
                            debug.warn('Cannot access file:', name, e.message);
                        }
                    }
                }
            }

            debug.log(' Quick loaded', allVideos.length, 'videos from current playlist');
        }

        const videoHandlesCache = new Map();
        
        function getVideoHandle(videoName) {
            return videoHandlesCache.get(videoName);
        }
        
        function cacheVideoHandle(videoName, handle, dirHandle) {
            videoHandlesCache.set(videoName, { handle, dirHandle });
        }

        async function loadAllVideos() {
            
            const wasQuickLoaded = allVideos.length > 0;
            if (wasQuickLoaded) {
                debug.log('Videos already quick-loaded, performing full scan to add remaining...');
            } else {
                debug.log('Starting loadAllVideos...');
            }

            const exts = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];

            if (!videoDirectoryHandle) {
                debug.error('No videoDirectoryHandle available');
                return;
            }

            const cachedVideos = await getVideosFromDB();
            const videoMap = new Map(cachedVideos.map(v => [v.name, v]));
            const currentVideoNames = new Set();

            const existingVideoNames = new Set(allVideos.map(v => v.name));
            let videosBuffer = [];
            const BATCH_SIZE = 100;
            let lastLogTime = Date.now();
            const LOG_INTERVAL = 1000;

            function updateProgress() {
                const now = Date.now();
                if (now - lastLogTime >= LOG_INTERVAL) {
                    debug.log(`Loaded ${allVideos.length} videos...`);
                    lastLogTime = now;
                }
            }

            async function flushBuffer() {
                if (videosBuffer.length === 0) return;

                await Promise.all(
                    videosBuffer.map(v => saveVideoToDB({
                        name: v.name,
                        size: v.size,
                        modified: v.modified,
                        views: v.views,
                        likes: v.likes,
                        dislikes: v.dislikes,
                        tags: v.tags,
                        created: v.created,
                        description: v.description
                    }))
                );

                allVideos.push(...videosBuffer);
                if (window.VideoID) {
                    videosBuffer.forEach(v => window.VideoID.register(v.name));
                }
                videosBuffer = [];
                updateProgress();

                await new Promise(resolve => setTimeout(resolve, 0));
            }

            async function scan(dir, path = '') {
                const entries = [];
                for await (const [name, handle] of dir.entries()) {
                    entries.push({ name, handle });
                }

                for (let i = 0; i < entries.length; i += BATCH_SIZE) {
                    const batch = entries.slice(i, i + BATCH_SIZE);

                    await Promise.all(
                        batch.map(async ({ name, handle }) => {
                            if (handle.kind === 'file') {
                                const lower = name.toLowerCase();
                                if (exts.some(ext => lower.endsWith(ext))) {
                                    currentVideoNames.add(name);

                                    if (existingVideoNames.has(name)) {
                                       
                                        cacheVideoHandle(name, handle, dir);
                                        return;
                                    }

                                    try {
                                        const file = await handle.getFile();
                                        const meta = await getVideoMetadata(dir, name);

                                        cacheVideoHandle(name, handle, dir);

                                        const videoData = {
                                            name,
                                            size: file.size,
                                            modified: file.lastModified,
                                            views: meta.views || 0,
                                            likes: meta.likes || 0,
                                            dislikes: meta.dislikes || 0,
                                            tags: meta.tags || [],
                                            created: meta.created || Date.now(),
                                            description: meta.description || '',
                                            handle: handle,
                                            file: file,
                                            dirHandle: dir
                                        };

                                        videosBuffer.push(videoData);
                                    } catch (e) {
                                        debug.warn('Cannot access file:', name, e.message);
                                    }
                                }
                            } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                                await scan(handle, path + '/' + name);
                            }
                        })
                    );

                    if (videosBuffer.length >= BATCH_SIZE) {
                        await flushBuffer();
                    }
                }
            }

            await scan(videoDirectoryHandle);

            await flushBuffer();

            const deletedVideos = cachedVideos.filter(v => !currentVideoNames.has(v.name));
            if (deletedVideos.length > 0) {
                await Promise.all(deletedVideos.map(v => deleteVideoFromDB(v.name)));
                deletedVideos.forEach(v => videoHandlesCache.delete(v.name));
            }

            debug.log('Total videos loaded:', allVideos.length);
            debug.log('Handles cached:', videoHandlesCache.size);
            
            if (window.VideoID && videoDirectoryHandle) {
                window.VideoID.saveIndex(videoDirectoryHandle);
            }
        }
        function renderSidebarCategories() {
            const categoriesContainer = document.getElementById('sidebarTagsContainer');
            if (!categoriesContainer) return;
            categoriesContainer.innerHTML = '';

            const sortedCategories = Array.from(allPlaylistCategories.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 17);

            if (sortedCategories.length === 0) {
                categoriesContainer.innerHTML = '<span class="sidebar-item"> </span>';
                return;
            }

            sortedCategories.forEach(([category, count]) => {
                const categoryItem = document.createElement('a');
                categoryItem.href = '#';
                categoryItem.className = 'sidebar-item';
                categoryItem.textContent = `${escapeHtml(category)} (${count})`;
                categoryItem.dataset.category = category;
                categoryItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    filterPlaylistsByCategory(category);
                });
                categoriesContainer.appendChild(categoryItem);
            });

            if (currentFilter === 'all') {
                document.getElementById('allPlaylistsLink').classList.add('active');
            }
        }

        function filterPlaylistsByCategory(category) {
            window.location.href = `youvi_main.html?tag=${encodeURIComponent(category)}`;
        }

        /*
        function sortVideos(videos) {
            switch (currentSort) {
                case 'new':
                    return videos.slice().sort((a, b) => (b.created||0)-(a.created||0));
                case 'popular':
                    return videos.slice().sort((a, b) => (b.views||0)-(a.views||0));
                case 'old':
                    return videos.slice().sort((a, b) => (a.created||0)-(b.created||0));
                case 'alphabetical':
                    return videos.slice().sort((a, b) => naturalSort(a.name || '', b.name || ''));
                case 'random':
                    return videos.slice().sort(() => Math.random() - 0.5);
                default:
                    return videos.slice().sort((a, b) => (b.created||0)-(a.created||0));
            }
        }
        */

        /**
         * Shows error state with disabled player controls
         * @param {string} errorMessage - The error message to display in the title
         * @param {string} errorType - The type of error ('folder' or 'notfound')
         */
        function showErrorState(errorMessage, errorType = 'notfound') {
            const videoPlayer = document.querySelector('.video-player');
            const videoTitleEl = document.getElementById('videoTitle');
            const videoContainer = document.getElementById('videoContainer');
            const video = document.getElementById('video');

            videoPlayer.classList.add('error-state');
            document.body.classList.add('error-state');

            if (videoTitleEl) {
                videoTitleEl.textContent = errorMessage;
            }

            document.title = `${errorMessage} | Youvi`;

            video.src = '';
            video.load();

            const existingErrorImg = videoContainer.querySelector('.error-image');
            if (existingErrorImg) {
                existingErrorImg.remove();
            }

            const errorImg = document.createElement('img');
            if (errorType === 'folder') {
                errorImg.src = 'images/notfoundfolder.png';
            } else {
                errorImg.src = 'images/notfound.png';
            }
            errorImg.alt = 'Error';
            errorImg.className = 'error-image';
            errorImg.onerror = () => {
                errorImg.style.display = 'none';
                const placeholder = document.createElement('div');
                placeholder.style.cssText = 'color: #666; font-size: 48px; text-align: center;';
                placeholder.textContent = '';
                placeholder.className = 'error-image';
                videoContainer.appendChild(placeholder);
            };

            videoContainer.appendChild(errorImg);

            const overlay = document.getElementById('videoOverlay');
            if (overlay) overlay.style.display = 'none';

            const spinner = document.getElementById('videoSpinner');
            if (spinner) spinner.style.display = 'none';

            const controls = videoPlayer.querySelectorAll('.video-controls button, .video-controls input, .control-btn');
            controls.forEach(control => {
                control.disabled = true;
                control.style.pointerEvents = 'none';
            });
        }

        /**
         * Clears error state and restores normal player functionality
         */
        function clearErrorState() {
            const videoPlayer = document.querySelector('.video-player');
            const videoContainer = document.getElementById('videoContainer');
            const video = document.getElementById('video');

            videoPlayer.classList.remove('error-state');
            document.body.classList.remove('error-state');

            if (video) {
                video.style.display = '';
            }

            const errorImg = videoContainer.querySelector('.error-image');
            if (errorImg) {
                errorImg.remove();
            }

            const controls = videoPlayer.querySelectorAll('.video-controls button, .video-controls input, .control-btn');
            controls.forEach(control => {
                control.disabled = false;
                control.style.pointerEvents = '';
            });

            const danmakuContent = document.querySelector('.danmaku-content');
            const danmakuForm = document.querySelector('.danmaku-form');
            if (danmakuContent) {
                danmakuContent.style.pointerEvents = '';
            }
            if (danmakuForm) {
                danmakuForm.style.pointerEvents = '';
                const danmakuElements = danmakuForm.querySelectorAll('input, textarea, button, select');
                danmakuElements.forEach(element => {
                    element.style.pointerEvents = '';
                    element.style.backgroundColor = '';
                    element.style.color = '';
                });
            }
        }

        async function loadVideoAndPlay() {
            const urlParams = new URLSearchParams(window.location.search);
            
            let videoName = null;
            const videoId = urlParams.get('v');
            if (videoId && window.VideoID && window.VideoID.isVideoId(videoId)) {
                videoName = window.VideoID.getFilename(videoId);
            }
            if (!videoName) {
                videoName = urlParams.get('name');
                if (videoName && window.VideoID) {
                    window.VideoID.register(videoName);
                }
            }
            
            const playlistId = urlParams.get('playlist') || urlParams.get('userPlaylist');

            if (!videoName) {
                showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.videoNotSpecified', '  ') : '  ', 'notfound');
                return;
            }
            
            if (window._openPlaylistTabOnLoad || playlistId) {
                window._openPlaylistTabOnLoad = false;
                const playlistTab = document.querySelector('.sidebar-panel-tab[data-tab="playlist"]');
                if (playlistTab && !document.body.classList.contains('wide-screen-mode')) {
                    playlistTab.click();
                }
            }

            const video = document.getElementById('video');
            const videoTitleEl = document.getElementById('videoTitle');
            const videoViewsEl = document.getElementById('videoViews');
            const videoLikesEl = document.getElementById('videoLikes');
            const videoDislikesEl = document.getElementById('videoDislikes');
            const videoDateEl = document.getElementById('videoDate');
            const videoCategoryEl = document.getElementById('videoCategory');
            const uploaderNameEl = document.getElementById('uploaderName');
            const descriptionTextEl = document.getElementById('descriptionText');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const progressBarFilled = document.getElementById('progressBarFilled');
            const timeDisplay = document.getElementById('timeDisplay');
            const volumeBtn = document.getElementById('volumeBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const volumeSlider = document.getElementById('volumeSlider');

            const progressBar = document.getElementById('progressBar');
            const progressHandle = document.getElementById('progressHandle');
            const progressPreview = document.getElementById('progressPreview');
            const previewCanvas = document.getElementById('previewCanvas');
            const previewTime = document.getElementById('previewTime');
            const pctx = previewCanvas ? previewCanvas.getContext('2d') : null;
            let offscreenVideo = null;
            try { window.offscreenPreviewVideo = offscreenVideo; } catch (_) { }

            currentVideo = allVideos.find(v => v.name === videoName);

            if (currentVideo && currentVideo.file) {
                clearErrorState();

                window.dispatchEvent(new CustomEvent('youvi:videoChanged', { detail: { video: currentVideo } }));

                window.currentVideoName = currentVideo.name;
                window.currentPlaylistHandle = currentVideo.dirHandle;
                window.currentVideo = currentVideo;
                window.videoEl = video; 

                currentVideoName = currentVideo.name;
                currentPlaylistHandle = currentVideo.dirHandle;

                if (typeof setCurrentVideo === 'function') {
                    setCurrentVideo(currentVideo.name, currentVideo.dirHandle);
                }

                if (typeof window.loadDanmakuData === 'function') {
                    window.loadDanmakuData();
                }
                hasStarted = false;

                video.preload = 'auto';
                const videoUrl = URL.createObjectURL(currentVideo.file);
                video.src = videoUrl;
                video.load();
                try {
                    const progressPreview = document.getElementById('progressPreview');
                    const previewCanvas = document.getElementById('previewCanvas');
                    if (previewCanvas) {
                        const ctx = previewCanvas.getContext('2d');
                        if (ctx) ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    }
                    if (progressPreview) progressPreview.style.display = 'none';
                    if (window.offscreenPreviewVideo) {
                        window.offscreenPreviewVideo.src = '';
                        window.offscreenPreviewVideo.removeAttribute('src');
                        window.offscreenPreviewVideo.load();
                    }
                } catch (_) { }
                try {
                    const dirHandle = currentVideo.dirHandle || videoDirectoryHandle;
                    if (dirHandle) {
                        const meta = await getVideoMetadata(dirHandle, currentVideo.name);
                        meta.views = (meta.views || 0) + 1;
                        await saveVideoMetadata(dirHandle, currentVideo.name, meta);
                        currentVideo.views = meta.views;
                        if (videoViewsEl) {
                            videoViewsEl.textContent = `${currentVideo.views || 0} ${i18n.t('video.views', 'views')}`;
                        }
                    }
                } catch (_) { }
                (function setupHistoryRecording() {
                    try {
                        const buildVideoKey = (name, playlist) => `${playlist || ''}::${name}`;
                        async function ensureHistoryDir() { try { return await videoDirectoryHandle.getDirectoryHandle('.history', { create: true }); } catch (_) { return null; } }
                        async function readHistoryFile(fileName, fallback) { try { const dir = await ensureHistoryDir(); if (!dir) return fallback; let exists = false; for await (const [name] of dir.entries()) { if (name === fileName) { exists = true; break; } } if (!exists) return fallback; const fh = await dir.getFileHandle(fileName, { create: false }); const f = await fh.getFile(); return JSON.parse(await f.text()); } catch (_) { return fallback; } }
                        async function writeHistoryFile(fileName, data) {
                            const maxRetries = 3;
                            for (let attempt = 0; attempt < maxRetries; attempt++) {
                                try {
                                    const dir = await ensureHistoryDir();
                                    if (!dir) { debug.log('[History] No history dir'); return false; }
                                    const fh = await dir.getFileHandle(fileName, { create: true });
                                    const w = await fh.createWritable({ keepExistingData: false });
                                    await w.write(JSON.stringify(data));
                                    await w.close();
                                    debug.log('[History] Saved', Array.isArray(data) ? data.length : 0, 'items');
                                    return true;
                                } catch (e) {
                                    debug.warn('[History] Write attempt', attempt + 1, 'failed:', e.message);
                                    if (attempt < maxRetries - 1) {
                                        await new Promise(r => setTimeout(r, 100 * Math.pow(2, attempt)));
                                    }
                                }
                            }
                            debug.error('[History] All write attempts failed');
                            return false;
                        }
                        async function loadSettings() { return await readHistoryFile('settings.json', { historyPaused: false }); }
                        async function loadHistory() { return await readHistoryFile('history.json', []); }
                        async function saveHistory(arr) { return await writeHistoryFile('history.json', arr || []); }
                        function capturePreviewDataURL(el) { try { const c = document.createElement('canvas'); const w = 320, h = 180; c.width = w; c.height = h; const cx = c.getContext('2d'); const vw = el.videoWidth || 1280, vh = el.videoHeight || 720; const ar = vw / vh; let dw = w, dh = h; if (w / h > ar) { dw = h * ar; dh = h; } else { dh = w / ar; dw = w; } cx.fillStyle = '#000'; cx.fillRect(0, 0, w, h); cx.drawImage(el, (w - dw) / 2, (h - dh) / 2, dw, dh); return c.toDataURL('image/jpeg', 0.7); } catch (_) { return null; } }
                        function makeDayKey(ts) { const d = new Date(ts); const y = d.getFullYear(); const m = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0'); return `${y}-${m}-${day}`; }
                        let historyListCache = null, historyPaused = false, lastWrite = 0, recorded = false;
                        const histBaseKey = buildVideoKey(currentVideo.name, currentVideo.playlist || '');
                        async function ensureLoaded() { if (!historyListCache) { const s = await loadSettings(); historyPaused = !!(s && s.historyPaused); historyListCache = await loadHistory(); } }
                        async function upsert(progress) { await ensureLoaded(); if (historyPaused) return; const list = historyListCache || []; const now = Date.now(); const dayKey = makeDayKey(now); const k = `${histBaseKey}::${dayKey}`; let it = list.find(x => x.key === k); const preview = (!it || !it.preview) ? capturePreviewDataURL(video) : it.preview; const base = { key: k, name: currentVideo.name, playlist: currentVideo.playlist || '', title: currentVideo.title || currentVideo.name, preview, lastWatchedAt: now, progress: Math.max(0, Math.min(1, progress || 0)) }; if (!it) list.push(base); else Object.assign(it, base); historyListCache = list; if (now - lastWrite > 1000) { lastWrite = now; saveHistory(list).catch(() => { }); } }
                        let lastHistoryUpdate = 0;
                        video.addEventListener('timeupdate', () => {
                            if (!video.duration) return;
                            const now = performance.now();
                            if (now - lastHistoryUpdate < 2000) return;
                            lastHistoryUpdate = now;

                            const pf = video.currentTime / (video.duration || 1);
                            upsert(pf);
                            if (!recorded && video.currentTime >= 5) { recorded = true; upsert(pf); }
                        });
                        video.addEventListener('ended', () => { upsert(1); });
                    } catch (_) { }
                })();

                const overlay = document.getElementById('videoOverlay');
                const previewImg = document.getElementById('videoPreview');
                const bigPlayBtn = document.getElementById('bigPlayBtn');

                try {
                    const { preview } = await getPreviewAndDuration(currentVideo);
                    if (preview) {
                        previewImg.src = preview;
                        if (video.paused) {
                            overlay.style.display = 'flex';
                            overlay.style.opacity = '1';
                        } else {
                            overlay.style.opacity = '0';
                            setTimeout(() => overlay.style.display = 'none', 300);
                        }
                    } else {
                        if (video.paused) {
                            overlay.style.display = 'flex';
                            overlay.style.opacity = '1';
                        }
                    }
                } catch (e) {
                    debug.error('Error loading preview:', e);
                    if (video.paused) {
                        overlay.style.display = 'flex';
                        overlay.style.opacity = '1';
                    }
                }



                const videoClock = document.getElementById('videoClock');
                const videoLogo = document.getElementById('videoLogo');
                if (!hasStarted) {
                    videoClock.style.display = 'none';
                    videoLogo.style.display = 'none';
                }

                video.addEventListener('loadedmetadata', () => {
                    const totalSeconds = Math.floor(video.duration);
                    const minutes = Math.floor(totalSeconds / 60);
                    const seconds = totalSeconds % 60;
                    document.getElementById('timeDisplay').textContent =
                        `0:00 / ${minutes}:${seconds.toString().padStart(2, '0')}`;

                    if (window.currentRawDescription && window.currentChapters && window.currentChapters.length > 0) {
                        clearChapterMarkers();
                        renderChapterMarkers(window.currentChapters);
                    }
                });

                video.addEventListener('error', (e) => {
                    debug.error('Video loading error:', e);
                    showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.videoLoadError', '  ') : '  ', 'notfound');
                });


                const currentTitle = getFileNameWithoutExtension(currentVideo.name);
                if (videoTitleEl) {
                    videoTitleEl.textContent = currentTitle;
                    videoTitleEl.removeAttribute('data-i18n');
                }
                const playIndicator = !video.paused ? ' ' : '';
                document.title = `${playIndicator}${currentTitle} | Youvi`;

                setTimeout(() => {
                    const playIndicator = !video.paused ? ' ' : '';
                    document.title = `${playIndicator}${currentTitle} | Youvi`;
                }, 100);

                try {
                    let metaPreview = '';
                    const previewImgEl = document.getElementById('videoPreview');
                    if (previewImgEl && previewImgEl.src && previewImgEl.src.startsWith('data:')) {
                        metaPreview = previewImgEl.src;
                    }
                    if (window.VideoMetaTags) {
                        window.VideoMetaTags.updateFromVideo(currentVideo, metaPreview);
                    }
                } catch (e) { debug.warn('[VideoMetaTags] Update failed:', e); }
                if (uploaderNameEl) {
                    let channelDisplay = currentVideo.channelName || '';
                    if (!channelDisplay && Array.isArray(currentVideo.tags) && currentVideo.tags.length) {
                        if (window.TagTypes) {
                            channelDisplay = window.TagTypes.getChannelFromTags(currentVideo.tags);
                        } else {
                            const channelTags = currentVideo.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                            if (channelTags.length > 0) {
                                channelDisplay = channelTags.map(t => t.replace(' ()', '')).join(', ');
                            }
                        }
                    }
                    if (channelDisplay) {
                        const channelName = channelDisplay.split(', ')[0];
                        window.currentChannelName = channelName;

                        uploaderNameEl.innerHTML = `<a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" style="color:inherit;text-decoration:none;">${escapeHtml(channelDisplay)}</a>`;

                        try {
                            const av = document.getElementById('uploaderAvatar');
                            if (av && channelName) {
                                av.textContent = channelName.charAt(0).toUpperCase();
                                av.style.background = '#ff69b4';
                                av.style.backgroundSize = 'cover';
                                av.style.backgroundPosition = 'center';
                                av.style.backgroundRepeat = 'no-repeat';

                                loadChannelAvatar(channelName).then(avatarUrl => {
                                    if (avatarUrl) {
                                        av.style.backgroundImage = `url(${avatarUrl})`;
                                        av.textContent = '';
                                    }
                                }).catch(() => {
                                });
                            }
                        } catch (_) { }

                        setupSubscriptionButton();
                    } else {
                        uploaderNameEl.textContent = i18n.t('video.noChannel', 'No channel');
                        window.currentChannelName = null;
                    }
                }
                if (videoViewsEl) videoViewsEl.textContent = `${currentVideo.views || 0} ${i18n.t('video.views', 'views')}`;
                if (videoLikesEl) videoLikesEl.textContent = `${currentVideo.likes || 0} ${i18n.t('video.likes', 'likes')}`;
                if (videoDislikesEl) videoDislikesEl.textContent = `${currentVideo.dislikes || 0} ${i18n.t('video.dislikes', 'dislikes')}`;
                const fileTs = (currentVideo.file && currentVideo.file.lastModified) ? currentVideo.file.lastModified : (currentVideo.modified || currentVideo.created || Date.now());
                if (videoDateEl) videoDateEl.textContent = new Date(fileTs).toLocaleDateString();
                const addedTs = currentVideo.created || currentVideo.modified || fileTs;
                if (videoCategoryEl) videoCategoryEl.textContent = new Date(addedTs).toLocaleString();
                try {
                    const tagsWrap = document.getElementById('videoTags');
                    if (tagsWrap) {
                        const tags = (currentVideo.tags && currentVideo.tags.length ? currentVideo.tags : (currentVideo.categories || [])) || [];
                        if (window.updateVideoTagsDisplay) {
                            window.updateVideoTagsDisplay(tags);
                        } else {
                            if (window.TagTypes) {
                                tagsWrap.innerHTML = window.TagTypes.renderTags(tags, 24, true);
                            } else {
                                tagsWrap.innerHTML = tags.slice(0, 24).map(t => {
                                    const tag = String(t);
                                    const href = `youvi_main.html?tag=${encodeURIComponent(tag)}`;
                                    return `<a class=\"video-tag\" href=\"${href}\">${escapeHtml(tag)}</a>`;
                                }).join('');
                            }
                        }
                    }
                } catch (_) { }
                if (descriptionTextEl) {
                    const savedDescription = await loadDescriptionFromFile();
                    const description = savedDescription || currentVideo.description || ' .';
                    window.currentRawDescription = description;
                    descriptionTextEl.textContent = description;

                    parseAndRenderChapters(description);
                }

                playPauseBtn.innerHTML = video.paused ? '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause-icon lucide-pause"><rect x="14" y="3" width="5" height="18" rx="1"/><rect x="5" y="3" width="5" height="18" rx="1"/></svg>';
                timeDisplay.textContent = `0:00 / 0:00`;
                progressBarFilled.style.width = '0%';

                try {
                    const likeBtnEl = document.getElementById('likeBtn');
                    const dislikeBtnEl = document.getElementById('dislikeBtn');
                    const favoriteBtnEl = document.getElementById('favoriteBtn');
                    const downloadBtnEl = document.getElementById('downloadBtn');
                    const likeCountEl = document.getElementById('likeCount');
                    const dislikeCountEl = document.getElementById('dislikeCount');
                    const statsMeta = await getVideoMetadata(currentVideo.dirHandle, currentVideo.name);
                    if (likeCountEl) likeCountEl.textContent = String(statsMeta.likes || 0);
                    if (dislikeCountEl) dislikeCountEl.textContent = String(statsMeta.dislikes || 0);

                    (async () => {
                        try {
                            const favs = await loadFavorites();
                            const favKey = buildVideoKey(currentVideo.name, currentVideo.playlist || '');
                            const isFav = (favs || []).some(it => it.key === favKey);
                            if (favoriteBtnEl) {
                                favoriteBtnEl.classList.toggle('favorite-active', !!isFav);
                                const label = favoriteBtnEl.querySelector('span');
                                if (label) label.textContent = isFav ? i18n.t('favorites.inFavorites', 'In favorites') : i18n.t('favorites.addToFavorites', 'Add to favorites');
                            }
                        } catch (_) { }
                    })();

                    if (likeBtnEl) likeBtnEl.onclick = async () => {
                        try {
                            const meta = await getVideoMetadata(currentVideo.dirHandle, currentVideo.name);
                            meta.likes = (meta.likes || 0) + 1;
                            await saveVideoMetadata(currentVideo.dirHandle, currentVideo.name, meta);
                            currentVideo.likes = meta.likes;
                            if (videoLikesEl) videoLikesEl.textContent = `${currentVideo.likes || 0} ${i18n.t('video.likes', 'likes')}`;
                            likeBtnEl.classList.add('liked');
                        } catch (_) { }
                    };

                    if (dislikeBtnEl) dislikeBtnEl.onclick = async () => {
                        try {
                            const meta = await getVideoMetadata(currentVideo.dirHandle, currentVideo.name);
                            meta.dislikes = (meta.dislikes || 0) + 1;
                            await saveVideoMetadata(currentVideo.dirHandle, currentVideo.name, meta);
                            currentVideo.dislikes = meta.dislikes;
                            if (videoDislikesEl) videoDislikesEl.textContent = `${currentVideo.dislikes || 0} ${i18n.t('video.dislikes', 'dislikes')}`;
                        } catch (_) { }
                    };

                    if (favoriteBtnEl) favoriteBtnEl.onclick = async () => {
                        try {
                            const favs = await loadFavorites();
                            const favKey = buildVideoKey(currentVideo.name, currentVideo.playlist || '');
                            const idx = favs.findIndex(it => it.key === favKey);
                            if (idx >= 0) {
                                favs.splice(idx, 1);
                                await saveFavorites(favs);
                                favoriteBtnEl.classList.remove('favorite-active');
                                const label = favoriteBtnEl.querySelector('span');
                                if (label) label.textContent = i18n.t('favorites.addToFavorites', 'Add to favorites');
                            } else {
                                const preview = capturePreviewForFav(video) || '';
                                favs.push({
                                    key: favKey,
                                    name: currentVideo.name,
                                    playlist: currentVideo.playlist || '',
                                    title: getFileNameWithoutExtension(currentVideo.name),
                                    preview,
                                    addedAt: Date.now()
                                });
                                await saveFavorites(favs);
                                favoriteBtnEl.classList.add('favorite-active');
                                const label = favoriteBtnEl.querySelector('span');
                                if (label) label.textContent = i18n.t('favorites.inFavorites', 'In favorites');
                            }
                        } catch (_) { }
                    };

                    if (downloadBtnEl) downloadBtnEl.onclick = () => {
                        try {
                            const a = document.createElement('a');
                            a.href = video.src;
                            a.download = currentVideo.name;
                            document.body.appendChild(a);
                            a.click();
                            a.remove();
                        } catch (_) { }
                    };
                } catch (_) { }

                video.currentTime = 0;

                const miniProgressFill = document.getElementById('miniProgressFill');
                if (miniProgressFill) {
                    miniProgressFill.style.width = '0%';
                }

                await renderCombinedPlaylist(playlistId, currentVideo.dirHandle, currentVideo.name);

                const currentPlaylist = allPlaylists.find(p => p.id === playlistId);
                if (currentPlaylist && currentPlaylist.videos) {
                    const currentIndex = currentPlaylist.videos.findIndex(v => v.name === currentVideo.name);
                    if (currentIndex !== -1) {
                        requestIdleCallback(() => {
                            preloadNextVideos(currentIndex, currentPlaylist.videos);
                        });
                    }
                }

                updateRecommendationsDebounced();
                attachCarouselNavEventListeners();

                updateLogoVisibility();
                updateClockVisibility();

                const overlayElement = document.getElementById('videoOverlay');
                if (overlayElement && video.paused) {
                    overlayElement.style.display = 'flex';
                    overlayElement.style.opacity = '1';
                }

                updateABMarkers();

                if (typeof window.updateDanmakuOverlay === 'function') {
                    window.updateDanmakuOverlay();
                }
                if (typeof window.debugDanmaku === 'function') {
                    window.debugDanmaku();
                }

                loadDanmakuComments();


                try {
                    if (typeof clearCommentImagesCache === 'function') {
                        clearCommentImagesCache();
                    }

                    await loadComments();
                    window.renderComments();
                    updateCommentsCount();
                } catch (error) {
                    debug.error('  :', error);
                }

            } else {
                showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.videoNotFound', '  ') : '  ', 'notfound');
            }
        }

        let currentPlaylistType = 'current';
        let virtualPlaylistRenderer = null;

        async function renderCombinedPlaylist(playlistId, dirHandle, currentVideoName) {
            debug.log('renderCombinedPlaylist called with:', { playlistId, dirHandle, currentVideoName });
            const playlistContent = document.getElementById('playlistContent');

            if (!playlistContent) {
                debug.log('Missing playlistContent element');
                return;
            }

            if (virtualPlaylistRenderer) {
                virtualPlaylistRenderer.destroy();
                virtualPlaylistRenderer = null;
            }

            playlistContent.innerHTML = '';
            playlistContent.className = 'virtual-playlist-container';

            if (currentPlaylistType === 'current') {
                if (playlistId) {
                    debug.log('Looking for playlist with ID:', playlistId);
                    const playlist = allPlaylists.find(pl => String(pl.id) === playlistId);
                    debug.log('Found playlist:', playlist);
                    
                    const playlistHeader = document.getElementById('playlistHeader');
                    const playlistTitleEl = document.getElementById('playlistTitle');
                    const playlistOpenLink = document.getElementById('playlistOpenLink');
                    
                    if (playlist && playlist.title) {
                        if (playlistHeader) playlistHeader.style.display = '';
                        if (playlistTitleEl) playlistTitleEl.textContent = playlist.title;
                        if (playlistOpenLink) {
                            playlistOpenLink.style.visibility = '';
                            playlistOpenLink.href = `youvi_playlists_view.html?playlistId=${playlistId}`;
                        }
                    } else {
                        if (playlistHeader) playlistHeader.style.display = 'none';
                    }
                    
                    if (playlist && playlist.videos && playlist.videos.length > 0) {
                        const videosToShow = playlist.videos.map(video => {
                            if (!video.channelName && Array.isArray(video.tags)) {
                                try {
                                    if (window.TagTypes) {
                                        video.channelName = window.TagTypes.getChannelFromTags(video.tags);
                                    } else {
                                        const chTags = video.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                                        if (chTags.length > 0) {
                                            video.channelName = chTags.map(t => t.replace(' ()', '')).join(', ');
                                        }
                                    }
                                } catch (_) { }
                            }
                            return video;
                        });
                        
                        if (window._playlistInverted) {
                            videosToShow.reverse();
                        }

                        if (window.VirtualPlaylistRenderer) {
                            virtualPlaylistRenderer = new window.VirtualPlaylistRenderer(playlistContent, {
                                itemHeight: 90,
                                bufferSize: 5,
                                onVideoClick: (video) => {
                                    window._openPlaylistTabOnLoad = true;
                                    
                                    const newUrl = window.VideoID.buildVideoUrl(video.name, playlistId);
                                    window.history.pushState({}, '', newUrl);
                                    currentVideo = video;
                                    loadVideoAndPlay();
                                }
                            });
                            virtualPlaylistRenderer.setVideos(videosToShow, currentVideoName);

                            requestIdleCallback(() => {
                                videosToShow.forEach(async (video) => {
                                    try {
                                        const videoDirHandle = video.dirHandle || currentVideo?.dirHandle;
                                        if (videoDirHandle) {
                                            const meta = await getVideoMetadata(videoDirHandle, video.name);
                                            video.views = meta.views || 0;
                                        }
                                    } catch (e) {
                                        debug.log('Could not load metadata for', video.name, e);
                                    }
                                });
                            });
                        }
                    } else {
                        const noPlaylist = document.createElement('div');
                        noPlaylist.textContent = i18n.t('playlists.playlistEmpty', 'Playlist is empty');
                        noPlaylist.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                        playlistContent.appendChild(noPlaylist);
                    }
                } else {
                    const playlistHeader = document.getElementById('playlistHeader');
                    if (playlistHeader) playlistHeader.style.display = 'none';
                    
                    const noPlaylist = document.createElement('div');
                    noPlaylist.textContent = i18n.t('playlists.noActivePlaylist', 'No active playlist');
                    noPlaylist.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                    playlistContent.appendChild(noPlaylist);
                }
            } else {
                const playlistHeader = document.getElementById('playlistHeader');
                const playlistTitleEl = document.getElementById('playlistTitle');
                const playlistOpenLink = document.getElementById('playlistOpenLink');
                
                if (dirHandle && dirHandle.name) {
                    if (playlistHeader) playlistHeader.style.display = '';
                    if (playlistTitleEl) playlistTitleEl.textContent = i18n.t('admin.folderPrefix') + ' ' + dirHandle.name;
                    if (playlistOpenLink) playlistOpenLink.style.visibility = 'hidden';
                } else {
                    if (playlistHeader) playlistHeader.style.display = 'none';
                }
                
                if (!dirHandle) {
                    const noFolder = document.createElement('div');
                    noFolder.textContent = i18n.t('admin.folderNotDefined');
                    noFolder.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                    playlistContent.appendChild(noFolder);
                    return;
                }

                const folderVideos = allVideos.filter(video => video.dirHandle === dirHandle);
                debug.log('Folder videos found:', folderVideos.length);
                if (folderVideos.length === 0) {
                    const noVideos = document.createElement('div');
                    noVideos.textContent = '   ';
                    noVideos.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                    playlistContent.appendChild(noVideos);
                    return;
                }

                const videosToShow = folderVideos.slice().sort((a, b) => {
                    const nameA = getFileNameWithoutExtension(a.name || '');
                    const nameB = getFileNameWithoutExtension(b.name || '');
                    return naturalSort(nameA, nameB);
                }).map(video => {
                    if (!video.channelName && Array.isArray(video.tags)) {
                        try {
                            if (window.TagTypes) {
                                video.channelName = window.TagTypes.getChannelFromTags(video.tags);
                            } else {
                                const chTags = video.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                                if (chTags.length > 0) {
                                    video.channelName = chTags.map(t => t.replace(' ()', '')).join(', ');
                                }
                            }
                        } catch (_) { }
                    }
                    return video;
                });
                
                if (window._playlistInverted) {
                    videosToShow.reverse();
                }

                if (window.VirtualPlaylistRenderer) {
                    virtualPlaylistRenderer = new window.VirtualPlaylistRenderer(playlistContent, {
                        itemHeight: 90,
                        bufferSize: 5,
                        onVideoClick: (video) => {
                            window._openPlaylistTabOnLoad = true;
                            
                            const newUrl = window.VideoID.buildVideoUrl(video.name);
                            window.history.pushState({}, '', newUrl);
                            currentVideo = video;
                            loadVideoAndPlay();
                        }
                    });
                    virtualPlaylistRenderer.setVideos(videosToShow, currentVideoName);

                    requestIdleCallback(() => {
                        videosToShow.forEach(async (video) => {
                            try {
                                const meta = await getVideoMetadata(dirHandle, video.name);
                                video.views = meta.views || 0;
                            } catch (e) {
                                debug.log('Could not load metadata for', video.name, e);
                            }
                        });
                    });
                }
            }
        }

        function createPlaylistVideoElement(video, currentVideoName, isCurrentVideo = false) {
            const relatedVideo = document.createElement('div');
            relatedVideo.className = 'related-video';
            if (isCurrentVideo) {
                relatedVideo.classList.add('current-video');
            }

            const lazyThumb = document.createElement('div');
            lazyThumb.className = 'lazy-thumb loading';
            lazyThumb.textContent = '...';

            const currentPlaylistId = new URLSearchParams(window.location.search).get('playlist');
            const videoUrl = window.VideoID.buildVideoUrl(video.name, currentPlaylistId);

            const channelInitial = video.channelName ? video.channelName.charAt(0).toUpperCase() : '?';
            const avatarId = `relatedAvatar_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;

            const danmakuCount = video.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(video.name) : 0);
            const createdDateObj = video.created ? new Date(video.created) : null;
            const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
            const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
            const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
            const metaParts = [];
            if (dateStr) metaParts.push(dateStr);
            metaParts.push(`${viewsSvg} ${(video.views || 0).toLocaleString()}`);
            metaParts.push(`${danmakuSvg} ${danmakuCount}`);
            const relatedMetaLine = metaParts.join('  ');

            relatedVideo.innerHTML = `
                <a href="${videoUrl}" class="related-video-link" title="${escapeHtml(getFileNameWithoutExtension(video.name))}"></a>
                <div class="related-thumb">
            ${lazyThumb.outerHTML}
            <div class="related-duration">0:00</div>
                </div>
                <div class="related-info">
                    <div class="related-title">${escapeHtml(getFileNameWithoutExtension(video.name))}</div>
                    <div class="related-meta-row">
                        <a href="youvi_ch_view.html?channel=${encodeURIComponent(video.channelName || '')}" class="channel-link" onclick="event.stopPropagation()">
                            <div class="channel-avatar" id="${avatarId}">${channelInitial}</div>
                        </a>
                        <div class="related-channel-info">
                            <a href="youvi_ch_view.html?channel=${encodeURIComponent(video.channelName || '')}" class="related-channel" onclick="event.stopPropagation()">${video.channelName || i18n.t('video.noChannel', 'No channel')}</a>
                            <div class="related-meta" style="color:#888;font-size:12px;">${relatedMetaLine}</div>
                        </div>
                    </div>
                </div>
            `;

            if (video.channelName) {
                requestIdleCallback(() => {
                    loadChannelAvatar(video.channelName).then(avatarUrl => {
                        if (avatarUrl) {
                            const avatarEl = document.getElementById(avatarId);
                            if (avatarEl) {
                                avatarEl.style.backgroundImage = `url(${avatarUrl})`;
                                avatarEl.classList.add('custom-avatar');
                                avatarEl.textContent = '';
                            }
                        }
                    }).catch(err => debug.error('Avatar load error:', err));
                });
            }

            requestIdleCallback(() => {
                (async () => {
                    try {
                        const { preview, duration } = await getPreviewAndDuration(video);
                        const thumbElement = relatedVideo.querySelector('.related-thumb');
                        const lazyElement = thumbElement?.querySelector('.lazy-thumb');

                        if (preview && thumbElement && lazyElement) {
                            const img = document.createElement('img');
                            img.dataset.src = preview;
                            img.alt = video.name;
                            img.loading = 'lazy';
                            img.decoding = 'async';
                            img.style.cssText = 'width:100%;height:100%;object-fit:cover;border-radius:4px;';

                            lazyLoadObserver.observe(img);
                            img.src = preview;

                            thumbElement.replaceChild(img, lazyElement);
                        } else if (lazyElement) {
                            lazyElement.className = 'lazy-thumb';
                            lazyElement.textContent = ' ';
                        }

                        const durationElement = thumbElement?.querySelector('.related-duration');
                        if (durationElement && duration) {
                            durationElement.textContent = duration;
                        }
                    } catch (error) {
                        debug.log('Error loading preview for', video.name, error);
                        const lazyElement = relatedVideo.querySelector('.lazy-thumb');
                        if (lazyElement) {
                            lazyElement.className = 'lazy-thumb';
                            lazyElement.textContent = ' ';
                        }
                    }
                })();
            });

            return relatedVideo;
        }

        function scrollToCurrentVideo() {
            const currentVideoElement = document.querySelector('.related-video.current-video');
            if (currentVideoElement) {
                currentVideoElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            function syncSidebarHeight() {
                if (document.body.classList.contains('wide-screen-mode') ||
                    document.body.classList.contains('cinema-mode') ||
                    document.fullscreenElement) {
                    return;
                }
                
                const playerSection = document.querySelector('.player-section');
                const danmakuContent = document.querySelector('.danmaku-content');
                const sidebarPanel = document.getElementById('sidebarPanelCombined');
                
                if (playerSection && sidebarPanel) {
                    let totalHeight = playerSection.offsetHeight;
                    if (danmakuContent) {
                        totalHeight += danmakuContent.offsetHeight;
                    }
                    if (totalHeight < 400) {
                        const playerWidth = playerSection.offsetWidth;
                        if (playerWidth > 0) {
                            totalHeight = Math.round(playerWidth * 9 / 16) + 60;
                        } else {
                            totalHeight = 500;
                        }
                    }
                    sidebarPanel.style.height = totalHeight + 'px';
                    sidebarPanel.style.maxHeight = totalHeight + 'px';
                }
            }
            
            syncSidebarHeight();
            setTimeout(syncSidebarHeight, 100);
            setTimeout(syncSidebarHeight, 500);
            window.addEventListener('resize', syncSidebarHeight);
            window.addEventListener('load', syncSidebarHeight);
            const videoForSync = document.getElementById('video');
            if (videoForSync) {
                videoForSync.addEventListener('loadedmetadata', syncSidebarHeight);
            }
            
            const tabs = document.querySelectorAll('.sidebar-panel-tab');
            const tabContents = document.querySelectorAll('.sidebar-tab-content');
            const danmakuControls = document.getElementById('danmakuControls');
            const playlistControls = document.getElementById('playlistControls');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.getAttribute('data-tab');
                    const currentTab = window._currentSidebarTab || 'danmaku';
                    
                    if (currentTab === 'danmaku' && targetTab !== 'danmaku') {
                        if (window.DanmakuScrollSync) {
                            window.DanmakuScrollSync.saveSidebarScrollPosition();
                        }
                    }
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === targetTab + 'TabContent') {
                            content.classList.add('active');
                        }
                    });
                    
                    if (danmakuControls) {
                        danmakuControls.style.display = targetTab === 'danmaku' ? '' : 'none';
                    }
                    if (playlistControls) {
                        playlistControls.style.display = targetTab === 'playlist' ? '' : 'none';
                    }
                    
                    if (targetTab === 'danmaku' && currentTab !== 'danmaku') {
                        const danmakuContent = document.getElementById('danmakuTabContent');
                        if (window.DanmakuScrollSync && danmakuContent) {
                            window.DanmakuScrollSync.syncSidebarScrollPosition(danmakuContent);
                        }
                    }
                    
                    window._currentSidebarTab = targetTab;
                });
            });
            
            
            const collapseBtn1 = document.getElementById('rightSidebarCollapseBtn');
            const collapseBtn2 = document.getElementById('rightSidebarCollapseBtnPlaylist');
            const sidebarPanelCombined = document.getElementById('sidebarPanelCombined');
            
            function togglePanelCollapse() {
                if (!sidebarPanelCombined) return;
                const wasCollapsed = sidebarPanelCombined.classList.contains('collapsed');
                sidebarPanelCombined.classList.toggle('collapsed');
                const collapsed = sidebarPanelCombined.classList.contains('collapsed');
                localStorage.setItem('danmakuPanelCollapsed', collapsed);
                
                if (wasCollapsed && !collapsed) {
                    const danmakuTab = document.querySelector('.sidebar-panel-tab[data-tab="danmaku"]');
                    const danmakuContent = document.getElementById('danmakuTabContent');
                    
                    if (danmakuTab && danmakuTab.classList.contains('active') && danmakuContent) {
                        if (window.DanmakuScrollSync) {
                            setTimeout(() => {
                                window.DanmakuScrollSync.syncSidebarScrollPosition(danmakuContent);
                            }, 100);
                        }
                    }
                }
            }
            
            if (sidebarPanelCombined) {
                const isCollapsed = localStorage.getItem('danmakuPanelCollapsed') === 'true';
                if (isCollapsed) {
                    sidebarPanelCombined.classList.add('collapsed');
                }
                
                if (collapseBtn1) collapseBtn1.addEventListener('click', togglePanelCollapse);
                if (collapseBtn2) collapseBtn2.addEventListener('click', togglePanelCollapse);
            }
            
            if (typeof window._danmakuFollowEnabled === 'undefined') {
                window._danmakuFollowEnabled = true;
            }
            
            const sidebarFollowBtn = document.getElementById('sidebarFollowBtn');
            if (sidebarFollowBtn) {
                sidebarFollowBtn.classList.toggle('active', window._danmakuFollowEnabled);
                
                sidebarFollowBtn.addEventListener('click', () => {
                    window._danmakuFollowEnabled = !window._danmakuFollowEnabled;
                    sidebarFollowBtn.classList.toggle('active', window._danmakuFollowEnabled);
                    
                    const panelFollow = document.getElementById('danmakuPanelFollow');
                    if (panelFollow) {
                        panelFollow.classList.toggle('active', window._danmakuFollowEnabled);
                    }
                });
            }
              const videoEl = document.getElementById('video');
            if (videoEl) {
                let lastSidebarHighlightTime = 0;
                videoEl.addEventListener('timeupdate', () => {
                    const danmakuTab = document.getElementById('danmakuTabContent');
                    if (!danmakuTab || !danmakuTab.classList.contains('active')) return;
                    
                    // Throttle updates
                    const now = Date.now();
                    if (now - lastSidebarHighlightTime < 500) return;
                    lastSidebarHighlightTime = now;
                    
                    const currentTime = videoEl.currentTime;
                    const commentsList = document.getElementById('danmakuCommentsList');
                    
                    // For follow mode with large datasets, use binary search on cached data
                    if (window._danmakuFollowEnabled && _sortedDanmakuData && _sortedDanmakuData.length > 0) {
                        const targetIndex = findDanmakuIndexByTime(_sortedDanmakuData, currentTime);
                        
                        if (targetIndex >= 0) {
                            // Check if we need to load more items
                            const renderedItems = commentsList ? commentsList.querySelectorAll('.danmaku-comment-item').length : 0;
                            const loadMoreBtn = commentsList ? commentsList.querySelector('.danmaku-load-more') : null;
                            
                            // If target is beyond rendered items, auto-load more
                            if (targetIndex >= renderedItems && loadMoreBtn) {
                                loadMoreBtn.click();
                                // Re-check after loading
                                requestAnimationFrame(() => {
                                    highlightSidebarDanmaku(danmakuTab, currentTime);
                                });
                                return;
                            }
                        }
                    }
                    
                    highlightSidebarDanmaku(danmakuTab, currentTime);
                });
            }
            
            function highlightSidebarDanmaku(danmakuTab, currentTime) {
                const items = danmakuTab.querySelectorAll('.danmaku-comment-item');
                let firstCurrentItem = null;
                
                
                items.forEach(item => {
                    const timeSpan = item.querySelector('.danmaku-comment-time');
                    if (!timeSpan) return;
                    const timeText = timeSpan.textContent;
                    const timeParts = timeText.split(':').map(Number);
                    let time = 0;
                    if (timeParts.length === 3) {
                        time = timeParts[0] * 3600 + timeParts[1] * 60 + timeParts[2];
                    } else if (timeParts.length === 2) {
                        time = timeParts[0] * 60 + timeParts[1];
                    }
                    
                    const isCurrent = Math.abs(time - currentTime) < 2;
                    item.classList.toggle('current', isCurrent);
                    
                    if (isCurrent && !firstCurrentItem) {
                        firstCurrentItem = item;
                    }
                });
                
                if (window._danmakuFollowEnabled && firstCurrentItem) {
                    const itemTop = firstCurrentItem.offsetTop;
                    const listHeight = danmakuTab.clientHeight;
                    const itemHeight = firstCurrentItem.offsetHeight;
                    const scrollTarget = itemTop - (listHeight / 2) + (itemHeight / 2);
                    const behavior = window._danmakuSkipSmoothScroll ? 'instant' : 'smooth';
                    danmakuTab.scrollTo({ top: scrollTarget, behavior: behavior });
                    if (window._danmakuSkipSmoothScroll) {
                        window._danmakuSkipSmoothScroll = false;
                    }
                }
            }

            const clearDanmakuBtn = document.getElementById('clearDanmakuBtn');
            if (clearDanmakuBtn) {
                clearDanmakuBtn.addEventListener('click', () => {
                    if (confirm('     ?')) {
                        clearDanmakuComments();
                    }
                });
            }
            
            const playlistToggle = document.getElementById('playlistToggle');
            const playlistContent = document.getElementById('playlistContent');
            if (playlistToggle) {
                playlistToggle.addEventListener('click', () => {
                    currentPlaylistType = currentPlaylistType === 'current' ? 'folder' : 'current';
                    playlistToggle.classList.toggle('rotated');
                    
                    if (currentVideo) {
                        if (playlistContent) {
                            playlistContent.innerHTML = '';
                        }
                        const urlParams = new URLSearchParams(window.location.search);
                        const playlistId = urlParams.get('playlist') || urlParams.get('userPlaylist');
                        renderCombinedPlaylist(playlistId, currentVideo.dirHandle, currentVideo.name);
                    }
                });
            }
            
            window._playlistInverted = localStorage.getItem('playlistInverted') === 'true';
            window._playlistLoop = localStorage.getItem('playlistLoop') === 'true';
            window._playlistShuffle = localStorage.getItem('playlistShuffle') === 'true';
            
            const playlistInvertBtn = document.getElementById('playlistInvertBtn');
            const playlistLoopBtn = document.getElementById('playlistLoopBtn');
            const playlistShuffleBtn = document.getElementById('playlistShuffleBtn');
            
            if (playlistInvertBtn) playlistInvertBtn.classList.toggle('active', window._playlistInverted);
            if (playlistLoopBtn) playlistLoopBtn.classList.toggle('active', window._playlistLoop);
            if (playlistShuffleBtn) playlistShuffleBtn.classList.toggle('active', window._playlistShuffle);
            
            if (playlistInvertBtn) {
                playlistInvertBtn.addEventListener('click', () => {
                    window._playlistInverted = !window._playlistInverted;
                    localStorage.setItem('playlistInverted', window._playlistInverted);
                    playlistInvertBtn.classList.toggle('active', window._playlistInverted);
                    
                    const urlParams = new URLSearchParams(window.location.search);
                    const playlistId = urlParams.get('playlist') || urlParams.get('userPlaylist');
                    const playlistContentEl = document.getElementById('playlistContent');
                    if (playlistContentEl) {
                        playlistContentEl.innerHTML = '';
                    }
                    renderCombinedPlaylist(playlistId, currentVideo?.dirHandle, currentVideo?.name);
                });
            }
            
            if (playlistLoopBtn) {
                playlistLoopBtn.addEventListener('click', () => {
                    window._playlistLoop = !window._playlistLoop;
                    localStorage.setItem('playlistLoop', window._playlistLoop);
                    playlistLoopBtn.classList.toggle('active', window._playlistLoop);
                });
            }
            
            if (playlistShuffleBtn) {
                playlistShuffleBtn.addEventListener('click', () => {
                    window._playlistShuffle = !window._playlistShuffle;
                    localStorage.setItem('playlistShuffle', window._playlistShuffle);
                    playlistShuffleBtn.classList.toggle('active', window._playlistShuffle);
                });
            }
        });

        async function renderCurrentPlaylist(playlistId) {
            await renderCombinedPlaylist(playlistId, currentVideo?.dirHandle, currentVideo?.name);
        }

        async function renderFolderPlaylist(dirHandle, currentVideoName) {
            await renderCombinedPlaylist(currentVideo?._playlistId, dirHandle, currentVideoName);
        }

        async function renderRandomRecommendations() {
            const numRecommendations = 12;
            let otherVideos = allVideos.filter(video => video.name !== currentVideo.name);

            if (currentFilter !== 'all') {
                otherVideos = otherVideos.filter(video =>
                    video.categories && video.categories.some(cat => cat.trim().toLowerCase() === currentFilter.trim().toLowerCase())
                );
            }

            let sortedRecommendations = otherVideos.sort(() => 0.5 - Math.random());
            const recommendations = sortedRecommendations.slice(0, numRecommendations);

            const sidebarSection = document.getElementById('recommendationsSidebar');
            if (!sidebarSection) return;

            const title = sidebarSection.querySelector('.section-title-right');
            sidebarSection.innerHTML = '';
            if (title) sidebarSection.appendChild(title);

            if (recommendations.length === 0) {
                const noRecommendations = document.createElement('div');
                noRecommendations.textContent = ' ';
                noRecommendations.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                sidebarSection.appendChild(noRecommendations);
                return;
            }

            for (const video of recommendations) {
                try {
                    if (!video.channelName && Array.isArray(video.tags)) {
                        if (window.TagTypes) {
                            video.channelName = window.TagTypes.getChannelFromTags(video.tags);
                        } else {
                            const chTags = video.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                            if (chTags.length > 0) video.channelName = chTags.map(t => t.replace(' ()', '')).join(', ');
                        }
                    }
                } catch (_) { }
                const relatedVideo = createPlaylistVideoElement(video, currentVideo?.name, false);
                relatedVideo.addEventListener('click', () => {
                    const currentPlaylistId = new URLSearchParams(window.location.search).get('playlist');
                    let newUrl;
                    if (window.VideoID) {
                        newUrl = window.VideoID.buildVideoUrl(video.name, currentPlaylistId);
                    } else {
                        const url = new URL(window.location.href);
                        url.searchParams.set('name', video.name);
                        if (currentPlaylistId) {
                            url.searchParams.set('playlist', currentPlaylistId);
                        }
                        newUrl = url.toString();
                    }
                    window.history.pushState({}, '', newUrl);
                    currentVideo = video;
                    loadVideoAndPlay();
                });
                sidebarSection.appendChild(relatedVideo);
            }
        }

        let recsUpdateTimer = null;
        let lastRecsVideoCount = 0;
        function updateRecommendationsDebounced() {
            if (recsUpdateTimer) {
                clearTimeout(recsUpdateTimer);
            }
            
            recsUpdateTimer = setTimeout(() => {
                try {
                    if (!window.YouviRecommendations || !Array.isArray(allVideos) || !currentVideo) {
                        return;
                    }
                    
                    const needsUpdate = window.YouviRecommendations.needsRebuild 
                        ? window.YouviRecommendations.needsRebuild(allVideos)
                        : allVideos.length !== lastRecsVideoCount;
                    
                    if (needsUpdate) {
                        window.YouviRecommendations.onAllVideosUpdated(allVideos);
                        lastRecsVideoCount = allVideos.length;
                        debug.log('[Recommendations] Index updated:', allVideos.length, 'videos');
                    }
                    
                    renderRecommendationsSidebarEfficient();
                } catch (e) {
                    debug.warn('[Recommendations] Update failed:', e);
                }
                recsUpdateTimer = null;
            }, 200);
        }

        function renderRecommendationsSidebarEfficient() {
            const sidebarSection = document.getElementById('recommendationsSidebar');
            if (!sidebarSection) return;
            const title = sidebarSection.querySelector('.section-title-right');
            
            const fragment = document.createDocumentFragment();
            
            if (!window.YouviRecommendations || !currentVideo) {
                const loading = document.createElement('div');
                loading.textContent = ' ';
                loading.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                fragment.appendChild(loading);
                sidebarSection.innerHTML = '';
                if (title) sidebarSection.appendChild(title);
                sidebarSection.appendChild(fragment);
                return;
            }
            const recs = window.YouviRecommendations.recommendFor(currentVideo, { limit: 15 }) || [];
            if (recs.length === 0) {
                const noRecommendations = document.createElement('div');
                noRecommendations.textContent = ' ';
                noRecommendations.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                fragment.appendChild(noRecommendations);
                sidebarSection.innerHTML = '';
                if (title) sidebarSection.appendChild(title);
                sidebarSection.appendChild(fragment);
                return;
            }
            for (const video of recs) {
                try {
                    if (!video.channelName && Array.isArray(video.tags)) {
                        if (window.TagTypes) {
                            video.channelName = window.TagTypes.getChannelFromTags(video.tags);
                        } else {
                            const chTags = video.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                            if (chTags.length > 0) video.channelName = chTags.map(t => t.replace(' ()', '')).join(', ');
                        }
                    }
                } catch (_) { }
                const relatedVideo = createPlaylistVideoElement(video, currentVideo?.name, false);
                relatedVideo.addEventListener('click', () => {
                    const currentPlaylistId = new URLSearchParams(window.location.search).get('playlist');
                    let newUrl;
                    if (window.VideoID) {
                        newUrl = window.VideoID.buildVideoUrl(video.name, currentPlaylistId);
                    } else {
                        const url = new URL(window.location.href);
                        url.searchParams.set('name', video.name);
                        if (currentPlaylistId) {
                            url.searchParams.set('playlist', currentPlaylistId);
                        }
                        newUrl = url.toString();
                    }
                    window.history.pushState({}, '', newUrl);
                    currentVideo = video;
                    loadVideoAndPlay();
                });
                fragment.appendChild(relatedVideo);
            }
            sidebarSection.innerHTML = '';
            if (title) sidebarSection.appendChild(title);
            sidebarSection.appendChild(fragment);
        }

        async function renderCarousel(carouselId, videos, playlistId = null) {
            const carousel = document.getElementById(carouselId);
            if (!carousel) return;

            carousel.innerHTML = '';
            const currentVideoPage = carouselVideoPages.get(playlistId) || 1;

            carousel.querySelectorAll('.video-thumbnail').forEach(el => el.classList.remove('active-thumbnail'));

            const totalVideoPages = Math.ceil((videos ? videos.length : 0) / videosPerPage);
            const videoStart = (currentVideoPage - 1) * videosPerPage;
            const videoEnd = Math.min(videoStart + videosPerPage, videos ? videos.length : 0);

            const videosToRender = videos.slice(videoStart, videoEnd);

            if (videosToRender.length > 0) {
                const previewTasks = [];
                for (const video of videosToRender) {
                    const videoCard = document.createElement('div');
                    videoCard.className = 'video-card';

                    const thumbnailElement = document.createElement('a');
                    thumbnailElement.className = 'video-thumbnail';
                    const thumbUrl = window.VideoID 
                        ? window.VideoID.buildVideoUrl(video.name, playlistId)
                        : `youvi_video.html?name=${encodeURIComponent(video.name)}${playlistId ? `&playlist=${encodeURIComponent(playlistId)}` : ''}`;
                    thumbnailElement.href = thumbUrl;
                    thumbnailElement.title = `${escapeHtml(getFileNameWithoutExtension(video.name))}`;

                    if (currentVideo && video.name === currentVideo.name) {
                        thumbnailElement.classList.add('active-thumbnail');
                    }


                    thumbnailElement.innerHTML = `
                        <div class="video-duration">...</div>
                        <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                            ${escapeHtml(getFileNameWithoutExtension(video.name))}
                        </div>`;

                    const infoElement = document.createElement('div');
                    infoElement.className = 'video-info';
                    const danmakuCount = video.danmakuCount || (window.DanmakuCounter ? window.DanmakuCounter.get(video.name) : 0);
                    const createdDateObj = video.created ? new Date(video.created) : null;
                    const dateStr = createdDateObj ? `${String(createdDateObj.getDate()).padStart(2,'0')}/${String(createdDateObj.getMonth()+1).padStart(2,'0')}/${createdDateObj.getFullYear()}` : '';
                    const viewsSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`;
                    const danmakuSvg = `<svg width="12" height="12" viewBox="0 0 24 24" style="display:inline;vertical-align:-2px;"><path fill="#888" d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg>`;
                    const metaParts = [];
                    if (dateStr) metaParts.push(dateStr);
                    metaParts.push(`${viewsSvg} ${(video.views || 0).toLocaleString()}`);
                    metaParts.push(`${danmakuSvg} ${danmakuCount}`);
                    infoElement.innerHTML = `
                        <div class="video-playlist">${video.channelName ? `<a href="channel_view.html?channel=${encodeURIComponent(video.channelName)}" class="playlist-channel-link">${escapeHtml(video.channelName)}</a>` : `<span>${i18n.t('video.noChannel', 'No channel')}</span>`}</div>
                        <div class="video-card-title">${escapeHtml(getFileNameWithoutExtension(video.name))}</div>
                        <div class="video-category" style="color:#888;font-size:12px;">${metaParts.join('  ')}</div>
                    `;

                    videoCard.appendChild(thumbnailElement);
                    videoCard.appendChild(infoElement);
                    carousel.appendChild(videoCard);

                    previewTasks.push(createVideoCardPreviewTask(video, thumbnailElement));

                    videoCard.addEventListener('click', async (e) => {
                        if (e.target.closest('.video-thumbnail')) {
                            return;
                        }
                        if (!e.target.closest('.video-playlist a') && !e.target.closest('.video-category-link')) {
                            let newUrl;
                            if (window.VideoID) {
                                newUrl = window.VideoID.buildVideoUrl(video.name, playlistId);
                            } else {
                                const url = new URL(window.location.href);
                                url.searchParams.set('name', video.name);
                                url.searchParams.set('playlist', playlistId || '');
                                newUrl = url.toString();
                            }
                            window.history.pushState({}, '', newUrl);

                            document.querySelectorAll('.video-card').forEach(card => card.classList.remove('active'));

                            currentVideo = video;
                            await loadVideoAndPlay();

                            videoCard.classList.add('active');
                        }
                    });
                }
                await parallelLimit(previewTasks, 3);
            } else {
                carousel.innerHTML = '<div class="empty-state" style="padding: 20px; font-size: 14px;"> .</div>';
            }

            const carouselWrapper = carousel.closest('.video-carousel-wrapper');
            if (!carouselWrapper) return;
            const prevBtn = carouselWrapper.querySelector('.prev-btn');
            const nextBtn = carouselWrapper.querySelector('.next-btn');
            if (prevBtn) prevBtn.style.display = currentVideoPage > 1 ? 'flex' : 'none';
            if (nextBtn) nextBtn.style.display = currentVideoPage < totalVideoPages ? 'flex' : 'none';
        }

        function createVideoCardPreviewTask(video, thumbnailElement) {
            return async () => {
                try {
                    const { preview, duration } = await getPreviewAndDuration(video);
                    if (preview) {
                        thumbnailElement.innerHTML = `<img src="${preview}" style="width:100%;height:100%;object-fit:cover;">`;
                    }
                    const newDurationElement = document.createElement('div');
                    newDurationElement.className = 'video-duration';
                    newDurationElement.textContent = duration;
                    thumbnailElement.appendChild(newDurationElement);
                } catch (e) {
                    debug.error('Error loading preview for', video.name, e);
                    thumbnailElement.innerHTML = `
                        <div class="video-duration">0:00</div>
                        <div style="width:100%;height:100%;background:#333;display:flex;align-items:center;justify-content:center;color:#fff;font-size:10px;text-align:center;padding:5px;">
                            ${escapeHtml(getFileNameWithoutExtension(video.name))}
                        </div>`;
                }
            };
        }

        function attachCarouselNavEventListeners() {
            document.querySelectorAll('.video-carousel-wrapper').forEach(wrapper => {
                const carousel = wrapper.querySelector('.video-carousel');
                const prevBtn = wrapper.querySelector('.prev-btn');
                const nextBtn = wrapper.querySelector('.next-btn');

                const playlistId = prevBtn ? prevBtn.dataset.playlistId : (nextBtn ? nextBtn.dataset.playlistId : null);
                const playlistType = prevBtn ? prevBtn.dataset.playlistType : (nextBtn ? nextBtn.dataset.playlistType : null);

                if (!carousel || !prevBtn || !nextBtn || !playlistId || !playlistType) return;

                prevBtn.addEventListener('click', () => {
                    let currentPage = carouselVideoPages.get(playlistId) || 1;
                    if (currentPage > 1) {
                        currentPage--;
                        carouselVideoPages.set(playlistId, currentPage);
                        if (playlistType === 'current') {
                            renderCurrentPlaylist(playlistId);
                        } else if (playlistType === 'folder') {
                            renderFolderPlaylist(currentVideo.dirHandle, currentVideo.name);
                        } else if (playlistType === 'recommendations') {
                            if (window.YouviRecommendations) renderRecommendationsSidebarEfficient();
                        }
                    }
                });

                nextBtn.addEventListener('click', () => {
                    let currentPage = carouselVideoPages.get(playlistId) || 1;
                    let videos = [];
                    if (playlistType === 'current') {
                        const playlist = allPlaylists.find(pl => String(pl.id) === playlistId);
                        videos = playlist ? playlist.videos : [];
                    } else if (playlistType === 'folder') {
                        videos = allVideos.filter(video => video.dirHandle === currentVideo.dirHandle && video.name !== currentVideo.name);
                    } else if (playlistType === 'recommendations') {
                        videos = allVideos.filter(video => video.name !== currentVideo.name);
                    }

                    const totalVideoPages = Math.ceil((videos ? videos.length : 0) / videosPerPage);
                    if (currentPage < totalVideoPages) {
                        currentPage++;
                        carouselVideoPages.set(playlistId, currentPage);
                        if (playlistType === 'current') {
                            renderCurrentPlaylist(playlistId);
                        } else if (playlistType === 'folder') {
                            renderFolderPlaylist(currentVideo.dirHandle, currentVideo.name);
                        } else if (playlistType === 'recommendations') {
                            if (window.YouviRecommendations) renderRecommendationsSidebarEfficient();
                        }
                    }
                });
            });
        }


        function getFileNameWithoutExtension(name) { return name.replace(/\.[^/.]+$/, ''); }
        function formatFileSize(b) { if (b < 1024) return b + ' B'; if (b < 1048576) return (b / 1024).toFixed(1) + ' KB'; return (b / 1048576).toFixed(1) + ' MB'; }
        function formatDuration(sec) {
            if (!isFinite(sec) || isNaN(sec) || sec <= 0) return '0:00';
            const s = Math.round(sec);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const ss = String(s % 60).padStart(2, '0');
            return h > 0 ? `${h}:${String(m).padStart(2, '0')}:${ss}` : `${m}:${ss}`;
        }

        function escapeHtml(text) { const d = document.createElement('div'); d.textContent = text ?? ''; return d.innerHTML; }

        function naturalSort(a, b) {
            const normalize = (s) => s.replace(//g, 'e');

            const chunkify = (s) => {
                const match = s.match(/\D+|\d+/g);
                return match ? match.map(c => isNaN(c) ? c.toLowerCase() : parseInt(c, 10)) : [];
            };

            const aChunks = chunkify(normalize(String(a)));
            const bChunks = chunkify(normalize(String(b)));

            for (let i = 0; i < Math.min(aChunks.length, bChunks.length); i++) {
                const aChunk = aChunks[i];
                const bChunk = bChunks[i];

                if (typeof aChunk === 'number' && typeof bChunk === 'number') {
                    if (aChunk < bChunk) return -1;
                    if (aChunk > bChunk) return 1;
                } else if (typeof aChunk === 'string' && typeof bChunk === 'string') {
                    const cmp = aChunk.localeCompare(bChunk, 'ru', { numeric: false, caseFirst: 'lower' });
                    if (cmp !== 0) return cmp;
                } else if (typeof aChunk === 'number') {
                    return -1;
                } else {
                    return 1;
                }
            }
            return aChunks.length - bChunks.length;
        }
        function attachVideoPlayerEventListeners() {
            const video = document.getElementById('video');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const progressBarFilled = document.getElementById('progressBarFilled');
            const timeDisplay = document.getElementById('timeDisplay');
            const volumeBtn = document.getElementById('volumeBtn');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            const volumeSlider = document.getElementById('volumeSlider');
            const progressBar = document.getElementById('progressBar');

            updateVolumeIcon();
            const progressHandle = document.getElementById('progressHandle');
            const progressPreview = document.getElementById('progressPreview');
            const previewCanvas = document.getElementById('previewCanvas');
            const previewTime = document.getElementById('previewTime');
            const pctx = previewCanvas ? previewCanvas.getContext('2d') : null;
            const offscreenVideo = document.createElement('video');
            offscreenVideo.muted = true;
            offscreenVideo.preload = 'metadata';

            const settingsBtn = document.getElementById('settingsBtn');
            const settingsMenu = document.getElementById('settingsMenu');

            let speedHud = null;
            let speedHudTimer = null;
            let allowSpeedHUD = false;
            let baseRate = 1;
            let suppressNextPauseHud = false;

            if (!video || !playPauseBtn || !progressBarFilled || !timeDisplay || !volumeBtn || !fullscreenBtn || !volumeSlider || !progressBar || !progressHandle || !progressPreview || !previewCanvas || !previewTime || !settingsBtn || !settingsMenu) {
                debug.error('Video player elements not found for event listeners.');
                return;
            }

            const videoSpinner = document.getElementById('videoSpinner');
            let spinnerTimer = null;
            function showSpinnerDelayed() {
                if (!videoSpinner) return;
                if (spinnerTimer) return;
                spinnerTimer = setTimeout(() => {
                    if (videoSpinner) videoSpinner.style.display = 'block';
                }, 200);
            }
            function hideSpinnerNow() {
                if (!videoSpinner) return;
                if (spinnerTimer) { clearTimeout(spinnerTimer); spinnerTimer = null; }
                videoSpinner.style.display = 'none';
            }
            video.addEventListener('waiting', showSpinnerDelayed);
            video.addEventListener('stalled', showSpinnerDelayed);
            video.addEventListener('seeking', showSpinnerDelayed);
            video.addEventListener('canplay', hideSpinnerNow);
            video.addEventListener('canplaythrough', hideSpinnerNow);
            video.addEventListener('seeked', hideSpinnerNow);
            video.addEventListener('playing', hideSpinnerNow);

            function updateVolumeIcon() {
                if (video.muted || video.volume === 0) {
                    volumeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-off-icon lucide-volume-off"><path d="M16 9a5 5 0 0 1 .95 2.293"/><path d="M19.364 5.636a9 9 0 0 1 1.889 9.96"/><path d="m2 2 20 20"/><path d="m7 7-.587.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298V11"/><path d="M9.828 4.172A.686.686 0 0 1 11 4.657v.686"/></svg>';
                } else if (video.volume < 0.5) {
                    volumeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume1-icon lucide-volume-1"><path d="M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"/><path d="M16 9a5 5 0 0 1 0 6"/></svg>';
                } else {
                    volumeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume2-icon lucide-volume-2"><path d="M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z"/><path d="M16 9a5 5 0 0 1 0 6"/><path d="M19.364 18.364a9 9 0 0 0 0-12.728"/></svg>';
                }
            }

            function showVolumeHUD(volumePercent) {
                const volumeHud = document.getElementById('volumeHud');
                if (!volumeHud) return;
                volumeHud.textContent = `: ${Math.round(volumePercent)}%`;
                volumeHud.style.display = 'block';
                clearTimeout(volumeHudTimer);
                volumeHudTimer = setTimeout(() => { if (volumeHud) volumeHud.style.display = 'none'; }, 800);
            }

            function applyVolume(newVolumePercent) {
                const newVolume = newVolumePercent / 100;
                video.volume = newVolume;
                video.muted = (newVolume === 0);
                localStorage.setItem('videoVolume', newVolume);
                volumeSlider.value = newVolumePercent;
                const fillPct = newVolumePercent;
                volumeSlider.style.setProperty('--volPos', `${fillPct}%`);
                volumeSlider.style.setProperty('--volColor', `#ff69b4`);
                updateVolumeIcon();
            }

            const savedVolume = localStorage.getItem('videoVolume');
            if (savedVolume !== null) {
                applyVolume(parseFloat(savedVolume) * 100);
            } else {
                applyVolume(100);
            }

            volumeSlider.addEventListener('input', () => {
                applyVolume(parseFloat(volumeSlider.value));
                showVolumeHUD(parseFloat(volumeSlider.value));
            });

            progressBar.addEventListener('click', (e) => {
                const rect = progressBar.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                const clickTime = video.duration * percentage;

                if (e.shiftKey) {
                    e.preventDefault();
                    window.abSegmentMode++;
                    if (window.abSegmentMode > 3) window.abSegmentMode = 0;

                    if (window.abSegmentMode === 1) {
                        window.abSegmentA = clickTime;
                        window.abSegmentB = null;
                        debug.log('A segment set at:', formatDuration(clickTime));
                        window.updateABMarkers();
                    } else if (window.abSegmentMode === 2) {
                        window.abSegmentB = clickTime;
                        debug.log('B segment set at:', formatDuration(clickTime));
                        window.updateABMarkers();
                        if (window.abSegmentA !== null && window.abSegmentB !== null) {
                            const startTime = Math.min(window.abSegmentA, window.abSegmentB);
                            video.currentTime = startTime;
                            video.play();
                        }
                    } else if (window.abSegmentMode === 3) {
                        window.abSegmentA = null;
                        window.abSegmentB = null;
                        window.abSegmentMode = 0;
                        debug.log('A/B segments reset');
                        window.updateABMarkers();
                    }
                } else {
                    video.currentTime = clickTime;
                }
            });

            video.addEventListener('click', () => {
                if (window.suppressNextVideoClick) {
                    window.suppressNextVideoClick = false;
                    return;
                }

                const overlay = document.getElementById('videoOverlay');
                if (overlay && overlay.style.display !== 'none') {
                    return;
                }

                if (video.paused || video.ended) {
                    if (overlay) {
                        overlay.style.opacity = '0';
                        setTimeout(() => overlay.style.display = 'none', 300);
                    }
                    video.play();
                    hasStarted = true;
                    updateClockVisibility();
                } else {
                    video.pause();
                    showControls();
                }
            });

            //   touch   play/pause
            let videoTouchStartTime = 0;
            let videoTouchMoved = false;
            
            video.addEventListener('touchstart', (e) => {
                videoTouchStartTime = Date.now();
                videoTouchMoved = false;
            }, { passive: true });
            
            video.addEventListener('touchmove', (e) => {
                videoTouchMoved = true;
            }, { passive: true });
            
            video.addEventListener('touchend', (e) => {
                //      ,     
                const touchDuration = Date.now() - videoTouchStartTime;
                if (!videoTouchMoved && touchDuration < 300 && !suppressNextClick) {
                    const overlay = document.getElementById('videoOverlay');
                    if (overlay && overlay.style.display !== 'none') {
                        return;
                    }

                    if (video.paused || video.ended) {
                        if (overlay) {
                            overlay.style.opacity = '0';
                            setTimeout(() => overlay.style.display = 'none', 300);
                        }
                        video.play();
                        hasStarted = true;
                        updateClockVisibility();
                    } else {
                        video.pause();
                        showControls();
                    }
                }
            }, { passive: true });





            video.addEventListener("play", () => {
                hasStarted = true;
                updateLogoVisibility();
                updateClockVisibility();
                if (hasStarted) showHud('');

                if (window.currentVideo) {
                    const title = getFileNameWithoutExtension(window.currentVideo.name);
                    document.title = ` ${title} | Youvi`;
                }

                setTimeout(() => {
                    try {
                        if (window.VideoMetaTags && window.currentVideo && video.videoWidth) {
                            const capturedPreview = window.VideoMetaTags.capturePreview(video);
                            if (capturedPreview) {
                                window.VideoMetaTags.updateFromVideo(window.currentVideo, capturedPreview);
                            }
                        }
                    } catch (e) { }
                }, 1000);
            });

            video.addEventListener("pause", () => {
                updateLogoVisibility();
                updateClockVisibility();

                if (window.currentVideo) {
                    const title = getFileNameWithoutExtension(window.currentVideo.name);
                    document.title = `${title} | Youvi`;
                }

                const nearEnd = isFinite(video.duration) && (video.duration - (video.currentTime || 0)) < 0.2;
                if (suppressNextPauseHud || video.ended || nearEnd) {
                    suppressNextPauseHud = false;
                } else if (hasStarted) {
                    showHud('');
                }
                cancelAutoplayIfActive();
            });

            video.addEventListener("ended", () => {
                updateLogoVisibility();
                updateClockVisibility();
            });

            playPauseBtn.addEventListener('click', () => {
                if (video.paused || video.ended) {
                    const overlay = document.getElementById('videoOverlay');
                    if (overlay) {
                        overlay.style.opacity = '0';
                        setTimeout(() => overlay.style.display = 'none', 300);
                    }
                    video.play();
                    playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause-icon lucide-pause"><rect x="14" y="3" width="5" height="18" rx="1"/><rect x="5" y="3" width="5" height="18" rx="1"/></svg>';
                    hasStarted = true;
                    updateClockVisibility();
                    const progressPreview = document.getElementById('progressPreview');
                    if (progressPreview) progressPreview.style.display = 'none';
                } else {
                    video.pause();
                    playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>';
                }
                updateClockVisibility();
            });

            const bigPlayBtn = document.getElementById('bigPlayBtn');
            if (bigPlayBtn) {
                bigPlayBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const overlay = document.getElementById('videoOverlay');
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.style.display = 'none', 300);
                    video.play();
                    hasStarted = true;
                    updateClockVisibility();
                    showControls();
                });
            }

            const overlay = document.getElementById('videoOverlay');
            if (overlay) {
                overlay.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            video.addEventListener('loadedmetadata', () => {
                if (video.duration && isFinite(video.duration)) {
                    timeDisplay.textContent = `0:00 / ${formatDuration(video.duration)}`;
                }
            });

            let lastProgressUpdate = 0;
            const updateInterval = isMobile || isLowEndDevice ? 200 : 100;
            video.addEventListener('timeupdate', () => {
                const now = performance.now();
                if (now - lastProgressUpdate < updateInterval) return;
                lastProgressUpdate = now;

                const progress = (video.currentTime / video.duration) * 100;
                progressBarFilled.style.width = `${progress}%`;
                timeDisplay.textContent = `${formatDuration(video.currentTime)} / ${formatDuration(video.duration)}`;
                progressHandle.style.left = `${progress}%`;

                const miniProgressFill = document.getElementById('miniProgressFill');
                const miniProgressBar = document.getElementById('miniProgressBar');
                if (miniProgressFill && miniProgressBar && miniProgressBar.classList.contains('show') && !videoContainer.classList.contains('fullscreen')) {
                    miniProgressFill.style.width = `${progress}%`;
                }

                if (window.abSegmentA !== null && window.abSegmentB !== null) {
                    const startTime = Math.min(window.abSegmentA, window.abSegmentB);
                    const endTime = Math.max(window.abSegmentA, window.abSegmentB);
                    if (video.currentTime >= endTime) {
                        video.currentTime = startTime;
                    } else if (video.currentTime < startTime) {
                        video.currentTime = endTime - 0.1;
                    }
                }
            });

            let lastPreviewTs = 0;
            let previewSeekScheduled = false;
            let isScrubbing = false;

            function seekFromClientX(clientX) {
                const rect = progressBar.getBoundingClientRect();
                const pos = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                const newTime = pos * (video.duration || 0);
                if (isFinite(newTime)) {
                    video.currentTime = newTime;
                }
                progressBarFilled.style.width = (pos * 100) + '%';
                progressHandle.style.left = (pos * 100) + '%';

                const miniProgressFill = document.getElementById('miniProgressFill');
                if (miniProgressFill && !videoContainer.classList.contains('fullscreen')) {
                    miniProgressFill.style.width = (pos * 100) + '%';
                }
                if (!isNaN(video.currentTime) && !isNaN(video.duration)) {
                    timeDisplay.textContent = `${formatDuration(video.currentTime)} / ${formatDuration(video.duration)}`;
                }
            }

            function onMouseMoveScrub(e) {
                if (!isScrubbing) return;
                seekFromClientX(e.clientX);
            }

            function onTouchMoveScrub(e) {
                if (!isScrubbing || e.touches.length === 0) return;
                seekFromClientX(e.touches[0].clientX);
            }

            function onMouseUpScrub() {
                if (!isScrubbing) return;
                isScrubbing = false;
                document.removeEventListener('mousemove', onMouseMoveScrub);
                document.removeEventListener('mouseup', onMouseUpScrub);
                document.removeEventListener('touchmove', onTouchMoveScrub);
                document.removeEventListener('touchend', onTouchUpScrub);
                video.play();
            }

            function onTouchUpScrub() {
                if (!isScrubbing) return;
                isScrubbing = false;
                document.removeEventListener('mousemove', onMouseMoveScrub);
                document.removeEventListener('mouseup', onMouseUpScrub);
                document.removeEventListener('touchmove', onTouchMoveScrub);
                document.removeEventListener('touchend', onTouchUpScrub);
                video.play();
            }

            function startDrag(e) {
                e.preventDefault();
                isScrubbing = true;
                video.pause();
                const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                seekFromClientX(clientX);
                document.addEventListener('mousemove', onMouseMoveScrub);
                document.addEventListener('mouseup', onMouseUpScrub);
                document.addEventListener('touchmove', onTouchMoveScrub, { passive: false });
                document.addEventListener('touchend', onTouchUpScrub);
            }

            if (progressHandle) {
                progressHandle.addEventListener('mousedown', startDrag);
                progressHandle.addEventListener('touchstart', startDrag, { passive: false });
            }
            progressBar.addEventListener('mousedown', (e) => {
                if (e.target === progressHandle) return;
                startDrag(e);
            });
            progressBar.addEventListener('touchstart', (e) => {
                if (e.target === progressHandle) return;
                startDrag(e);
            }, { passive: false });

            function getChapterAtTime(timeInSeconds) {
                if (!window.currentChapters || !Array.isArray(window.currentChapters)) return null;

                for (let i = 0; i < window.currentChapters.length; i++) {
                    const chapter = window.currentChapters[i];
                    const nextChapter = window.currentChapters[i + 1];

                    if (timeInSeconds >= chapter.time && (!nextChapter || timeInSeconds < nextChapter.time)) {
                        return chapter;
                    }
                }
                return null;
            }

            function updatePreviewPosition(clientX) {
                if (!progressPreview || !video.duration) return;
                const rect = progressBar.getBoundingClientRect();
                const clampedX = Math.max(rect.left, Math.min(rect.right, clientX));
                const pos = (clampedX - rect.left) / rect.width;
                const px = pos * rect.width;
                progressPreview.style.left = `${px}px`;
                const targetTime = pos * (video.duration || 0);
                if (!Number.isFinite(targetTime)) return;
                previewTime.textContent = formatDuration(targetTime);

                const currentChapter = getChapterAtTime(targetTime);
                if (currentChapter) {
                    let chapterElement = progressPreview.querySelector('.preview-chapter');
                    if (!chapterElement) {
                        chapterElement = document.createElement('div');
                        chapterElement.className = 'preview-chapter';
                        chapterElement.style.cssText = 'font-size: 10px; color: #ff69b4; margin-top: 2px; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 160px;';
                        progressPreview.appendChild(chapterElement);
                    }
                    chapterElement.textContent = currentChapter.title;
                } else {
                    const chapterElement = progressPreview.querySelector('.preview-chapter');
                    if (chapterElement) {
                        chapterElement.remove();
                    }
                }

                const now = performance.now();
                const previewInterval = isMobile || isLowEndDevice ? 500 : 300;
                if (now - lastPreviewTs < previewInterval || previewSeekScheduled) return;
                lastPreviewTs = now;
                previewSeekScheduled = true;

                if (!offscreenVideo) {
                    offscreenVideo = document.createElement('video');
                    offscreenVideo.muted = true;
                    offscreenVideo.preload = 'metadata';
                }
                if (offscreenVideo.src !== video.src) {
                    try {
                        if (pctx) pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        if (progressPreview) progressPreview.style.display = 'none';
                    } catch (_) { }
                    offscreenVideo.src = video.src;
                    offscreenVideo.onloadedmetadata = () => {
                        if (progressPreview) progressPreview.style.display = 'block';
                    };
                    previewSeekScheduled = false;
                    return;
                }
                if (offscreenVideo.readyState < 2) {
                    offscreenVideo.onloadeddata = () => { updatePreviewPosition(clientX); };
                    previewSeekScheduled = false;
                    return;
                }
                offscreenVideo.onseeked = () => {
                    previewSeekScheduled = false;
                    if (!pctx) return;
                    const vw = offscreenVideo.videoWidth || 160;
                    const vh = offscreenVideo.videoHeight || 90;
                    const ar = vw / vh;
                    let cw = previewCanvas.width, ch = previewCanvas.height;
                    if (cw / ch > ar) {
                        cw = ch * ar;
                    } else {
                        ch = cw / ar;
                    }
                    pctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                    pctx.drawImage(offscreenVideo, (previewCanvas.width - cw) / 2, (previewCanvas.height - ch) / 2, cw, ch);
                };
                if (Number.isFinite(targetTime)) {
                    offscreenVideo.currentTime = targetTime;
                }
            }

            progressBar.addEventListener('mousemove', (e) => {
                if (!isScrubbing) {
                    progressPreview.style.display = 'block';
                    updatePreviewPosition(e.clientX);
                }
            });

            progressBar.addEventListener('mouseleave', () => {
                if (progressPreview) progressPreview.style.display = 'none';
            });

            volumeBtn.addEventListener('click', () => {
                video.muted = !video.muted;
                updateVolumeIcon();
                showVolumeHUD(video.volume * 100);
            });




            let videoZoomLevel = 1;
            let videoPanX = 0;
            let videoPanY = 0;
            let zoomHudTimerVideo = null;

            function applyVideoTransform() {
                const v = document.getElementById('video');
                if (!v) return;
                v.style.transformOrigin = 'center center';
                v.style.transform = `scale(${videoZoomLevel}) translate(${videoPanX}px, ${videoPanY}px)`;
            }

            function showVideoZoomHUD(level) {
                const container = document.getElementById('videoContainer');
                if (!container) return;
                let hud = document.getElementById('zoomHudVideo');
                if (!hud) {
                    hud = document.createElement('div');
                    hud.id = 'zoomHudVideo';
                    hud.style.position = 'absolute';
                    hud.style.top = '15px';
                    hud.style.left = '50%';
                    hud.style.transform = 'translateX(-50%)';
                    hud.style.padding = '6px 12px';
                    hud.style.borderRadius = '8px';
                    hud.style.background = 'rgba(0,0,0,0.8)';
                    hud.style.color = '#fff';
                    hud.style.fontWeight = '700';
                    hud.style.fontSize = '14px';
                    hud.style.zIndex = '30';
                    hud.style.pointerEvents = 'none';
                    hud.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                    container.appendChild(hud);
                }
                hud.innerHTML = `: ${Math.round(level * 100)}%`;
                hud.style.display = 'block';
                if (zoomHudTimerVideo) clearTimeout(zoomHudTimerVideo);
                zoomHudTimerVideo = setTimeout(() => {
                    const h = document.getElementById('zoomHudVideo');
                    if (h) h.style.display = 'none';
                }, 1500);
            }

            function increaseVideoZoom(delta = 0.1) {
                videoZoomLevel = Math.min(3.0, videoZoomLevel + delta);
                applyVideoTransform();
                showVideoZoomHUD(videoZoomLevel);
            }

            function decreaseVideoZoom(delta = 0.1) {
                videoZoomLevel = Math.max(0.1, videoZoomLevel - delta);
                applyVideoTransform();
                showVideoZoomHUD(videoZoomLevel);
            }

            function resetVideoZoom() {
                videoZoomLevel = 1;
                videoPanX = 0;
                videoPanY = 0;
                applyVideoTransform();
                showVideoZoomHUD(videoZoomLevel);
            }

            function panVideo(direction) {
                const step = 20;
                switch (direction) {
                    case 'up': videoPanY -= step; break;
                    case 'down': videoPanY += step; break;
                    case 'left': videoPanX -= step; break;
                    case 'right': videoPanX += step; break;
                }
                applyVideoTransform();
                showVideoZoomHUD(videoZoomLevel);
            }

            function toggleCinemaMode() {
                const body = document.body;
                const cinemaModeBtn = document.getElementById('cinemaModeBtn');

                if (body.classList.contains('cinema-mode')) {
                    if (window.DanmakuScrollSync) {
                        window.DanmakuScrollSync.savePanelScrollPosition();
                    }
                    
                    body.classList.remove('cinema-mode');
                    body.classList.remove('sidebar-open');
                    
                    const isWidescreen = body.classList.contains('wide-screen-mode');
                    const isFullscreen = document.fullscreenElement;
                    if (!isWidescreen && !isFullscreen) {
                        const danmakuPanelOverlay = document.getElementById('danmakuPanelOverlay');
                        const danmakuPanelBtn = document.getElementById('danmakuPanelBtn');
                        if (danmakuPanelOverlay) {
                            danmakuPanelOverlay.classList.remove('open');
                            danmakuPanelOverlay.classList.remove('expanded');
                        }
                        if (danmakuPanelBtn) {
                            danmakuPanelBtn.classList.remove('active');
                        }
                        
                        const danmakuContent = document.getElementById('danmakuTabContent');
                        if (window.DanmakuScrollSync && danmakuContent) {
                            window.DanmakuScrollSync.syncSidebarScrollPosition(danmakuContent);
                        }
                    }
                    
                    if (window.__cinemaMeasureHandler) {
                        try { window.removeEventListener('resize', window.__cinemaMeasureHandler); } catch (_) { }
                        window.__cinemaMeasureHandler = null;
                    }

                    body.classList.add('no-sidebar-transitions');

                    const sidebarCollapsed = localStorage.getItem('sidebarCollapsed');
                    const currentlyCollapsed = body.classList.contains('sidebar-collapsed');

                    if (sidebarCollapsed === 'true' && !currentlyCollapsed) {
                        body.classList.add('sidebar-collapsed');
                    } else if (sidebarCollapsed !== 'true' && currentlyCollapsed) {
                        body.classList.remove('sidebar-collapsed');
                    }

                    setTimeout(() => {
                        body.classList.remove('no-sidebar-transitions');
                    }, 50);
                    if (cinemaModeBtn) {
                        cinemaModeBtn.classList.remove('active');
                    }
                    try { document.body.style.removeProperty('--cin-form-height'); } catch (_) { }
                    
                    setTimeout(() => {
                        window.dispatchEvent(new Event('resize'));
                    }, 100);
                } else {
                    if (window.DanmakuScrollSync) {
                        window.DanmakuScrollSync.saveSidebarScrollPosition();
                    }
                    
                    body.classList.add('cinema-mode-entering');
                    void body.offsetHeight;
                    body.classList.add('cinema-mode');
                    body.classList.remove('sidebar-open');
                    setTimeout(() => {
                        body.classList.remove('cinema-mode-entering');
                    }, 100);
                    if (cinemaModeBtn) {
                        cinemaModeBtn.classList.add('active');
                    }
                    window.scrollTo({ top: 0, behavior: 'smooth' });

                    setTimeout(() => {
                        try {
                            const form = document.querySelector('#danmakuContent .danmaku-form');
                            const h = form ? Math.ceil(form.getBoundingClientRect().height) : 0;
                            document.body.style.setProperty('--cin-form-height', (h || 48) + 'px');
                        } catch (_) { }
                    }, 0);
                    const onResizeMeasure = () => {
                        try {
                            const form = document.querySelector('#danmakuContent .danmaku-form');
                            const h = form ? Math.ceil(form.getBoundingClientRect().height) : 0;
                            document.body.style.setProperty('--cin-form-height', (h || 48) + 'px');
                        } catch (_) { }
                    };
                    window.addEventListener('resize', onResizeMeasure, { passive: true });
                    window.__cinemaMeasureHandler = onResizeMeasure;
                }
            }

            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                const seekTime = 10;
                const volumeStep = 0.05;

                let seekHudEl = null;
                let seekHudTimerId = null;
                function showSeekHUD(direction , seconds) {
                    const container = document.getElementById('videoContainer');
                    if (!container) return;
                    try {
                        document.querySelectorAll('.seek-hud-wrapper').forEach(n => n.remove());
                    } catch (_) { }
                    if (!seekHudEl) {
                        seekHudEl = document.createElement('div');
                        seekHudEl.className = 'seek-hud-wrapper';
                        seekHudEl.style.position = 'absolute';
                        seekHudEl.style.top = '50%';
                        seekHudEl.style.transform = 'translateY(-50%)';
                        seekHudEl.style.zIndex = '50';
                        seekHudEl.style.display = 'flex';
                        seekHudEl.style.flexDirection = 'column';
                        seekHudEl.style.alignItems = 'center';
                        seekHudEl.style.pointerEvents = 'none';
                        seekHudEl.style.transition = 'opacity 120ms ease';
                        seekHudEl.style.opacity = '0';
                        const circle = document.createElement('div');
                        circle.style.width = '56px';
                        circle.style.height = '56px';
                        circle.style.borderRadius = '50%';
                        circle.style.background = 'rgba(0,0,0,0.7)';
                        circle.style.display = 'flex';
                        circle.style.flexDirection = 'column';
                        circle.style.alignItems = 'center';
                        circle.style.justifyContent = 'center';
                        circle.style.color = '#fff';
                        circle.style.fontSize = '12px';
                        circle.style.fontWeight = '700';
                        circle.style.textAlign = 'center';
                        circle.style.lineHeight = '1.1';
                        circle.style.boxShadow = 'none';
                        circle.className = 'seek-hud-circle';

                        seekHudEl.appendChild(circle);
                        container.appendChild(seekHudEl);
                    }

                    seekHudEl.style.left = direction === 'left' ? '8%' : '';
                    seekHudEl.style.right = direction === 'right' ? '8%' : '';

                    const circle = seekHudEl.querySelector('.seek-hud-circle');
                    if (circle) {
                        const arrow = direction === 'left' ? '' : '';
                        circle.innerHTML = `<div style="font-size:14px;">${seconds} </div><div style="font-size:16px; margin-top:2px;">${arrow}</div>`;
                    }

                    seekHudEl.style.display = 'flex';
                    void seekHudEl.offsetWidth;
                    seekHudEl.style.opacity = '1';

                    if (seekHudTimerId) clearTimeout(seekHudTimerId);
                    seekHudTimerId = setTimeout(() => {
                        if (seekHudEl) {
                            seekHudEl.style.opacity = '0';
                            setTimeout(() => { if (seekHudEl) seekHudEl.style.display = 'none'; }, 120);
                        }
                    }, 250);
                }

                if (e.code === 'KeyP') {
                    e.preventDefault();
                    increaseVideoZoom();
                } else if (e.code === 'KeyO') {
                    e.preventDefault();
                    decreaseVideoZoom();
                } else if (e.shiftKey && e.code === 'KeyW') {
                    e.preventDefault();
                    panVideo('up');
                } else if (e.shiftKey && e.code === 'KeyS') {
                    e.preventDefault();
                    panVideo('down');
                } else if (e.shiftKey && e.code === 'KeyA') {
                    e.preventDefault();
                    panVideo('left');
                } else if (e.shiftKey && e.code === 'KeyD') {
                    e.preventDefault();
                    panVideo('right');
                } else if (e.shiftKey && e.code === 'KeyI') {
                    e.preventDefault();
                    resetVideoZoom();
                } else if (e.code === 'KeyQ') {
                    e.preventDefault();
                    if (typeof togglePictureInPicture === 'function') togglePictureInPicture();
                } else if (e.code === 'KeyJ') {
                    e.preventDefault();
                    video.currentTime = Math.max(0, video.currentTime - seekTime);
                    showSeekHUD('left', 10);
                } else if (e.code === 'KeyL') {
                    e.preventDefault();
                    video.currentTime = Math.min(video.duration, video.currentTime + seekTime);
                    showSeekHUD('right', 10);
                } else if (e.code === 'KeyV') {
                    e.preventDefault();
                    logoEnabled = !logoEnabled;
                    localStorage.setItem("video_logo_enabled", logoEnabled);
                    updateLogoButtonText();
                    updateLogoVisibility();
                    if (typeof updateTabValues === 'function') updateTabValues();
                } else if (e.shiftKey && e.code === 'KeyC') {
                    const isWidescreen = document.body.classList.contains('wide-screen-mode');
                    const isCinema = document.body.classList.contains('cinema-mode');
                    const isFullscreen = document.fullscreenElement;
                    if (isWidescreen || isCinema || isFullscreen) {
                        e.preventDefault();
                        const panelBtn = document.getElementById('danmakuPanelBtn');
                        if (panelBtn) {
                            panelBtn.click();
                        }
                    }
                } else if (e.code === 'KeyH') {
                    e.preventDefault();
                    clockEnabled = !clockEnabled;
                    localStorage.setItem("video_clock_enabled", clockEnabled);
                    updateClockButtonText();
                    if (typeof updateTabValues === 'function') updateTabValues();
                    updateClockVisibility();
                } else if (e.code === 'KeyC') {
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        return;
                    }
                    e.preventDefault();
                    if (typeof window.toggleSubtitles === 'function') {
                        window.toggleSubtitles();
                    }
                } else if (e.code === 'KeyA') {
                    e.preventDefault();
                    autoplayEnabled = !autoplayEnabled;
                    localStorage.setItem("autoplayEnabled", autoplayEnabled);
                    updateAutoplayButtonText();
                } else if (e.code === 'Space' || e.code === 'KeyK') {
                    e.preventDefault();
                    if (video.paused || video.ended) {
                        const overlay = document.getElementById('videoOverlay');
                        if (overlay) {
                            overlay.style.opacity = '0';
                            setTimeout(() => overlay.style.display = 'none', 300);
                        }
                        video.play();
                        showControls();
                    } else {
                        video.pause();
                        showControls();
                    }
                } else if (e.code === 'KeyF') {
                    if (document.body.classList.contains('error-state')) {
                        e.preventDefault();
                        return;
                    }
                    if (e.ctrlKey || e.metaKey) {
                        return;
                    }
                    e.preventDefault();
                    showControls();
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else if (videoContainer.requestFullscreen) {
                        if (window.DanmakuScrollSync) {
                            window.DanmakuScrollSync.saveSidebarScrollPosition();
                        }
                        videoContainer.requestFullscreen();
                    } else if (videoContainer.webkitRequestFullscreen) { 
                        videoContainer.webkitRequestFullscreen();
                    } else if (videoContainer.msRequestFullscreen) { 
                        videoContainer.msFullscreenElement();
                    }
                } else if (e.code === 'KeyT') {
                    if (document.body.classList.contains('error-state')) {
                        e.preventDefault();
                        return;
                    }
                    e.preventDefault();
                    toggleCinemaMode();
                } else if (e.code === 'ArrowLeft') {
                    e.preventDefault();
                    video.currentTime = Math.max(0, video.currentTime - 5);
                    showSeekHUD('left', 5);
                } else if (e.code === 'ArrowRight') {
                    e.preventDefault();
                    video.currentTime = Math.min(video.duration, video.currentTime + 5);
                    showSeekHUD('right', 5);
                } else if (e.code === 'ArrowUp') {
                    e.preventDefault();
                    const newVolumePercent = Math.min(100, (video.volume * 100) + (volumeStep * 100));
                    applyVolume(newVolumePercent);
                    showVolumeHUD(newVolumePercent);
                } else if (e.code === 'ArrowDown') {
                    e.preventDefault();
                    const newVolumePercent = Math.max(0, (video.volume * 100) - (volumeStep * 100));
                    applyVolume(newVolumePercent);
                    showVolumeHUD(newVolumePercent);
                } else if (((e.code === 'Equal' && e.shiftKey) || e.code === 'NumpadAdd')) {
                    e.preventDefault();
                    increaseSpeed();
                    allowSpeedHUD = true;
                    if (typeof showSpeedHUDKeyboard === 'function') {
                        showSpeedHUDKeyboard(video.playbackRate || 1);
                    }
                    setTimeout(() => { if (speedHud) speedHud.style.display = 'none'; allowSpeedHUD = false; }, 1000);
                    showControls();
                    const hideOnUp = (upEvent) => {
                        if (upEvent.code === e.code) {
                            if (speedHud) speedHud.style.display = 'none';
                            document.removeEventListener('keyup', hideOnUp);
                        }
                    };
                    const hideOnShiftUp = (upEvent) => {
                        if (upEvent.code === 'ShiftLeft' || upEvent.code === 'ShiftRight') {
                            if (speedHud) speedHud.style.display = 'none';
                            document.removeEventListener('keyup', hideOnShiftUp);
                        }
                    };
                    document.addEventListener('keyup', hideOnUp);
                    document.addEventListener('keyup', hideOnShiftUp);
                } else if (((e.code === 'Minus' && e.shiftKey) || e.code === 'NumpadSubtract')) {
                    e.preventDefault();
                    decreaseSpeed();
                    allowSpeedHUD = true;
                    if (typeof showSpeedHUDKeyboard === 'function') {
                        showSpeedHUDKeyboard(video.playbackRate || 1);
                    }
                    setTimeout(() => { if (speedHud) speedHud.style.display = 'none'; allowSpeedHUD = false; }, 1000);
                    showControls();
                    const hideOnUp = (upEvent) => {
                        if (upEvent.code === e.code) {
                            if (speedHud) speedHud.style.display = 'none';
                            document.removeEventListener('keyup', hideOnUp);
                        }
                    };
                    const hideOnShiftUp = (upEvent) => {
                        if (upEvent.code === 'ShiftLeft' || upEvent.code === 'ShiftRight') {
                            if (speedHud) speedHud.style.display = 'none';
                            document.removeEventListener('keyup', hideOnShiftUp);
                        }
                    };
                    document.addEventListener('keyup', hideOnUp);
                    document.addEventListener('keyup', hideOnShiftUp);
                } else if (e.code === 'KeyM') {
                    e.preventDefault();
                    if (video.muted || video.volume === 0) {
                        video.muted = false;
                        applyVolume(lastVolume * 100);
                    } else {
                        lastVolume = video.volume > 0 ? video.volume : 1;
                        video.muted = true;
                        applyVolume(0);
                    }
                    showVolumeHUD(video.volume * 100);
                } else if (e.code >= 'Digit0' && e.code <= 'Digit9') {
                    e.preventDefault();
                    const percentage = parseInt(e.code.replace('Digit', '')) * 10;
                    if (video.duration && video.duration > 0) {
                        video.currentTime = (video.duration * percentage) / 100;
                    }
                }
            });
            (() => {
                let speedBadge = null;
                let suppressNextClick = false;
                let speedLocked = false;
                window.videoSpeedLocked = false;

                const container = document.getElementById('videoContainer');
                if (!container) return;

                function showSpeedBadge() {
                    if (speedBadge) return;
                    speedBadge = document.createElement('div');
                    speedBadge.className = 'speed-hud';
                    speedBadge.innerHTML = `
                  <div style="font-size:18px;margin-bottom:3px;">>>2x</div>
                `;
                    container.appendChild(speedBadge);
                }

                function showSpeedHUD(rate) {
                    if (!speedHud) {
                        speedHud = document.createElement('div');
                        speedHud.className = 'speed-hud';
                        container.appendChild(speedHud);
                    }

                    speedHud.innerHTML = `
                  <div style="font-size:16px;margin-bottom:3px;">: ${rate}x</div>
                `;
                    speedHud.style.display = 'block';
                }

                function hideSpeedBadge() {
                    if (speedBadge && speedBadge.parentNode) {
                        speedBadge.parentNode.removeChild(speedBadge);
                    }
                    speedBadge = null;
                }
                function hideSpeedHUD() {
                    if (speedHud) speedHud.style.display = 'none';
                }


                let holdTimer = null;
                window.videoSpeedHoldTimer = null;
                window.videoSpeedHolding = false;
                let isHolding = false;

                container.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;

                    if (e.target.closest('.volume-slider') || e.target.closest('.volume-container')) {
                        return;
                    }


                    isHolding = true;

                    holdTimer = setTimeout(() => {
                        if (isHolding) {
                            window.videoSpeedHolding = true;
                            video.playbackRate = 2;
                            speedLocked = true;
                            window.videoSpeedLocked = true;
                            showSpeedBadge();
                            showSpeedHUD(2);
                            suppressNextClick = true;
                        }
                    }, 300);
                    window.videoSpeedHoldTimer = holdTimer;
                });

                container.addEventListener('mouseup', (e) => {
                    if (e.button !== 0) return;

                    if (holdTimer) {
                        clearTimeout(holdTimer);
                        holdTimer = null;
                    }

                    if (speedLocked && isHolding) {
                        speedLocked = false;
                        window.videoSpeedLocked = false;
                        video.playbackRate = baseRate || 1;
                        hideSpeedBadge();
                        hideSpeedHUD();
                        allowSpeedHUD = false;
                        suppressNextClick = true;
                    }

                    isHolding = false;
                    window.videoSpeedHolding = false;
                });

                container.addEventListener('mouseleave', (e) => {
                    if (holdTimer) {
                        clearTimeout(holdTimer);
                        holdTimer = null;
                    }

                    if (speedLocked && isHolding) {
                        speedLocked = false;
                        window.videoSpeedLocked = false;
                        video.playbackRate = baseRate || 1;
                        hideSpeedBadge();
                        hideSpeedHUD();
                        allowSpeedHUD = false;
                        suppressNextClick = true;
                    }

                    isHolding = false;
                    window.videoSpeedHolding = false;
                });


                let touchHoldTimer = null;
                let touchHolding = false;
                let touchStartTime = 0;

                container.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        //   preventDefault()  -   !
                        touchHolding = true;
                        touchStartTime = Date.now();

                        touchHoldTimer = setTimeout(() => {
                            if (touchHolding) {
                                //     -  
                                video.playbackRate = 2;
                                speedLocked = true;
                                window.videoSpeedLocked = true;
                                showSpeedBadge();
                                showSpeedHUD(2);
                                suppressNextClick = true;
                            }
                        }, 300);
                    }
                }, { passive: true });

                document.addEventListener('touchend', (e) => {
                    if (e.changedTouches.length === 1 && touchHolding) {
                        if (touchHoldTimer) {
                            clearTimeout(touchHoldTimer);
                            touchHoldTimer = null;
                        }

                        if (speedLocked && touchHolding) {
                            speedLocked = false;
                            window.videoSpeedLocked = false;
                            video.playbackRate = baseRate || 1;
                            hideSpeedBadge();
                            hideSpeedHUD();
                            allowSpeedHUD = false;
                            suppressNextClick = true;
                        }

                        touchHolding = false;
                    }
                });

                document.addEventListener('touchcancel', (e) => {
                    if (touchHolding) {
                        touchHolding = false;
                        if (touchHoldTimer) {
                            clearTimeout(touchHoldTimer);
                            touchHoldTimer = null;
                        }
                        if (speedLocked) {
                            speedLocked = false;
                            window.videoSpeedLocked = false;
                            video.playbackRate = baseRate || 1;
                            hideSpeedBadge();
                            hideSpeedHUD();
                            allowSpeedHUD = false;
                        }
                    }
                });

                video.addEventListener('click', (e) => {
                    if (suppressNextClick) {
                        e.stopPropagation();
                        e.preventDefault();
                        suppressNextClick = false;
                    }
                }, true);

                let suppressResetTimer = null;
                const resetSuppressNextClick = () => {
                    if (suppressResetTimer) clearTimeout(suppressResetTimer);
                    suppressResetTimer = setTimeout(() => {
                        suppressNextClick = false;
                    }, 500);
                };

                document.addEventListener('touchend', resetSuppressNextClick);
                document.addEventListener('mouseup', resetSuppressNextClick);
            })();

            const videoContainerForLMB = document.getElementById('videoContainer');
            videoContainerForLMB.addEventListener('wheel', (e) => {
                if (!document.fullscreenElement) return;
                e.preventDefault();
                const delta = e.deltaY;
                const step = 0.05;
                let newVol = video.volume + (delta < 0 ? step : -step);
                newVol = Math.max(0, Math.min(1, newVol));
                applyVolume(newVol * 100);
                showVolumeHUD(newVol * 100);
            }, { passive: false });

            const toggleLogoBtn = document.getElementById('toggleLogoBtn');
            const toggleClockBtn = document.getElementById('toggleClockBtn');
            const videoLogo = document.getElementById('videoLogo');
            const videoClock = document.getElementById('videoClock');

            let autoplayEnabled = localStorage.getItem('autoplayEnabled') !== 'false';

            const autoplayToggleText = null;
            const autoplayToggleBtn = null;

            function updateAutoplayToggleUI() {
                if (autoplayToggleText && autoplayToggleBtn) {
                    autoplayToggleText.textContent = autoplayEnabled ? i18n.t('playerSettings.autoplayOn', 'Autoplay on') : i18n.t('playerSettings.autoplayOff', 'Autoplay off');
                    autoplayToggleBtn.textContent = autoplayEnabled ? i18n.t('playerSettings.disableAutoplay', 'Disable autoplay') : i18n.t('playerSettings.enableAutoplay', 'Enable autoplay');
                }
            }

            updateAutoplayToggleUI();


            const sidebarAutoplayToggle = document.getElementById('autoplayToggle');
            const sidebarAutoplayToggleBtn = document.getElementById('autoplayToggleBtn');

            updateSidebarAutoplayStatus();

            function updateSidebarAutoplayStatus() {
                const statusElement = document.getElementById('autoplayStatus');
                const toggleElement = document.getElementById('autoplayToggle');
                if (statusElement) {
                    statusElement.textContent = autoplayEnabled ? i18n.t('playerSettings.on', 'On') : i18n.t('playerSettings.off', 'Off');
                }
                if (toggleElement) {
                    if (autoplayEnabled) {
                        toggleElement.classList.add('active');
                    } else {
                        toggleElement.classList.remove('active');
                    }
                }
            }


            if (sidebarAutoplayToggle) {
                sidebarAutoplayToggle.addEventListener('click', () => {
                    autoplayEnabled = !autoplayEnabled;
                    localStorage.setItem('autoplayEnabled', autoplayEnabled);
                    updateAutoplayToggleUI();
                    updateSidebarAutoplayStatus();
                    if (typeof updateAutoplayButtonText === 'function') {
                        updateAutoplayButtonText();
                    }
                });
            }

            function updateActiveSpeedButtons() {
                document.querySelectorAll('.settings-option[data-speed]').forEach(b => {
                    const s = parseFloat(b.dataset.speed);
                    if (Math.abs(s - (video.playbackRate || 1)) < 0.001) b.classList.add('active');
                    else b.classList.remove('active');
                });
                baseRate = video.playbackRate || 1;

                const speedSlider = document.getElementById('speedSlider');
                const speedSliderValue = document.getElementById('speedSliderValue');
                if (speedSlider && speedSliderValue) {
                    const currentRate = video.playbackRate || 1;
                    speedSlider.value = currentRate;
                    speedSliderValue.textContent = currentRate.toFixed(2);
                    const percentage = ((currentRate - 0.25) / (3 - 0.25)) * 100;
                    speedSlider.style.setProperty('--speedPos', percentage + '%');
                }
            }

            function showSpeedHUD(rate) {
                if (!allowSpeedHUD) return;
                if (!speedHud) return;
                speedHud.innerHTML = `
                <div style="font-size:16px;margin-bottom:3px;">: ${rate}x</div>
              `;
                speedHud.style.display = 'block';
            }

            function showSpeedHUDKeyboard(rate) {
                if (!allowSpeedHUD) return;
                if (!speedHud) {
                    const container = document.getElementById('videoContainer');
                    if (!container) return;
                    speedHud = document.createElement('div');
                    speedHud.className = 'speed-hud';
                    container.appendChild(speedHud);
                }
                speedHud.innerHTML = `
                <div style="font-size:16px;margin-bottom:3px;">: ${rate}x</div>
                <div style="font-size:11px;opacity:0.8;">Shift +/-   </div>
              `;
                speedHud.style.display = 'block';
            }

            function increaseSpeed() {
                let idx = availableSpeeds.findIndex(s => Math.abs(s - (video.playbackRate || 1)) < 0.001);
                if (idx === -1) idx = availableSpeeds.indexOf(1);
                if (idx < availableSpeeds.length - 1) {
                    const newRate = availableSpeeds[idx + 1];
                    video.playbackRate = newRate;
                    updateActiveSpeedButtons();
                    baseRate = newRate;
                    if (typeof updateTabValues === 'function') updateTabValues();
                }
            }

            function decreaseSpeed() {
                let idx = availableSpeeds.findIndex(s => Math.abs(s - (video.playbackRate || 1)) < 0.001);
                if (idx === -1) idx = availableSpeeds.indexOf(1);
                if (idx > 0) {
                    const newRate = availableSpeeds[idx - 1];
                    video.playbackRate = newRate;
                    updateActiveSpeedButtons();
                    baseRate = newRate;
                    if (typeof updateTabValues === 'function') updateTabValues();
                }
            }

            document.querySelectorAll('.settings-option[data-speed]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const speed = parseFloat(btn.dataset.speed);
                    video.playbackRate = speed;
                    updateActiveSpeedButtons();
                    baseRate = speed;
                    updateTabValues();
                });
            });

            const speedSlider = document.getElementById('speedSlider');
            const speedSliderValue = document.getElementById('speedSliderValue');
            if (speedSlider) {
                speedSlider.addEventListener('input', (e) => {
                    e.stopPropagation();
                    const speed = parseFloat(e.target.value);
                    video.playbackRate = speed;
                    baseRate = speed;
                    speedSliderValue.textContent = speed.toFixed(2);
                    updateActiveSpeedButtons();
                    updateTabValues();
                    localStorage.setItem('video_playback_speed', speed);
                    allowSpeedHUD = false;
                    if (speedHud) speedHud.style.display = 'none';
                    const percentage = ((speed - 0.25) / (3 - 0.25)) * 100;
                    speedSlider.style.setProperty('--speedPos', percentage + '%');
                });

                speedSlider.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    allowSpeedHUD = false;
                    if (speedHud) speedHud.style.display = 'none';
                });

                speedSlider.addEventListener('mouseup', (e) => {
                    e.stopPropagation();
                });

                const savedSpeed = localStorage.getItem('video_playback_speed');
                if (savedSpeed) {
                    const speed = parseFloat(savedSpeed);
                    if (speed >= 0.25 && speed <= 3) {
                        speedSlider.value = speed;
                        speedSliderValue.textContent = speed.toFixed(2);
                        const percentage = ((speed - 0.25) / (3 - 0.25)) * 100;
                        speedSlider.style.setProperty('--speedPos', percentage + '%');
                    }
                } else {
                    speedSliderValue.textContent = (parseFloat(speedSlider.value) || 1).toFixed(2);
                    const defaultPercentage = ((1 - 0.25) / (3 - 0.25)) * 100;
                    speedSlider.style.setProperty('--speedPos', defaultPercentage + '%');
                }
            }

            video.addEventListener('loadedmetadata', updateActiveSpeedButtons);

            const logoTabValue = document.getElementById('logoTabValue');
            const clockTabValue = document.getElementById('clockTabValue');
            const speedTabValue = document.getElementById('speedTabValue');

            function updateTabValues() {
                if (logoTabValue) logoTabValue.textContent = logoEnabled ? i18n.t('playerSettings.on', 'On') : i18n.t('playerSettings.off', 'Off');
                if (clockTabValue) clockTabValue.textContent = clockEnabled ? i18n.t('playerSettings.on', 'On') : i18n.t('playerSettings.off', 'Off');
                if (speedTabValue) speedTabValue.textContent = video.playbackRate === 1 ? "1x" : video.playbackRate + "x";
                const dragSeekTabValue = document.getElementById('dragSeekTabValue');
                if (dragSeekTabValue) dragSeekTabValue.textContent = dragSeekEnabled ? i18n.t('playerSettings.on', 'On') : i18n.t('playerSettings.off', 'Off');
            }

            settingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                const audioTracksMenu = document.getElementById('audioTracksMenu');
                if (audioTracksMenu) {
                    audioTracksMenu.classList.remove('show');
                }

                showMainMenu();
                updateTabValues();
                settingsMenu.classList.toggle('show');
            });

            function showMainMenu() {
                const mainMenu = document.getElementById('settingsMainMenu');
                const logoSettings = document.getElementById('logoSettingsSubMenu');
                const clockSettings = document.getElementById('clockSettingsSubMenu');
                const speedSettings = document.getElementById('speedSettingsSubMenu');
                const dragseekSettings = document.getElementById('dragseekSettingsSubMenu');

                if (mainMenu) mainMenu.style.display = 'flex';
                if (logoSettings) {
                    logoSettings.style.display = 'none';
                    logoSettings.style.position = 'absolute';
                }
                if (clockSettings) {
                    clockSettings.style.display = 'none';
                    clockSettings.style.position = 'absolute';
                }
                if (speedSettings) {
                    speedSettings.style.display = 'none';
                    speedSettings.style.position = 'absolute';
                }
                if (dragseekSettings) {
                    dragseekSettings.style.display = 'none';
                    dragseekSettings.style.position = 'absolute';
                }
            }

            showMainMenu();

            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const tabType = tab.dataset.tab;

                    const mainMenu = document.getElementById('settingsMainMenu');
                    const logoSettings = document.getElementById('logoSettingsSubMenu');
                    const clockSettings = document.getElementById('clockSettingsSubMenu');
                    const speedSettings = document.getElementById('speedSettingsSubMenu');
                    const dragseekSettings = document.getElementById('dragseekSettingsSubMenu');

                    if (mainMenu) mainMenu.style.display = 'none';

                    const mainMenuHeight = mainMenu ? mainMenu.offsetHeight : 0;

                    if (tabType === 'logo' && logoSettings) {
                        logoSettings.style.display = 'flex';
                        logoSettings.style.position = 'static';
                        logoSettings.style.minHeight = mainMenuHeight + 'px';
                    } else if (tabType === 'clock' && clockSettings) {
                        clockSettings.style.display = 'flex';
                        clockSettings.style.position = 'static';
                        clockSettings.style.minHeight = mainMenuHeight + 'px';
                    } else if (tabType === 'speed' && speedSettings) {
                        speedSettings.style.display = 'flex';
                        speedSettings.style.position = 'static';
                        speedSettings.style.minHeight = mainMenuHeight + 'px';
                    } else if (tabType === 'dragseek' && dragseekSettings) {
                        dragseekSettings.style.display = 'flex';
                        dragseekSettings.style.position = 'static';
                        dragseekSettings.style.minHeight = mainMenuHeight + 'px';
                    }
                });
            });

            const logoBackBtn = document.getElementById('logoBackBtn');
            const clockBackBtn = document.getElementById('clockBackBtn');
            const speedBackBtn = document.getElementById('speedBackBtn');
            const dragseekBackBtn = document.getElementById('dragseekBackBtn');

            if (logoBackBtn) {
                logoBackBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const sub = document.getElementById('logoSettingsSubMenu');
                    if (sub) {
                        sub.classList.remove('slide-out');
                        void sub.offsetWidth;
                        sub.classList.add('slide-out');
                        const onEnd = () => {
                            sub.classList.remove('slide-out');
                            sub.style.display = 'none';
                            sub.style.position = 'absolute';
                            sub.removeEventListener('animationend', onEnd);
                            showMainMenu();
                        };
                        sub.addEventListener('animationend', onEnd);
                    } else {
                        showMainMenu();
                    }
                });
            }

            if (clockBackBtn) {
                clockBackBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const sub = document.getElementById('clockSettingsSubMenu');
                    if (sub) {
                        sub.classList.remove('slide-out');
                        void sub.offsetWidth;
                        sub.classList.add('slide-out');
                        const onEnd = () => {
                            sub.classList.remove('slide-out');
                            sub.style.display = 'none';
                            sub.style.position = 'absolute';
                            sub.removeEventListener('animationend', onEnd);
                            showMainMenu();
                        };
                        sub.addEventListener('animationend', onEnd);
                    } else {
                        showMainMenu();
                    }
                });
            }

            if (speedBackBtn) {
                speedBackBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const sub = document.getElementById('speedSettingsSubMenu');
                    if (sub) {
                        sub.classList.remove('slide-out');
                        void sub.offsetWidth;
                        sub.classList.add('slide-out');
                        const onEnd = () => {
                            sub.classList.remove('slide-out');
                            sub.style.display = 'none';
                            sub.style.position = 'absolute';
                            sub.removeEventListener('animationend', onEnd);
                            showMainMenu();
                        };
                        sub.addEventListener('animationend', onEnd);
                    } else {
                        showMainMenu();
                    }
                });
            }

            if (dragseekBackBtn) {
                dragseekBackBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const sub = document.getElementById('dragseekSettingsSubMenu');
                    if (sub) {
                        sub.classList.remove('slide-out');
                        void sub.offsetWidth;
                        sub.classList.add('slide-out');
                        const onEnd = () => {
                            sub.classList.remove('slide-out');
                            sub.style.display = 'none';
                            sub.style.position = 'absolute';
                            sub.removeEventListener('animationend', onEnd);
                            showMainMenu();
                        };
                        sub.addEventListener('animationend', onEnd);
                    } else {
                        showMainMenu();
                    }
                });
            }

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.settings-container')) {
                    settingsMenu.classList.remove('show');
                    showMainMenu();
                }
            });

            function updateLogoButtonText() {
                toggleLogoBtn.textContent = logoEnabled ? i18n.t('playerSettings.off', 'Off') : i18n.t('playerSettings.on', 'On');
            }
            updateLogoButtonText();

            toggleLogoBtn.addEventListener('click', () => {
                logoEnabled = !logoEnabled;
                localStorage.setItem("video_logo_enabled", logoEnabled);
                updateLogoButtonText();
                updateLogoVisibility();
                updateTabValues();
            });

            const toggleLogoTypeBtn = document.getElementById('toggleLogoTypeBtn');

            function updateLogoTypeButtonText() {
                const typeNames = {
                    "default": i18n.t('playerSettings.default', 'Default'),
                    "red": i18n.t('playerSettings.red', 'Red'),
                    "white": i18n.t('playerSettings.white', 'White')
                };
                if (toggleLogoTypeBtn) {
                    toggleLogoTypeBtn.textContent = typeNames[logoType] || " ";
                }
            }
            updateLogoTypeButtonText();

            if (toggleLogoTypeBtn) {
                toggleLogoTypeBtn.addEventListener('click', () => {
                    const types = ["default", "red", "white"];
                    const currentIndex = types.indexOf(logoType);
                    const nextIndex = (currentIndex + 1) % types.length;
                    logoType = types[nextIndex];
                    localStorage.setItem("video_logo_type", logoType);
                    updateLogoTypeButtonText();
                    updateLogoVisibility();
                    updateTabValues();
                });
            }

            function updateClockButtonText() {
                toggleClockBtn.textContent = clockEnabled ? i18n.t('playerSettings.off', 'Off') : i18n.t('playerSettings.on', 'On');
            }
            updateClockButtonText();

            toggleClockBtn.addEventListener('click', () => {
                clockEnabled = !clockEnabled;
                localStorage.setItem("video_clock_enabled", clockEnabled);
                updateClockButtonText();
                updateClockVisibility();
                updateTabValues();
            });

            const toggleClockModeBtn = document.getElementById('toggleClockModeBtn');

            function updateClockModeButtonText() {
                toggleClockModeBtn.textContent = clockBlinkingMode ? i18n.t('playerSettings.blinking', 'Blinking') : i18n.t('playerSettings.static', 'Static');
            }
            updateClockModeButtonText();

            toggleClockModeBtn.addEventListener('click', () => {
                clockBlinkingMode = !clockBlinkingMode;
                localStorage.setItem("video_clock_blinking", clockBlinkingMode);
                updateClockModeButtonText();
                updateClockVisibility();
                updateTabValues();
            });

            const toggleDragSeekBtn = document.getElementById('toggleDragSeekBtn');
            let dragSeekEnabled = localStorage.getItem("video_dragseek_enabled") !== "false";

            function updateDragSeekButtonText() {
                if (toggleDragSeekBtn) {
                    toggleDragSeekBtn.textContent = dragSeekEnabled ? i18n.t('playerSettings.off', 'Off') : i18n.t('playerSettings.on', 'On');
                    toggleDragSeekBtn.classList.toggle('active', dragSeekEnabled);
                }
            }
            updateDragSeekButtonText();

            if (toggleDragSeekBtn) {
                toggleDragSeekBtn.addEventListener('click', () => {
                    dragSeekEnabled = !dragSeekEnabled;
                    localStorage.setItem("video_dragseek_enabled", dragSeekEnabled);
                    updateDragSeekButtonText();
                    updateTabValues();

                    if (window.dragSeekInstance) {
                        window.dragSeekInstance.setEnabled(dragSeekEnabled);
                    }
                });
            }



            let fullscreenHandler = null;

            function initFullscreenHandler() {
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                const videoContainer = document.getElementById('videoContainer');

                if (!fullscreenBtn || !videoContainer) {
                    debug.warn('Fullscreen button or video container not found');
                    return;
                }

                if (fullscreenHandler) {
                    fullscreenBtn.removeEventListener('click', fullscreenHandler);
                }

                fullscreenHandler = async () => {
                    try {
                        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                            if (document.exitFullscreen) {
                                await document.exitFullscreen();
                            } else if (document.webkitExitFullscreen) {
                                await document.webkitExitFullscreen();
                            } else if (document.mozCancelFullScreen) {
                                await document.mozCancelFullScreen();
                            } else if (document.msExitFullscreen) {
                                await document.msExitFullscreen();
                            }
                        } else {
                            if (window.DanmakuScrollSync) {
                                window.DanmakuScrollSync.saveSidebarScrollPosition();
                            }
                            
                            if (videoContainer.requestFullscreen) {
                                await videoContainer.requestFullscreen();
                            } else if (videoContainer.webkitRequestFullscreen) {
                                await videoContainer.webkitRequestFullscreen();
                            } else if (videoContainer.mozRequestFullScreen) {
                                await videoContainer.mozRequestFullScreen();
                            } else if (videoContainer.msRequestFullscreen) {
                                await videoContainer.msRequestFullscreen();
                            }
                        }
                    } catch (error) {
                        debug.error('Fullscreen error:', error);
                    }
                };

                fullscreenBtn.addEventListener('click', fullscreenHandler);
            }

            window.initFullscreenHandler = initFullscreenHandler;

            initFullscreenHandler();

            const fsDanmakuToggleBtn = document.getElementById('fsDanmakuToggleBtn');

            const cinemaModeBtn = document.getElementById('cinemaModeBtn');
            if (cinemaModeBtn) {
                cinemaModeBtn.addEventListener('click', () => {
                    toggleCinemaMode();
                });
            }

            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement === videoContainer) {
                    videoContainer.classList.add('fullscreen');
                    videoContainer.classList.add('show-cursor');
                    videoContainer.classList.remove('hide-cursor');
                    videoContainer.classList.add('fs-form-hidden');
                    const fsDanmakuToggleBtn = document.getElementById('fsDanmakuToggleBtn');
                    if (fsDanmakuToggleBtn) {
                        fsDanmakuToggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-keyboard-icon lucide-keyboard"><path d="M10 8h.01"/><path d="M12 12h.01"/><path d="M14 8h.01"/><path d="M16 12h.01"/><path d="M18 8h.01"/><path d="M6 8h.01"/><path d="M7 16h10"/><path d="M8 12h.01"/><rect width="20" height="16" x="2" y="4" rx="2"/></svg>';
                    }
                    const fullscreenBtn = document.getElementById('fullscreenBtn');
                    if (fullscreenBtn) {
                        fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shrink-icon lucide-shrink"><path d="m15 15 6 6m-6-6v4.8m0-4.8h4.8"/><path d="M9 19.8V15m0 0H4.2M9 15l-6 6"/><path d="M15 4.2V9m0 0h4.8M15 9l6-6"/><path d="M9 4.2V9m0 0H4.2M9 9 3 3"/></svg>';
                    }
                    try {
                        const overlay = document.getElementById('fullscreenDanmakuFormOverlay');
                        const form = overlay ? overlay.querySelector('.danmaku-form') : null;
                        const h = form ? Math.ceil(form.getBoundingClientRect().height) : 0;
                        videoContainer.style.setProperty('--fs-form-height', h ? h + 'px' : '0px');
                    } catch (_) { }
                    document.querySelector('.video-controls').classList.remove('autohide');
                    document.querySelector('.video-controls').classList.add('show');
                    startControlsTimer();
                } else {
                    videoContainer.classList.remove('fullscreen');
                    videoContainer.classList.remove('fs-form-hidden');
                    videoContainer.classList.remove('show-cursor');
                    videoContainer.classList.remove('hide-cursor');
                    const fullscreenBtn = document.getElementById('fullscreenBtn');
                    if (fullscreenBtn) {
                        fullscreenBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize-icon lucide-maximize"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>';
                    }
                    videoContainer.style.removeProperty('--fs-form-height');
                    showControls();
                    clearTimeout(controlsTimeout);
                    
                    const isWidescreen = document.body.classList.contains('wide-screen-mode');
                    const isCinema = document.body.classList.contains('cinema-mode');
                    if (!isWidescreen && !isCinema) {
                        const danmakuContent = document.getElementById('danmakuTabContent');
                        if (window.DanmakuScrollSync && danmakuContent) {
                            window.DanmakuScrollSync.syncSidebarScrollPosition(danmakuContent);
                        }
                    }
                }
            });

            if (fsDanmakuToggleBtn) {
                fsDanmakuToggleBtn.addEventListener('click', () => {
                    const hidden = videoContainer.classList.toggle('fs-form-hidden');
                    if (hidden) {
                        fsDanmakuToggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-keyboard-icon lucide-keyboard"><path d="M10 8h.01"/><path d="M12 12h.01"/><path d="M14 8h.01"/><path d="M16 12h.01"/><path d="M18 8h.01"/><path d="M6 8h.01"/><path d="M7 16h10"/><path d="M8 12h.01"/><rect width="20" height="16" x="2" y="4" rx="2"/></svg>';
                    } else {
                        fsDanmakuToggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-keyboard-off-icon lucide-keyboard-off"><path d="M 20 4 A2 2 0 0 1 22 6"/><path d="M 22 6 L 22 16.41"/><path d="M 7 16 L 16 16"/><path d="M 9.69 4 L 20 4"/><path d="M14 8h.01"/><path d="M18 8h.01"/><path d="m2 2 20 20"/><path d="M20 20H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2"/><path d="M6 8h.01"/><path d="M8 12h.01"/></svg>';
                    }
                    try {
                        const overlay = document.getElementById('fullscreenDanmakuFormOverlay');
                        const form = overlay ? overlay.querySelector('.danmaku-form') : null;
                        const h = (!hidden && form) ? Math.ceil(form.getBoundingClientRect().height) : 0;
                        videoContainer.style.setProperty('--fs-form-height', h ? h + 'px' : '0px');
                        if (!hidden) {
                            const input = document.getElementById('danmakuText');
                            if (input) input.focus();
                        }
                    } catch (_) { }
                });
            }

            document.addEventListener('keydown', (e) => {
                const t = e.target;
                if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;

                if (document.body.classList.contains('error-state')) {
                    return;
                }

                const isFullscreen = document.fullscreenElement && document.fullscreenElement === videoContainer;
                const isTheaterMode = document.body.classList.contains('cinema-mode');

                if (!isFullscreen && !isTheaterMode) return;

                const key = (e.key || '').toLowerCase();
                if (key === 'x' || key === '') {
                    e.preventDefault();
                    const hidden = videoContainer.classList.toggle('fs-form-hidden');
                    const fsDanmakuToggleBtn = document.getElementById('fsDanmakuToggleBtn');
                    if (fsDanmakuToggleBtn) {
                        if (hidden) {
                            fsDanmakuToggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-keyboard-icon lucide-keyboard"><path d="M10 8h.01"/><path d="M12 12h.01"/><path d="M14 8h.01"/><path d="M16 12h.01"/><path d="M18 8h.01"/><path d="M6 8h.01"/><path d="M7 16h10"/><path d="M8 12h.01"/><rect width="20" height="16" x="2" y="4" rx="2"/></svg>';
                        } else {
                            fsDanmakuToggleBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-keyboard-off-icon lucide-keyboard-off"><path d="M 20 4 A2 2 0 0 1 22 6"/><path d="M 22 6 L 22 16.41"/><path d="M 7 16 L 16 16"/><path d="M 9.69 4 L 20 4"/><path d="M14 8h.01"/><path d="M18 8h.01"/><path d="m2 2 20 20"/><path d="M20 20H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2"/><path d="M6 8h.01"/><path d="M8 12h.01"/></svg>';
                        }
                    }
                    try {
                        const overlay = document.getElementById('fullscreenDanmakuFormOverlay');
                        const form = overlay ? overlay.querySelector('.danmaku-form') : null;
                        const h = (!hidden && form) ? Math.ceil(form.getBoundingClientRect().height) : 0;
                        videoContainer.style.setProperty('--fs-form-height', h ? h + 'px' : '0px');
                        if (!hidden) {
                            const input = document.getElementById('danmakuText');
                            if (input) input.focus();
                        }
                    } catch (_) { }
                }
            });

            function startControlsTimer() {
                clearTimeout(controlsTimeout);
                controlsTimeout = setTimeout(() => {
                    if (!video.paused && hasStarted) {
                        const vc = videoContainer.querySelector('.video-controls');
                        const pb = videoContainer.querySelector('#progressBar');
                        const miniProgressBar = videoContainer.querySelector('#miniProgressBar');
                        const danmakuPanelBtn = document.getElementById('danmakuPanelBtn');
                        const danmakuPanelOverlay = document.getElementById('danmakuPanelOverlay');
                        if (vc) {
                            vc.classList.remove('show');
                            vc.classList.add('autohide');
                        }
                        if (pb) {
                            pb.classList.remove('show');
                            pb.classList.add('autohide');
                        }
                        if (danmakuPanelBtn && !danmakuPanelBtn.classList.contains('active')) {
                            danmakuPanelBtn.classList.remove('show');
                        }
                        if (danmakuPanelOverlay && danmakuPanelOverlay.classList.contains('open')) {
                            danmakuPanelOverlay.classList.add('expanded');
                        }
                        if (miniProgressBar && !videoContainer.classList.contains('fullscreen')) {
                            miniProgressBar.classList.add('show');
                        }
                        videoContainer.classList.add('hide-cursor');
                        videoContainer.classList.remove('show-cursor');
                    }
                }, 3000);
            }

            function showControls() {
                const vc = videoContainer.querySelector('.video-controls');
                const pb = videoContainer.querySelector('#progressBar');
                const miniProgressBar = videoContainer.querySelector('#miniProgressBar');
                const danmakuPanelBtn = document.getElementById('danmakuPanelBtn');

                if (miniProgressBar) {
                    miniProgressBar.classList.remove('show');
                }

                if (vc) {
                    vc.style.display = 'flex';
                    vc.classList.remove('autohide');
                    vc.classList.add('show');
                }
                if (pb) {
                    pb.style.display = 'block';
                    pb.classList.remove('autohide');
                    pb.classList.add('show');
                }

                if (danmakuPanelBtn) {
                    danmakuPanelBtn.classList.add('show');
                }

                const danmakuPanelOverlay = document.getElementById('danmakuPanelOverlay');
                if (danmakuPanelOverlay) {
                    danmakuPanelOverlay.classList.remove('expanded');
                }

                videoContainer.classList.add('show-cursor');
                videoContainer.classList.remove('hide-cursor');
                startControlsTimer();
            }

            function hideControls() {
                const vc = videoContainer.querySelector('.video-controls');
                const pb = videoContainer.querySelector('#progressBar');
                const miniProgressBar = videoContainer.querySelector('#miniProgressBar');
                const danmakuPanelBtn = document.getElementById('danmakuPanelBtn');
                const danmakuPanelOverlay = document.getElementById('danmakuPanelOverlay');

                if (vc) {
                    vc.classList.remove('show');
                    vc.classList.add('autohide');
                }
                if (pb) {
                    pb.classList.remove('show');
                    pb.classList.add('autohide');
                }

                if (danmakuPanelBtn && !danmakuPanelBtn.classList.contains('active')) {
                    danmakuPanelBtn.classList.remove('show');
                }

                if (danmakuPanelOverlay && danmakuPanelOverlay.classList.contains('open')) {
                    danmakuPanelOverlay.classList.add('expanded');
                }

                if (miniProgressBar && !videoContainer.classList.contains('fullscreen')) {
                    requestAnimationFrame(() => {
                        miniProgressBar.classList.add('show');
                    });
                }

                if (videoContainer.classList.contains('fullscreen')) {
                    videoContainer.classList.add('hide-cursor');
                    videoContainer.classList.remove('show-cursor');
                }
            }

            window.globalStartControlsTimer = function () {
                clearTimeout(controlsTimeout);
                controlsTimeout = setTimeout(() => {
                    if (!video.paused && hasStarted) {
                        const vc = videoContainer.querySelector('.video-controls');
                        const pb = videoContainer.querySelector('#progressBar');
                        const miniProgressBar = videoContainer.querySelector('#miniProgressBar');
                        const danmakuPanelBtn = document.getElementById('danmakuPanelBtn');
                        const danmakuPanelOverlay = document.getElementById('danmakuPanelOverlay');
                        if (vc) {
                            vc.classList.remove('show');
                            vc.classList.add('autohide');
                        }
                        if (pb) {
                            pb.classList.remove('show');
                            pb.classList.add('autohide');
                        }
                        if (danmakuPanelBtn && !danmakuPanelBtn.classList.contains('active')) {
                            danmakuPanelBtn.classList.remove('show');
                        }
                        if (danmakuPanelOverlay && danmakuPanelOverlay.classList.contains('open')) {
                            danmakuPanelOverlay.classList.add('expanded');
                        }
                        if (miniProgressBar && !videoContainer.classList.contains('fullscreen')) {
                            miniProgressBar.classList.add('show');
                        }
                        videoContainer.classList.add('hide-cursor');
                        videoContainer.classList.remove('show-cursor');
                    }
                }, 3000);
            };

            video.addEventListener('mousemove', () => {
                showControls();
            });

            videoContainer.addEventListener('mousemove', () => {
                showControls();
            });

            videoContainer.addEventListener('mouseleave', () => {
                if (videoContainer.classList.contains('fullscreen')) {
                    if (!video.paused) startControlsTimer();
                } else {
                    hideControls();
                }
            });
            const controlsEl = document.querySelector('.video-controls');
            if (controlsEl) {
                controlsEl.addEventListener('mousemove', () => {
                    showControls();
                });
            }

            video.addEventListener('mouseleave', () => {
                if (videoContainer.classList.contains('fullscreen')) {
                    if (!video.paused) startControlsTimer();
                } else {
                    hideControls();
                }
            });

            video.addEventListener('pause', () => {
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>';
                const vc = document.querySelector('.video-controls');
                if (vc) {
                    vc.classList.remove('autohide');
                    vc.classList.add('show');
                }
                videoContainer.classList.add('show-cursor');
                videoContainer.classList.remove('hide-cursor');
                clearTimeout(controlsTimeout);
                cancelAutoplayIfActive();
            });

            video.addEventListener('play', () => {
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause-icon lucide-pause"><rect x="14" y="3" width="5" height="18" rx="1"/><rect x="5" y="3" width="5" height="18" rx="1"/></svg>';
                hasStarted = true;

                if (!videoContainer.classList.contains('fullscreen')) {
                    hideControls();
                } else {
                    showControls();
                }

                try {
                    const overlay = document.getElementById('videoOverlay');
                    if (overlay) { overlay.style.opacity = '0'; setTimeout(() => overlay.style.display = 'none', 300); }
                    const progressPreview = document.getElementById('progressPreview');
                    if (progressPreview) progressPreview.style.display = 'none';
                } catch (_) { }
            });

            video.addEventListener('ended', () => {
                suppressNextPauseHud = true;
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>';
                const atEndWidth = '100%';
                if (progressBarFilled) progressBarFilled.style.width = atEndWidth;
                if (typeof video.duration === 'number' && isFinite(video.duration)) {
                    timeDisplay.textContent = `${formatDuration(video.duration)} / ${formatDuration(video.duration)}`;
                }
                const miniProgressFill = document.getElementById('miniProgressFill');
                if (miniProgressFill) {
                    miniProgressFill.style.width = atEndWidth;
                }
                try { if (progressHandle) progressHandle.style.left = atEndWidth; } catch (_) { }
                try {
                    if (!videoContainer.classList.contains('fullscreen')) {
                        hideControls();
                    }
                } catch (_) { }
                setTimeout(() => { suppressNextPauseHud = false; }, 0);

                if (window.abSegmentA !== null && window.abSegmentB !== null) {
                    const startTime = Math.min(window.abSegmentA, window.abSegmentB);
                    video.currentTime = startTime;
                    video.play();
                }

                if (autoplayEnabled && currentVideo) {
                    let nextVideo = null;
                    let currentPlaylist = null;
                    let playlistVideos = null;

                    const urlParams = new URLSearchParams(window.location.search);
                    const playlistId = urlParams.get('playlist');

                    if (playlistId) {
                        currentPlaylist = allPlaylists.find(pl => String(pl.id) === playlistId);
                    }

                    if (currentPlaylist && currentPlaylist.videos) {
                        playlistVideos = currentPlaylist.videos.slice();
                        
                        if (window._playlistInverted) {
                            playlistVideos.reverse();
                        }
                        
                        const currentIndex = playlistVideos.findIndex(v => v.name === currentVideo.name);
                        
                        if (window._playlistShuffle) {
                            const otherVideos = playlistVideos.filter(v => v.name !== currentVideo.name);
                            if (otherVideos.length > 0) {
                                nextVideo = otherVideos[Math.floor(Math.random() * otherVideos.length)];
                            }
                        } else if (currentIndex !== -1) {
                            if (currentIndex < playlistVideos.length - 1) {
                                nextVideo = playlistVideos[currentIndex + 1];
                            } else if (window._playlistLoop) {
                                nextVideo = playlistVideos[0];
                            }
                        }
                    }

                    if (!nextVideo) {
                        const folderVideos = allVideos.filter(v => v.dirHandle === currentVideo.dirHandle);
                        const currentIndex = folderVideos.findIndex(v => v.name === currentVideo.name);
                        
                        if (window._playlistShuffle) {
                            const otherVideos = folderVideos.filter(v => v.name !== currentVideo.name);
                            if (otherVideos.length > 0) {
                                nextVideo = otherVideos[Math.floor(Math.random() * otherVideos.length)];
                            }
                        } else if (currentIndex !== -1) {
                            if (currentIndex < folderVideos.length - 1) {
                                nextVideo = folderVideos[currentIndex + 1];
                            } else if (window._playlistLoop) {
                                nextVideo = folderVideos[0];
                            }
                        }
                    }

                    if (nextVideo) {
                        showNextOverlay(nextVideo);
                    }
                }
            });
        }

        function updateUrlParameter(param, value) {
            const url = new URL(window.location.href);
            if (value && value !== 'new') {
                url.searchParams.set(param, value);
            } else {
                url.searchParams.delete(param);
            }
            window.history.replaceState({}, '', url.toString());
        }

        function updatePageTitle() {
            if (currentVideo && currentVideo.name) {
                return;
            }

            let titleParts = [];
            const baseTitle = 'Youvi';

            if (currentFilter && currentFilter !== 'all') {
                titleParts.push(currentFilter);
            }

            /*
            if (currentSort && currentSort !== 'new') {
              titleParts.push(currentSort === 'popular' ? '' : 
                              currentSort === 'old' ? '' : 
                              currentSort === 'random' ? '' : 
                              currentSort === 'alphabetical' ? ' ' : '');
            }
            */

            if (titleParts.length > 0) {
                document.title = `${titleParts.join(' | ')} | ${baseTitle}`;
            } else {
                document.title = `${i18n.t('video.watchingVideo', 'Watching video')} | ${baseTitle}`;
            }
        }
        window.currentPlaylistHandle = null;
        window.currentVideoName = null;

        let currentPlaylistHandle = null;
        let currentVideoName = null;

        window.debugDanmaku = function () {
            debug.log('Danmaku Debug Info:');
            debug.log('- currentVideoName:', window.currentVideoName);
            debug.log('- currentPlaylistHandle:', window.currentPlaylistHandle);
            debug.log('- danmakuData:', window.danmakuData || 'not loaded');
            debug.log('- danmakuEnabled:', window.danmakuEnabled);
        };

        window.videoEl = null;

        window.readJSONFile = async (dirHandle, fileName, defaultValue = null) => {
            if (!dirHandle) return defaultValue;
            try {
                let exists = false;
                for await (const [name] of dirHandle.entries()) {
                    if (name === fileName) {
                        exists = true;
                        break;
                    }
                }
                if (!exists) return defaultValue;

                const fileHandle = await dirHandle.getFileHandle(fileName, { create: false });
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (error) {
                debug.warn(`Could not read ${fileName}:`, error);
                return defaultValue;
            }
        };

        window.writeJSONFile = async (dirHandle, fileName, data) => {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();
                return true;
            } catch (error) {
                console.error(`Could not write ${fileName}:`, error);
                return false;
            }
        };


        function linkifyTimecodes(html) {
            const re = /(\d{1,2}):(\d{2})(?::(\d{2}))?(?!\d)/g;
            return html.replace(re, (match, first, second, third) => {
                let total;
                if (third !== undefined) {
                    total = parseInt(first, 10) * 3600 + parseInt(second, 10) * 60 + parseInt(third, 10);
                } else {
                    total = parseInt(first, 10) * 60 + parseInt(second, 10);
                }
                return `<button class="btn" data-seek="${total}" style="padding:2px 6px;margin:0 2px;">${match}</button>`;
            });
        }

        function escapeHtml(s) {
            const d = document.createElement('div');
            d.textContent = s;
            return d.innerHTML;
        }

        function toggleImageSize(img) {
            if (window.ImageViewer) {
                const title = img.alt || img.title || '';
                window.ImageViewer.show(img.src, title, img.alt);
            }
        }






        document.addEventListener('DOMContentLoaded', async () => {
            const langSwitcher = document.getElementById('langSwitcher');
            if (langSwitcher && typeof i18n !== 'undefined') {
                langSwitcher.value = i18n.getCurrentLanguage();
                
                langSwitcher.addEventListener('change', async (e) => {
                    await i18n.setLanguage(e.target.value);
                });
                
                i18n.subscribe(async (newLang) => {
                    debug.log('[i18n] Language changed to:', newLang, '- re-rendering dynamic content');
                    
                    if (typeof currentVideo !== 'undefined' && currentVideo) {
                        const videoViewsEl = document.getElementById('videoViews');
                        const videoLikesEl = document.getElementById('videoLikes');
                        const videoDislikesEl = document.getElementById('videoDislikes');
                        const uploaderNameEl = document.getElementById('uploaderName');
                        
                        if (videoViewsEl) videoViewsEl.textContent = `${currentVideo.views || 0} ${i18n.t('video.views', 'views')}`;
                        if (videoLikesEl) videoLikesEl.textContent = `${currentVideo.likes || 0} ${i18n.t('video.likes', 'likes')}`;
                        if (videoDislikesEl) videoDislikesEl.textContent = `${currentVideo.dislikes || 0} ${i18n.t('video.dislikes', 'dislikes')}`;
                        
                        if (uploaderNameEl && !window.currentChannelName) {
                            uploaderNameEl.textContent = i18n.t('video.noChannel', 'No channel');
                        }
                        
                        if (window.updateVideoTagsDisplay) {
                            const tags = currentVideo.tags || currentVideo.categories || [];
                            try { window.updateVideoTagsDisplay(tags); } catch (e) { }
                        }
                    }
                    
                    if (typeof window.renderComments === 'function') {
                        try {
                            const uiState = typeof captureCommentsUIState === 'function' ? captureCommentsUIState() : null;
                            await window.renderComments(uiState);
                        } catch (e) { debug.warn('Failed to re-render comments:', e); }
                    }
                    
                    if (typeof renderDanmakuComments === 'function' && typeof danmakuData !== 'undefined') {
                        try { renderDanmakuComments(danmakuData); } catch (e) { }
                    }
                    
                    if (typeof renderCombinedPlaylist === 'function' && currentVideo) {
                        try { 
                            await renderCombinedPlaylist(currentVideo._playlistId, currentVideo.dirHandle, currentVideo.name); 
                        } catch (e) { debug.warn('Failed to re-render playlist:', e); }
                    }
                    
                    if (typeof updateRecommendationsDebounced === 'function') {
                        updateRecommendationsDebounced();
                    }
                    
                    if (typeof renderSubscribedChannelsList === 'function') {
                        try { await renderSubscribedChannelsList(); } catch (e) { }
                    }
                    
                    if (typeof renderSidebarCategories === 'function') {
                        try { renderSidebarCategories(); } catch (e) { }
                    }
                    
                    if (typeof window.renderParentChildCarousels === 'function') {
                        try { window.renderParentChildCarousels(); } catch (e) { }
                    }
                    
                    if (typeof updateTabValues === 'function') {
                        try { updateTabValues(); } catch (e) { }
                    }
                    
                    if (typeof updateSidebarAutoplayStatus === 'function') {
                        try { updateSidebarAutoplayStatus(); } catch (e) { }
                    }
                });
            }
            
            const overlay = document.getElementById('videoOverlay');
            if (overlay) {
                overlay.style.display = 'flex';
                overlay.style.opacity = '1';
            }

            if (!supportsFS) {
                showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.fsNotSupported', 'File System API     .  Chrome/Edge.') : 'File System API     .  Chrome/Edge.', 'notfound');
                return;
            }
            try {
                db = await openDB();
                const savedHandle = await getFromDB(db, 'videoDirectoryHandle');
                if (savedHandle) {
                    const perm = await savedHandle.queryPermission();
                    if (perm === 'granted' || (perm === 'prompt' && await savedHandle.requestPermission() === 'granted')) {
                        videoDirectoryHandle = savedHandle;

                        if (window.VideoID) {
                            await window.VideoID.loadIndex(videoDirectoryHandle);
                        }

                        const urlParams = new URLSearchParams(window.location.search);
                        let videoName = null;
                        const videoId = urlParams.get('v');
                        if (videoId && window.VideoID && window.VideoID.isVideoId(videoId)) {
                            videoName = window.VideoID.getFilename(videoId);
                        }
                        if (!videoName) {
                            videoName = urlParams.get('name');
                        }
                        if (videoName) {
                            await loadCurrentPlaylistVideos();
                        }

                        await loadVideoAndPlay();
                        updateRecommendationsDebounced();

                        if (window.currentPlaylistHandle && window.currentVideoName) {
                            currentPlaylistHandle = window.currentPlaylistHandle;
                            currentVideoName = window.currentVideoName;
                            debug.log('Video metadata variables initialized:', currentVideoName, currentPlaylistHandle);
                        }

                        requestIdleCallback(async () => {
                            if (window.tagDatabaseManager && videoDirectoryHandle) {
                                try {
                                    await window.tagDatabaseManager.initialize(videoDirectoryHandle);
                                    debug.log('[TagDB]  Initialized on video page');
                                } catch (error) {
                                    debug.warn('[TagDB]  Failed to initialize:', error);
                                }
                            }
                        }, { timeout: 2000 });

                        const playlistId = urlParams.get('playlist') || urlParams.get('userPlaylist');
                        const v = document.getElementById('video');
                        const kickOffBackground = async () => {
                            try {
                                
                                debug.log(' Loading all videos in background...');
                                await loadAllVideos();
                                debug.log(' All videos loaded:', allVideos.length);

                                // Load danmaku counts
                                if (window.DanmakuCounter) {
                                    await window.DanmakuCounter.load(videoDirectoryHandle, allVideos);
                                }

                                updateRecommendationsDebounced();

                                await loadAllPlaylists();

                                try {
                                    const searchInput = document.getElementById('headerSearchInput');
                                    if (searchInput && typeof AutocompleteIntegration !== 'undefined' && typeof YouviAutocomplete !== 'undefined') {
                                        const cacheValid = await window.autocompleteCache.isCacheValid(
                                            allVideos.length,
                                            allPlaylists.length
                                        );

                                        let videos = [];
                                        let playlists = [];

                                        if (!cacheValid) {
                                            debug.log('[Autocomplete] Cache invalid, updating with loaded data:', {
                                                videos: allVideos.length,
                                                playlists: allPlaylists.length
                                            });
                                            videos = allVideos || [];
                                            playlists = allPlaylists || [];
                                        } else {
                                            debug.log('[Autocomplete] Cache valid, skipping data update');
                                        }

                                        const autocompleteIntegration = new AutocompleteIntegration();
                                        await autocompleteIntegration.init(searchInput, {
                                            videoDirectoryHandle: videoDirectoryHandle,
                                            allVideos: videos,
                                            allPlaylists: playlists
                                        });
                                        debug.log('[Autocomplete]  Initialized on youvi_video.html');
                                    }
                                } catch (error) {
                                    debug.error('[Autocomplete] Failed to initialize:', error);
                                }

                                if (currentVideo) {
                                    await renderCombinedPlaylist(playlistId, currentVideo.dirHandle, currentVideo.name);
                                    updateRecommendationsDebounced();
                                }
                            } catch (err) {
                                debug.error('[Background] Error loading playlists:', err);
                            }
                        };
                        
                        setTimeout(kickOffBackground, 100);

                        attachVideoPlayerEventListeners();
                        document.getElementById('currentPlaylistAllLink').addEventListener('click', (e) => {
                            e.preventDefault();
                            const playlistId = new URLSearchParams(window.location.search).get('playlist');
                            if (playlistId) {
                                window.location.href = `screen_playlist.html?playlistId=${playlistId}`;
                            }
                        });

                        document.getElementById('folderPlaylistAllLink').addEventListener('click', (e) => {
                            e.preventDefault();
                            const folderLink = document.getElementById('folderPlaylistAllLink');
                            if (folderLink && folderLink.getAttribute('href')) {
                                window.location.href = folderLink.getAttribute('href');
                            }
                        });

                    } else {
                        showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.noFolderAccess', '     ') : '     ', 'folder');
                    }
                } else {
                    showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.selectFolderFirstFull', '       ') : '       ', 'folder');
                }
            } catch (e) {
                debug.error('FS access error', e);
                showErrorState(typeof i18n !== 'undefined' ? i18n.t('video.fsAccessError', '    ') : '    ', 'notfound');
            }

            initializeSidebarState();

            const sidebarToggle = document.getElementById('sidebarToggle');
            if (sidebarToggle && !sidebarToggle.dataset.listenerAttached) {
                sidebarToggle.addEventListener('click', toggleSidebar);
                sidebarToggle.dataset.listenerAttached = 'true';
            }

            const descriptionToggle = document.getElementById('descriptionToggle');
            const descriptionContent = document.getElementById('descriptionContent');
            const descriptionHeader = document.getElementById('descriptionHeader');

            if (descriptionToggle && descriptionContent && descriptionHeader) {
                descriptionContent.classList.add('collapsed');
                descriptionToggle.classList.add('collapsed');

                descriptionHeader.addEventListener('click', () => {
                    const isCollapsed = descriptionContent.classList.contains('collapsed');

                    if (isCollapsed) {
                        descriptionContent.classList.remove('collapsed');
                        descriptionContent.classList.add('expanded');
                        descriptionToggle.classList.remove('collapsed');
                    } else {
                        descriptionContent.classList.remove('expanded');
                        descriptionContent.classList.add('collapsed');
                        descriptionToggle.classList.add('collapsed');
                    }
                });
            }

            const editDescriptionBtn = document.getElementById('editDescriptionBtn');
            const descriptionEditForm = document.getElementById('descriptionEditForm');
            const descriptionEditInput = document.getElementById('descriptionEditInput');
            const descriptionEditCancel = document.getElementById('descriptionEditCancel');
            const descriptionEditSave = document.getElementById('descriptionEditSave');
            const descriptionText = document.getElementById('descriptionText');

            if (editDescriptionBtn && descriptionEditForm && descriptionEditInput && descriptionEditCancel && descriptionEditSave && descriptionText) {
                editDescriptionBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    descriptionText.style.display = 'none';
                    descriptionEditForm.style.display = 'block';
                    descriptionEditForm.style.width = '100%';
                    descriptionEditForm.style.maxWidth = '100%';

                    if (window.currentRawDescription && typeof window.currentRawDescription === 'string') {
                        descriptionEditInput.value = window.currentRawDescription;
                    } else {
                        loadDescriptionFromFile().then(text => {
                            descriptionEditInput.value = text || '';
                        }).catch(() => {
                            descriptionEditInput.value = descriptionText.textContent || '';
                        });
                    }
                    descriptionEditInput.focus();
                });

                descriptionEditCancel.addEventListener('click', (e) => {
                    e.preventDefault();

                    descriptionEditForm.style.display = 'none';
                    descriptionText.style.display = 'block';
                });

                descriptionEditSave.addEventListener('click', async (e) => {
                    e.preventDefault();

                    const newDescription = descriptionEditInput.value.trim();

                    descriptionText.textContent = newDescription;
                    window.currentRawDescription = newDescription;

                    descriptionEditForm.style.display = 'none';
                    descriptionText.style.display = 'block';

                    parseAndRenderChapters(newDescription);

                    await saveDescriptionToFile(newDescription);
                });
            }
        });

        function parseAndRenderChapters(description) {
            const descriptionText = document.getElementById('descriptionText');
            const progressBar = document.getElementById('progressBar');

            if (!descriptionText || !progressBar) return;

            clearChapterMarkers();

            const lines = description.split('\n');
            const chapters = [];

            lines.forEach(line => {
                const trimmedLine = line.trim();

                const timeCodePattern = /^(?:\d+[\.)]?\s+)?(\d{1,2}:\d{2}(?::\d{2})?)\s*[-:]?\s*(.+)/;
                const match = trimmedLine.match(timeCodePattern);

                if (match) {
                    const timeStr = match[1];
                    const title = match[2] ? match[2].trim() : `Chapter at ${timeStr}`;

                    const timeInSeconds = parseTimeToSeconds(timeStr);

                    chapters.push({
                        time: timeInSeconds,
                        timeStr: timeStr,
                        title: title
                    });
                }
            });

            if (chapters.length > 0) {
                chapters.sort((a, b) => a.time - b.time);

                window.currentChapters = chapters;

                highlightTimeCodesInText(description, chapters);

                renderChapterMarkers(chapters);
            } else {
                window.currentChapters = [];
            }
        }

        function highlightTimeCodesInText(description, chapters) {
            const descriptionText = document.getElementById('descriptionText');
            if (!descriptionText) return;

            let processedText = String(description || '').replace(/[&<>]/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[s]));

            chapters.forEach(chapter => {
                const timeCodeRegex = new RegExp(`(${chapter.timeStr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'g');
                processedText = processedText.replace(timeCodeRegex, `<button class="time-code" data-time="${chapter.time}">$1</button>`);
            });

            processedText = processedText.replace(/\n/g, '<br>');

            descriptionText.innerHTML = processedText;

            descriptionText.querySelectorAll('.time-code').forEach(element => {
                element.replaceWith(element.cloneNode(true));
            });

            const timecodes = Array.from(descriptionText.querySelectorAll('.time-code'));
            timecodes.forEach((element, index) => {
                element.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    if (window.abSegmentA !== null || window.abSegmentB !== null) {
                        window.abSegmentA = null;
                        window.abSegmentB = null;
                        window.abSegmentMode = 0;
                        if (typeof window.updateABMarkers === 'function') {
                            window.updateABMarkers();
                        }
                    }

                    const time = parseFloat(element.dataset.time);
                    if (!isNaN(time)) {
                        seekToTime(time);
                    }
                });

                element.addEventListener('contextmenu', (e) => {
                    window.showTimecodeContextMenu(e, element, timecodes, index);
                });
            });
        }

        function clearChapterMarkers() {
            const progressBar = document.getElementById('progressBar');
            const miniProgressBar = document.getElementById('miniProgressBar');

            if (progressBar) {
                const existingMarkers = progressBar.querySelectorAll('.chapter-marker');
                existingMarkers.forEach(marker => marker.remove());
            }

            if (miniProgressBar) {
                const existingMarkers = miniProgressBar.querySelectorAll('.chapter-marker');
                existingMarkers.forEach(marker => marker.remove());
            }
        }

        function renderChapterMarkers(chapters) {
            const progressBar = document.getElementById('progressBar');
            const miniProgressBar = document.getElementById('miniProgressBar');
            const video = document.querySelector('.video-player video');

            if (!video) return;

            const addMarkerToBar = (bar, chapter) => {
                if (!bar) return;

                const marker = document.createElement('div');
                marker.className = 'chapter-marker';
                marker.dataset.time = chapter.time;
                marker.dataset.title = chapter.title;

                marker.addEventListener('click', (e) => {
                    e.stopPropagation();
                    seekToTime(chapter.time);
                });

                const updateMarkerPosition = () => {
                    if (video.duration > 0) {
                        const percentage = (chapter.time / video.duration) * 100;
                        marker.style.left = `${percentage}%`;
                    }
                };

                if (video.duration > 0) {
                    updateMarkerPosition();
                } else {
                    video.addEventListener('loadedmetadata', updateMarkerPosition, { once: true });
                }

                bar.appendChild(marker);
            };

            chapters.forEach(chapter => {
                addMarkerToBar(progressBar, chapter);
                addMarkerToBar(miniProgressBar, chapter);
            });
        }

        function parseTimeToSeconds(timeStr) {
            const parts = timeStr.split(':');
            let seconds = 0;

            if (parts.length === 2) {
                seconds = parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else if (parts.length === 3) {
                seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
            }

            return seconds;
        }

        function seekToTime(timeInSeconds) {
            let video = null;
            let playPauseBtn = null;

            if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                video = window.documentPiPManager.pipWindow.document.querySelector('video');
                playPauseBtn = window.documentPiPManager.pipWindow.document.getElementById('playPauseBtn');
            } else {
                video = document.querySelector('video');
                playPauseBtn = document.getElementById('playPauseBtn');
            }

            if (video) {
                video.currentTime = Math.min(video.duration || timeInSeconds, timeInSeconds);
                video.play();
                if (playPauseBtn) playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause-icon lucide-pause"><rect x="14" y="3" width="5" height="18" rx="1"/><rect x="5" y="3" width="5" height="18" rx="1"/></svg>';
            }
        }

        async function saveDescriptionToFile(description) {
            try {
                if (currentVideo && currentVideo.dirHandle) {
                    const metadataDir = await currentVideo.dirHandle.getDirectoryHandle('.metadata', { create: true });
                    const descriptionFile = await metadataDir.getFileHandle(currentVideo.name + '.description.txt', { create: true });
                    const writable = await descriptionFile.createWritable();
                    await writable.write(description);
                    await writable.close();
                }
            } catch (error) {
                debug.error('Error saving description:', error);
            }
        }

        async function loadDescriptionFromFile() {
            try {
                if (currentVideo && currentVideo.dirHandle) {
                    const metadataDir = await currentVideo.dirHandle.getDirectoryHandle('.metadata', { create: false });
                    const descriptionFile = await metadataDir.getFileHandle(currentVideo.name + '.description.txt', { create: false });
                    const file = await descriptionFile.getFile();
                    const description = await file.text();
                    return description;
                }
            } catch (error) {
                debug.log('No description file found, using default');
            }
            return null;
        }

        let autoplayEnabled = true;
        const videoLogo = document.getElementById("videoLogo");
        const videoClock = document.getElementById("videoClock");
        let autoplayOverlayActive = false;
        let autoplayTimer = null;

        function getVideoElement(id) {
            if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                const pipEl = window.documentPiPManager.pipWindow.document.getElementById(id);
                if (pipEl) return pipEl;
            }
            return document.getElementById(id);
        }

        function updateLogoVisibility() {
            const videoLogo = getVideoElement("videoLogo");
            if (!videoLogo) return;
            if (!logoEnabled || !hasStarted) {
                videoLogo.style.display = "none";
                return;
            }
            videoLogo.style.display = "block";

            let logoSrc = "images/8site_mini_white.png";
            if (logoType === "red") {
                logoSrc = "images/tv8_red.png";
            } else if (logoType === "white") {
                logoSrc = "images/tv8_white.png";
            }
            videoLogo.src = logoSrc;
        }

        function updateClockVisibility() {
            const videoClock = getVideoElement("videoClock");
            if (!videoClock) return;
            const video = getVideoElement('video');
            if (!clockEnabled || !hasStarted) {
                videoClock.style.display = "none";
                return;
            }
            videoClock.style.display = "block";

            if (clockBlinkingMode && video && !video.paused) {
                videoClock.classList.add('blinking');
                videoClock.classList.remove('paused');
            } else if (video && video.paused && clockBlinkingMode) {
                videoClock.classList.add('blinking', 'paused');
            } else {
                videoClock.classList.remove('blinking', 'paused');
            }
        }

        function showHud(icon) {
            const videoHud = document.getElementById('videoHud');
            if (videoHud) {
                if (icon === '') {
                    videoHud.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>';
                } else if (icon === '') {
                    videoHud.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pause-icon lucide-pause"><rect x="14" y="3" width="5" height="18" rx="1"/><rect x="5" y="3" width="5" height="18" rx="1"/></svg>';
                } else {
                    videoHud.textContent = icon;
                }
                videoHud.style.display = 'flex';
                setTimeout(() => {
                    videoHud.style.display = 'none';
                }, 400);
            }
        }
        function attachCarouselNavEventListeners() {
            document.querySelectorAll('.carousel-nav-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const playlistId = btn.dataset.playlistId;
                    const type = btn.dataset.playlistType;
                    const targetCarouselId =
                        type === 'current' ? 'currentPlaylistCarousel' :
                            type === 'folder' ? 'folderPlaylistCarousel' :
                                'recommendationsCarousel';

                    let videos = [];
                    if (type === 'current') {
                        const pl = allPlaylists.find(pl => String(pl.id) === playlistId);
                        if (pl) videos = pl.videos || [];
                    } else if (type === 'folder') {
                        videos = allVideos.filter(v => v.dirHandle === currentVideo.dirHandle);
                    } else if (type === 'recommendations') {
                        videos = allVideos.filter(v => v.name !== currentVideo.name);
                    }

                    const totalPages = Math.max(1, Math.ceil(videos.length / videosPerPage));

                    let page = carouselVideoPages.get(playlistId) || 1;
                    page += btn.classList.contains('next-btn') ? 1 : -1;
                    if (page < 1) page = 1;
                    if (page > totalPages) page = totalPages;

                    carouselVideoPages.set(playlistId, page);
                    renderCarousel(targetCarouselId, videos, playlistId);
                });
            });
        }

        const videoElement = document.getElementById('video');
        const resizeBtn = document.getElementById('resizeVideoBtn');
        let videoFitMode = 0;

        function updateVideoFit() {
            switch (videoFitMode) {
                case 0:
                    videoElement.style.objectFit = 'contain';
                    resizeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2"><path d="M15 3h6v6"/><path d="m21 3-7 7"/><path d="m3 21 7-7"/><path d="M9 21H3v-6"/></svg>';
                    resizeBtn.title = "  ";
                    resizeBtn.classList.remove('active');
                    break;
                case 1:
                    videoElement.style.objectFit = 'cover';
                    resizeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-scissors-icon lucide-scissors"><circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/></svg>';
                    resizeBtn.title = "  ";
                    resizeBtn.classList.add('active');
                    break;
                case 2:
                    videoElement.style.objectFit = 'fill';
                    resizeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-minimize2-icon lucide-minimize-2"><path d="m14 10 7-7"/><path d="M20 10h-6V4"/><path d="m3 21 7-7"/><path d="M4 14h6v6"/></svg>';
                    resizeBtn.title = "   ";
                    resizeBtn.classList.add('active');
                    break;
            }
        }

        function toggleVideoResize() {
            videoFitMode = (videoFitMode + 1) % 3;
            updateVideoFit();
            localStorage.setItem("video_fit_mode", videoFitMode);
        }

        const savedMode = localStorage.getItem("video_fit_mode");
        if (savedMode !== null) {
            videoFitMode = parseInt(savedMode);
            updateVideoFit();
        } else {
            updateVideoFit();
        }

        resizeBtn.addEventListener('click', toggleVideoResize);

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.contentEditable === 'true') {
                return;
            }

            if (e.key.toLowerCase() === 'r' || e.key.toLowerCase() === '') {
                if (document.body.classList.contains('error-state')) {
                    e.preventDefault();
                    return;
                }
                e.preventDefault();
                toggleVideoResize();
            }

        });

        (function () {
            const form = document.getElementById('danmakuContent');
            const overlay = document.getElementById('fullscreenDanmakuFormOverlay');
            const anchor = document.getElementById('danmakuFormAnchor');
            const videoContainer = document.getElementById('videoContainer');

            function isFullscreen() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
            }

            function moveFormToOverlay() {
                if (!form || !overlay || !videoContainer) return;
                if (overlay.contains(form)) return;
                overlay.style.display = 'block';
                if (overlay.parentElement !== videoContainer) videoContainer.appendChild(overlay);
                overlay.appendChild(form);

                setTimeout(() => {
                    if (window.initDanmakuKaomojiPicker) {
                        window.initDanmakuKaomojiPicker();
                    }
                }, 100);
            }

            function restoreForm() {
                if (!form || !anchor || !anchor.parentNode) return;
                if (anchor.nextSibling === form) return;
                
                const isWideMode = document.body.classList.contains('wide-screen-mode');
                if (isWideMode) {
                    const mainContent = document.querySelector('.main-content');
                    const playerSection = document.querySelector('.player-section');
                    if (mainContent && playerSection && playerSection.parentNode === mainContent) {
                        playerSection.parentNode.insertBefore(form, playerSection.nextSibling);
                    } else {
                        anchor.parentNode.insertBefore(form, anchor.nextSibling);
                    }
                } else {
                    anchor.parentNode.insertBefore(form, anchor.nextSibling);
                }
                overlay.style.display = 'none';

                setTimeout(() => {
                    if (window.initDanmakuKaomojiPicker) {
                        window.initDanmakuKaomojiPicker();
                    }
                }, 100);
            }

            function onFsChange() {
                if (isFullscreen()) moveFormToOverlay(); else restoreForm();
            }

            document.addEventListener('fullscreenchange', onFsChange);
            document.addEventListener('webkitfullscreenchange', onFsChange);
            document.addEventListener('mozfullscreenchange', onFsChange);
            document.addEventListener('MSFullscreenChange', onFsChange);

            if (isFullscreen()) moveFormToOverlay();
        })();


        document.addEventListener('DOMContentLoaded', () => {
            const pipBtn = document.getElementById('pipBtn');
            if (pipBtn) {
                pipBtn.addEventListener('click', () => {
                    togglePictureInPicture();
                });
            }
            const headerSearchBtn = document.getElementById('doSearch');
            const headerSearchInput = document.getElementById('headerSearchInput');

            if (headerSearchInput && headerSearchBtn) {
                const goToSearch = () => {
                    const q = (headerSearchInput.value || '').trim();
                    const params = new URLSearchParams();
                    if (q) params.set('q', q);
                    window.location.href = `youvi_search.html${params.toString() ? '?' + params.toString() : ''}`;
                };

                headerSearchBtn.addEventListener('click', goToSearch);

                headerSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        goToSearch();
                    }
                });
            }
        });

        function togglePictureInPicture() {
            const video = document.getElementById('video');
            if (!video) return;
            if (document.pictureInPictureElement) {
                document.exitPictureInPicture().catch(() => { });
            } else {
                video.requestPictureInPicture().catch(() => { });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const pipBtn = document.getElementById('pipBtn');
            if (pipBtn) {
                document.addEventListener('enterpictureinpicture', () => {
                    pipBtn.classList.add('active');
                });
                document.addEventListener('leavepictureinpicture', () => {
                    pipBtn.classList.remove('active');
                });
            }
        });
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const colorSelect = document.getElementById('danmakuColor');
                const textInput = document.getElementById('danmakuText');
                if (colorSelect && textInput) {
                    const applyInputColor = () => {
                        let c = colorSelect.value || '#ffffff';
                        const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
                        const isCinemaMode = document.body.classList.contains('cinema-mode');
                        const isPiP = window.documentPiPManager && window.documentPiPManager.pipWindow;
                        const isInPiPDocument = textInput.ownerDocument !== document;
                        const isDarkBackground = isFullscreen || isCinemaMode || isPiP || isInPiPDocument || document.body.classList.contains('dark-theme');
                        
                        if (!isDarkBackground && (c.toLowerCase() === '#ffffff' || c.toLowerCase() === 'white' || c.toLowerCase() === '#fff')) {
                            c = '#111111';
                        }
                        textInput.style.color = c;
                        textInput.style.caretColor = c;
                    };
                    applyInputColor();
                    colorSelect.addEventListener('change', applyInputColor);
                    
                    document.addEventListener('fullscreenchange', applyInputColor);
                    document.addEventListener('webkitfullscreenchange', applyInputColor);
                    
                    window.applyDanmakuInputColor = applyInputColor;
                }
            } catch (_) { }
        });

        function showNextOverlay(nextVideo) {
            if (autoplayOverlayActive) {
                return;
            }

            autoplayOverlayActive = true;
            const overlay = document.createElement("div");
            overlay.className = "autoplay-overlay";
            overlay.style.display = "flex";

            overlay.innerHTML = `
        <div class="autoplay-title">
            ${i18n.t('video.nextVideo', ' ')}:<br>
            <span>${nextVideo.title || getFileNameWithoutExtension(nextVideo.name)}</span>
        </div>
        <div class="autoplay-circle">
            <svg class="autoplay-progress" viewBox="0 0 80 80" preserveAspectRatio="xMidYMid meet">
                <circle cx="40" cy="40" r="32"></circle>
            </svg>
            <div class="autoplay-play" role="button" aria-label="${i18n.t('comments.watch', '')}">
                <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play">
                    <path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/>
                </svg>
            </div>
        </div>
        <div id="countdown" style="color:#ccc; font-size:13px; margin-bottom:10px;">
        </div>
        <div class="autoplay-actions">
            <button id="playNow" class="autoplay-btn">${i18n.t('comments.watch', '')}</button>
            <button id="cancelAutoplay" class="autoplay-btn">${i18n.t('comments.cancel', '')}</button>
        </div>
    `;

            document.querySelector(".video-container").appendChild(overlay);

            try {
                video.pause();
                video.currentTime = Math.max(0, video.duration - 0.1);
                video.removeAttribute("poster");
            } catch (e) {
                debug.warn(" freeze last frame:", e);
            }

            const circle = overlay.querySelector("circle");
            const dash = circle.getTotalLength();
            circle.style.strokeDasharray = dash;
            circle.style.strokeDashoffset = dash;

            const goNext = () => {
                if (!autoplayOverlayActive) return;
                autoplayOverlayActive = false;
                overlay.remove();
                const urlParams = new URLSearchParams(window.location.search);
                const playlistId = urlParams.get('playlist');

                let url = window.VideoID 
                    ? window.VideoID.buildVideoUrl(nextVideo.name, playlistId)
                    : `youvi_video.html?name=${encodeURIComponent(nextVideo.name)}${playlistId ? `&playlist=${encodeURIComponent(playlistId)}` : ''}`;
                window.location.href = url;
            };

            const start = Date.now();
            autoplayTimer = setInterval(() => {
                if (!autoplayOverlayActive) {
                    clearInterval(autoplayTimer);
                    return;
                }
                const left = Math.ceil((10000 - (Date.now() - start)) / 1000);
                const countdownElement = document.getElementById('countdown');
                if (countdownElement) {
                    countdownElement.textContent = i18n.t('comments.autoplayCountdown', '  {n} ...').replace('{n}', Math.max(left, 0));
                }
                if (left <= 0) {
                    clearInterval(autoplayTimer);
                    if (autoplayEnabled && autoplayOverlayActive) {
                        goNext();
                    }
                }
            }, 200);

            document.getElementById('playNow').onclick = () => {
                clearInterval(autoplayTimer);
                goNext();
            };
            overlay.querySelector('.autoplay-play').onclick = () => {
                clearInterval(autoplayTimer);
                goNext();
            };

            document.getElementById('cancelAutoplay').onclick = () => {
                clearInterval(autoplayTimer);
                autoplayOverlayActive = false;
                circle.style.animation = 'none';
                overlay.remove();
                video.currentTime = 0;
                hasStarted = false;
                const overlayElement = document.getElementById('videoOverlay');
                if (overlayElement) {
                    overlayElement.style.display = 'flex';
                    overlayElement.style.opacity = '1';
                }
                playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-play-icon lucide-play"><path d="M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z"/></svg>';

                const videoClock = document.getElementById('videoClock');
                const videoLogo = document.getElementById('videoLogo');
                if (videoClock) videoClock.style.display = 'none';
                if (videoLogo) videoLogo.style.display = 'none';
            };
        }

        function updateVideoPreviewInUI(videoName, preview, duration) {
            document.querySelectorAll(`[data-video-name="${videoName}"]`).forEach(element => {
                const previewImg = element.querySelector('.video-preview, .playlist-thumb');
                if (previewImg && previewImg.tagName === 'IMG') {
                    previewImg.src = preview;
                }
            });
        }

        const metadataCache = new Map();
        let metadataCacheTimer = null;

        async function preloadFolderMetadata(dirHandle) {
            try {
                const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: false });
                const entries = [];

                for await (const [name, handle] of metaDir.entries()) {
                    if (name.endsWith('.meta.json')) {
                        entries.push({ name, handle });
                    }
                }

                const batchSize = 10;
                for (let i = 0; i < entries.length; i += batchSize) {
                    const batch = entries.slice(i, i + batchSize);
                    await Promise.all(batch.map(async ({ name, handle }) => {
                        try {
                            const file = await handle.getFile();
                            const content = await file.text();
                            const metadata = JSON.parse(content);
                            const videoName = name.replace('.meta.json', '');
                            metadataCache.set(videoName, metadata);
                        } catch (e) {
                            debug.warn('Failed to load metadata for:', name, e);
                        }
                    }));

                    if (i + batchSize < entries.length) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
            } catch (e) {
                debug.warn('Failed to preload metadata:', e);
            }
        }

        async function getVideoMetadataOptimized(dirHandle, fileName) {
            const cacheKey = `${dirHandle.name}_${fileName}`;

            if (metadataCache.has(fileName)) {
                return metadataCache.get(fileName);
            }

            const metadata = await getVideoMetadata(dirHandle, fileName);
            metadataCache.set(fileName, metadata);

            return metadata;
        }

        function clearMetadataCache() {
            metadataCache.clear();
        }

        function renderCarouselOptimized(containerId, videos, playlistId, videosPerPage = 6) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '';

            const fragment = document.createDocumentFragment();

            const visibleVideos = videos.slice(0, videosPerPage);

            visibleVideos.forEach((video, index) => {
                const videoElement = createVideoElement(video, index, playlistId);
                fragment.appendChild(videoElement);
            });

            container.appendChild(fragment);

            if (videos.length > videosPerPage) {
                addCarouselNavigation(container, videos, playlistId, videosPerPage);
            }
        }

        function createVideoElement(video, index, playlistId) {
            const div = document.createElement('div');
            div.className = 'video-item';
            div.setAttribute('data-video-name', video.name);

            div.innerHTML = `
                <div class="video-thumbnail">
                    <img src="${video.preview || 'placeholder.jpg'}" alt="${video.name}" class="video-preview">
                    <div class="video-duration">${video.duration || '0:00'}</div>
                </div>
                <div class="video-info">
                    <div class="video-title">${video.name}</div>
                    <div class="video-meta">${video.views || 0} ${i18n.t('video.views', 'views')}</div>
                </div>
            `;

            div.addEventListener('click', () => {
                const url = window.VideoID 
                    ? window.VideoID.buildVideoUrl(video.name, playlistId)
                    : `youvi_video.html?name=${encodeURIComponent(video.name)}&playlist=${encodeURIComponent(playlistId || '')}`;
                window.location.href = url;
            });

            return div;
        }

        function addCarouselNavigation(container, videos, playlistId, videosPerPage) {
            const nav = document.createElement('div');
            nav.className = 'carousel-navigation';

            const totalPages = Math.ceil(videos.length / videosPerPage);

            nav.innerHTML = `
                <button class="carousel-nav-btn prev-btn" data-playlist-id="${playlistId}" data-playlist-type="current"></button>
                <span class="carousel-page-info">1 / ${totalPages}</span>
                <button class="carousel-nav-btn next-btn" data-playlist-id="${playlistId}" data-playlist-type="current"></button>
            `;

            container.appendChild(nav);
        }

        function cancelAutoplayIfActive() {
            if (autoplayOverlayActive) {
                autoplayOverlayActive = false;
                if (autoplayTimer) {
                    clearInterval(autoplayTimer);
                    autoplayTimer = null;
                }
                const autoplayOverlay = document.querySelector('.autoplay-overlay');
                if (autoplayOverlay) {
                    autoplayOverlay.remove();
                }
            }
        }

        async function ensureHistoryBaseDir() {
            try { return await videoDirectoryHandle.getDirectoryHandle('.history', { create: true }); } catch (_) { return null; }
        }
        async function readHistoryJson(fileName, fallback) {
            try {
                const dir = await ensureHistoryBaseDir(); if (!dir) return fallback;

                let exists = false;
                for await (const [name] of dir.entries()) {
                    if (name === fileName) {
                        exists = true;
                        break;
                    }
                }
                if (!exists) return fallback;

                const fh = await dir.getFileHandle(fileName, { create: false });
                const f = await fh.getFile();
                return JSON.parse(await f.text());
            } catch (_) { return fallback; }
        }
        async function writeHistoryJson(fileName, data) {
            try {
                const dir = await ensureHistoryBaseDir(); if (!dir) return false;
                const fh = await dir.getFileHandle(fileName, { create: true });
                const w = await fh.createWritable();
                await w.write(JSON.stringify(data));
                await w.close();
                return true;
            } catch (_) { return false; }
        }
        async function loadFavorites() { return await readHistoryJson('favorites.json', []); }
        async function saveFavorites(arr) { return await writeHistoryJson('favorites.json', arr || []); }
        function buildVideoKey(name, playlist) { return `${playlist || ''}::${name}`; }
        function capturePreviewForFav(el) {
            try {
                const c = document.createElement('canvas'); const w = 320, h = 180; c.width = w; c.height = h;
                const cx = c.getContext('2d'); const vw = el.videoWidth || 1280, vh = el.videoHeight || 720; const ar = vw / vh;
                let dw = w, dh = h; if (w / h > ar) { dw = h * ar; dh = h; } else { dh = w / ar; dw = w; }
                cx.fillStyle = '#000'; cx.fillRect(0, 0, w, h);
                cx.drawImage(el, (w - dw) / 2, (h - dh) / 2, dw, dh);
                return c.toDataURL('image/jpeg', 0.7);
            } catch (_) { return null; }
        }




        // Store sorted data for lazy panel rendering
        let _sortedDanmakuData = [];
        let _danmakuRenderLimit = 200; // Initial render limit
        let _danmakuLoadMoreBtn = null;

        function renderDanmakuComments(danmakuData = []) {
            const commentsList = document.getElementById('danmakuCommentsList');
            const commentsCount = document.getElementById('danmakuCommentsCount');

            if (!commentsList || !commentsCount) return;

            commentsCount.textContent = danmakuData.length;
            commentsList.innerHTML = '';

            if (danmakuData.length === 0) {
                const noDanmaku = document.createElement('div');
                noDanmaku.textContent = i18n.t('comments.noDanmaku', 'No danmaku');
                noDanmaku.style.cssText = 'padding:10px;text-align:center;color:#666;font-size:12px;';
                commentsList.appendChild(noDanmaku);
                _sortedDanmakuData = [];
                updateDanmakuPanelOverlay([]);
                return;
            }

            // Sort once and cache
            _sortedDanmakuData = danmakuData.slice().sort((a, b) => a.time - b.time);

            // Render with limit for large datasets
            const renderCount = Math.min(_sortedDanmakuData.length, _danmakuRenderLimit);
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < renderCount; i++) {
                const comment = _sortedDanmakuData[i];
                fragment.appendChild(createDanmakuCommentElement(comment));
            }
            commentsList.appendChild(fragment);

            // Add "Load more" button if there are more items
            if (_sortedDanmakuData.length > renderCount) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'danmaku-load-more';
                loadMoreBtn.textContent = `  (${_sortedDanmakuData.length - renderCount} )`;
                loadMoreBtn.style.cssText = 'padding:12px;text-align:center;color:#ff69b4;cursor:pointer;font-size:13px;';
                loadMoreBtn.addEventListener('click', () => loadMoreDanmakuComments(commentsList, renderCount));
                commentsList.appendChild(loadMoreBtn);
                _danmakuLoadMoreBtn = loadMoreBtn;
            }

            // Update panel count without rendering items (lazy)
            const panelCount = document.getElementById('danmakuPanelCount');
            if (panelCount) {
                panelCount.textContent = `(${_sortedDanmakuData.length})`;
            }
            
            // Mark panel as needing re-render
            window._danmakuPanelNeedsRender = true;
        }

        function loadMoreDanmakuComments(commentsList, startIdx) {
            if (!_sortedDanmakuData.length) return;
            
            // Remove load more button
            if (_danmakuLoadMoreBtn) {
                _danmakuLoadMoreBtn.remove();
                _danmakuLoadMoreBtn = null;
            }

            const endIdx = Math.min(_sortedDanmakuData.length, startIdx + _danmakuRenderLimit);
            const fragment = document.createDocumentFragment();
            
            for (let i = startIdx; i < endIdx; i++) {
                const comment = _sortedDanmakuData[i];
                fragment.appendChild(createDanmakuCommentElement(comment));
            }
            commentsList.appendChild(fragment);

            // Add new "Load more" button if there are still more items
            if (_sortedDanmakuData.length > endIdx) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.className = 'danmaku-load-more';
                loadMoreBtn.textContent = `  (${_sortedDanmakuData.length - endIdx} )`;
                loadMoreBtn.style.cssText = 'padding:12px;text-align:center;color:#ff69b4;cursor:pointer;font-size:13px;';
                loadMoreBtn.addEventListener('click', () => loadMoreDanmakuComments(commentsList, endIdx));
                commentsList.appendChild(loadMoreBtn);
                _danmakuLoadMoreBtn = loadMoreBtn;
            }
        }

        function createDanmakuCommentElement(comment) {
            const commentElement = document.createElement('div');
            commentElement.className = 'danmaku-comment-item';
            commentElement.setAttribute('data-danmaku-id', comment.id);
            const ts = comment.created || comment.timestamp || null;
            const dateStr = ts ? new Date(ts).toLocaleDateString(undefined, { year: 'numeric', month: '2-digit', day: '2-digit' }) : '';
            commentElement.innerHTML = `
                <div class="danmaku-comment-header">
                    <div>
                        <span class="danmaku-comment-time">${formatDuration(comment.time)}</span>
                        <span class="danmaku-comment-text">${escapeHtml(comment.text)}</span>
                    </div>
                    ${dateStr ? `<span class="danmaku-comment-date">${dateStr}</span>` : ''}
                </div>
            `;

            commentElement.addEventListener('click', () => {
                let targetVideo = null;
                if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                    targetVideo = window.documentPiPManager.pipWindow.document.querySelector('video');
                } else {
                    targetVideo = video;
                }

                if (targetVideo && isFinite(comment.time)) {
                    if (window.abSegmentA !== null || window.abSegmentB !== null) {
                        window.abSegmentA = null;
                        window.abSegmentB = null;
                        window.abSegmentMode = 0;
                        if (typeof window.updateABMarkers === 'function') {
                            window.updateABMarkers();
                        }
                    }

                    if (typeof window.clearAllDanmaku === 'function') {
                        window.clearAllDanmaku();
                    }
                    targetVideo.currentTime = comment.time;
                    targetVideo.play();
                }
            });

            return commentElement;
        }

        function updateDanmakuPanelOverlay(sortedComments = []) {
            const panelList = document.getElementById('danmakuPanelList');
            const panelCount = document.getElementById('danmakuPanelCount');

            if (!panelList) return;

            if (panelCount) {
                panelCount.textContent = `(${sortedComments.length})`;
            }

            panelList.innerHTML = '';
            panelList._allComments = sortedComments; // Store for lazy loading
            panelList._renderedCount = 0;

            if (sortedComments.length === 0) {
                panelList.innerHTML = `<div class="danmaku-panel-empty">${i18n.t('comments.noDanmaku', 'No danmaku')}</div>`;
                return;
            }

            // Initial render
            renderMorePanelItems(panelList, 300);
            
            window._danmakuPanelNeedsRender = false;
        }

        function renderMorePanelItems(panelList, count) {
            const sortedComments = panelList._allComments;
            if (!sortedComments) return;
            
            const startIdx = panelList._renderedCount || 0;
            const endIdx = Math.min(sortedComments.length, startIdx + count);
            
            if (startIdx >= sortedComments.length) return; // Nothing more to render
            
            // Remove old "load more" message if exists
            const oldMore = panelList.querySelector('.danmaku-panel-more');
            if (oldMore) oldMore.remove();
            
            const fragment = document.createDocumentFragment();
            
            for (let i = startIdx; i < endIdx; i++) {
                const comment = sortedComments[i];
                const item = document.createElement('div');
                item.className = 'danmaku-panel-item';
                item.setAttribute('data-time', comment.time);
                item.setAttribute('data-index', i);
                item.innerHTML = `
                    <span class="danmaku-panel-time">${formatDuration(comment.time)}</span>
                    <span class="danmaku-panel-text">${escapeHtml(comment.text)}</span>
                `;

                item.addEventListener('click', () => {
                    let targetVideo = null;
                    if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                        targetVideo = window.documentPiPManager.pipWindow.document.querySelector('video');
                    } else {
                        targetVideo = document.getElementById('video');
                    }

                    if (targetVideo && isFinite(comment.time)) {
                        if (window.abSegmentA !== null || window.abSegmentB !== null) {
                            window.abSegmentA = null;
                            window.abSegmentB = null;
                            window.abSegmentMode = 0;
                            if (typeof window.updateABMarkers === 'function') {
                                window.updateABMarkers();
                            }
                        }

                        if (typeof window.clearAllDanmaku === 'function') {
                            window.clearAllDanmaku();
                        }
                        targetVideo.currentTime = comment.time;
                        targetVideo.play();
                    }
                });

                fragment.appendChild(item);
            }
            panelList.appendChild(fragment);
            panelList._renderedCount = endIdx;

            // Show "load more" if there are more items
            if (sortedComments.length > endIdx) {
                const moreMsg = document.createElement('div');
                moreMsg.className = 'danmaku-panel-more';
                moreMsg.style.cssText = 'padding:8px;text-align:center;color:#ff69b4;font-size:11px;cursor:pointer;';
                moreMsg.textContent = `+  ${sortedComments.length - endIdx}`;
                moreMsg.addEventListener('click', () => renderMorePanelItems(panelList, 300));
                panelList.appendChild(moreMsg);
            }
        }

        // Find index of item closest to given time using binary search
        function findDanmakuIndexByTime(sortedComments, targetTime) {
            if (!sortedComments || sortedComments.length === 0) return -1;
            
            let left = 0;
            let right = sortedComments.length - 1;
            
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                if (sortedComments[mid].time < targetTime) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            // Find closest item within 2 seconds
            const idx = left;
            if (idx < sortedComments.length && Math.abs(sortedComments[idx].time - targetTime) < 2) {
                return idx;
            }
            if (idx > 0 && Math.abs(sortedComments[idx - 1].time - targetTime) < 2) {
                return idx - 1;
            }
            
            return -1;
        }

        // Ensure items around target index are rendered
        function ensurePanelItemsRendered(panelList, targetIndex) {
            if (!panelList || !panelList._allComments) return false;
            
            const renderedCount = panelList._renderedCount || 0;
            
            // If target is beyond rendered items, render more
            if (targetIndex >= renderedCount) {
                const needToRender = targetIndex - renderedCount + 50; // Render 50 extra
                renderMorePanelItems(panelList, Math.max(needToRender, 200));
                return true;
            }
            
            return false;
        }

        (function() {
            const panelBtn = document.getElementById('danmakuPanelBtn');
            const panelOverlay = document.getElementById('danmakuPanelOverlay');
            const panelClose = document.getElementById('danmakuPanelClose');
            const panelList = document.getElementById('danmakuPanelList');

            if (!panelBtn || !panelOverlay) return;

            panelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = panelOverlay.classList.toggle('open');
                panelBtn.classList.toggle('active', isOpen);
                
                // Lazy render panel on first open
                if (isOpen && panelList) {
                    if (window._danmakuPanelNeedsRender && _sortedDanmakuData.length > 0) {
                        updateDanmakuPanelOverlay(_sortedDanmakuData);
                    }
                    if (window.DanmakuScrollSync) {
                        window.DanmakuScrollSync.syncPanelScrollPosition(panelList);
                    }
                }
            });

            if (panelClose) {
                panelClose.addEventListener('click', (e) => {
                    e.stopPropagation();
                    panelOverlay.classList.remove('open');
                    panelOverlay.classList.remove('expanded');
                    panelBtn.classList.remove('active');
                });
            }

            const panelFollow = document.getElementById('danmakuPanelFollow');

            if (panelFollow) {
                if (typeof window._danmakuFollowEnabled !== 'undefined') {
                    panelFollow.classList.toggle('active', window._danmakuFollowEnabled);
                }
                
                panelFollow.addEventListener('click', (e) => {
                    e.stopPropagation();
                    window._danmakuFollowEnabled = !window._danmakuFollowEnabled;
                    panelFollow.classList.toggle('active', window._danmakuFollowEnabled);
                    
                    const sidebarFollowBtn = document.getElementById('sidebarFollowBtn');
                    if (sidebarFollowBtn) {
                        sidebarFollowBtn.classList.toggle('active', window._danmakuFollowEnabled);
                    }
                });
            }

            panelOverlay.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            if (panelList) {
                panelList.addEventListener('wheel', (e) => {
                    e.stopPropagation();
                }, { passive: true });
            }

            document.addEventListener('fullscreenchange', () => {
                const isWidescreen = document.body.classList.contains('wide-screen-mode');
                if (!document.fullscreenElement && !document.body.classList.contains('cinema-mode') && !isWidescreen) {
                    if (window.DanmakuScrollSync) {
                        window.DanmakuScrollSync.savePanelScrollPosition();
                    }
                    panelOverlay.classList.remove('open');
                    panelOverlay.classList.remove('expanded');
                    panelBtn.classList.remove('active');
                }
            });

            const video = document.getElementById('video');
            if (video) {
                let lastHighlightTime = 0;
                video.addEventListener('timeupdate', () => {
                    if (!panelOverlay.classList.contains('open')) return;
                    
                    // Throttle highlight updates
                    const now = Date.now();
                    if (now - lastHighlightTime < 500) return;
                    lastHighlightTime = now;
                    
                    const currentTime = video.currentTime;
                    
                    // For follow mode with large datasets, use binary search
                    if (window._danmakuFollowEnabled && panelList && panelList._allComments) {
                        const targetIndex = findDanmakuIndexByTime(panelList._allComments, currentTime);
                        
                        if (targetIndex >= 0) {
                            // Ensure items around target are rendered
                            const wasRendered = ensurePanelItemsRendered(panelList, targetIndex);
                            
                            // Find the DOM element by index
                            const targetItem = panelList.querySelector(`[data-index="${targetIndex}"]`);
                            
                            if (targetItem) {
                                // Clear previous highlights
                                panelList.querySelectorAll('.danmaku-panel-item.current').forEach(el => {
                                    el.classList.remove('current');
                                });
                                
                                // Highlight current
                                targetItem.classList.add('current');
                                
                                // Scroll to item
                                const itemTop = targetItem.offsetTop;
                                const listHeight = panelList.clientHeight;
                                const itemHeight = targetItem.offsetHeight;
                                const scrollTarget = itemTop - (listHeight / 2) + (itemHeight / 2);
                                const behavior = (window._danmakuPanelSkipSmoothScroll || wasRendered) ? 'instant' : 'smooth';
                                panelList.scrollTo({ top: scrollTarget, behavior: behavior });
                                if (window._danmakuPanelSkipSmoothScroll) {
                                    window._danmakuPanelSkipSmoothScroll = false;
                                }
                                return;
                            }
                        }
                    }
                    
                    // Fallback: highlight visible items
                    let firstCurrentItem = null;
                    const items = panelOverlay.querySelectorAll('.danmaku-panel-item');
                    items.forEach(item => {
                        const time = parseFloat(item.getAttribute('data-time'));
                        const isCurrent = Math.abs(time - currentTime) < 2;
                        item.classList.toggle('current', isCurrent);
                        
                        if (isCurrent && !firstCurrentItem) {
                            firstCurrentItem = item;
                        }
                    });

                    if (window._danmakuFollowEnabled && firstCurrentItem && panelList && panelOverlay.classList.contains('open')) {
                        const itemTop = firstCurrentItem.offsetTop;
                        const listHeight = panelList.clientHeight;
                        const itemHeight = firstCurrentItem.offsetHeight;
                        const scrollTarget = itemTop - (listHeight / 2) + (itemHeight / 2);
                        const behavior = window._danmakuPanelSkipSmoothScroll ? 'instant' : 'smooth';
                        panelList.scrollTo({ top: scrollTarget, behavior: behavior });
                        if (window._danmakuPanelSkipSmoothScroll) {
                            window._danmakuPanelSkipSmoothScroll = false;
                        }
                    }
                });
            }
        })();

        async function loadDanmakuComments() {
            try {
                if (window.currentPlaylistHandle && window.currentVideoName) {
                    const metaDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = window.currentVideoName + '.danmaku.json';
                    const loadedData = await window.readJSONFile(metaDir, fileName, []);
                    renderDanmakuComments(loadedData);
                }
            } catch (e) {
                debug.warn('Could not load danmaku comments:', e);
            }
        }

        async function clearDanmakuComments() {
            try {
                if (window.currentPlaylistHandle && window.currentVideoName) {
                    const metaDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = window.currentVideoName + '.danmaku.json';
                    await window.writeJSONFile(metaDir, fileName, []);
                    renderDanmakuComments([]);
                }
            } catch (e) {
                debug.warn('Could not clear danmaku comments:', e);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            loadDanmakuComments();
        });

        window.refreshDanmakuComments = function () {
            loadDanmakuComments();
        };

        window.addDanmakuComment = addDanmakuComment;

        function addDanmakuComment(danmakuItem) {
            const commentsList = document.getElementById('danmakuCommentsList');
            const commentsCount = document.getElementById('danmakuCommentsCount');

            if (!commentsList || !commentsCount) return;

            const existingComment = commentsList.querySelector(`[data-danmaku-id="${danmakuItem.id}"]`);
            if (existingComment) {
                return;
            }

            const noDanmakuMessage = commentsList.querySelector('.danmaku-panel-empty, div:not([data-danmaku-id])');
            if (noDanmakuMessage && !noDanmakuMessage.hasAttribute('data-danmaku-id')) {
                noDanmakuMessage.remove();
            }

            const commentElement = document.createElement('div');
            commentElement.className = 'danmaku-comment-item';
            commentElement.setAttribute('data-danmaku-id', danmakuItem.id);
            commentElement.innerHTML = `
                <div>
                    <span class="danmaku-comment-time">${formatDuration(danmakuItem.time)}</span>
                    <span class="danmaku-comment-text">${escapeHtml(danmakuItem.text)}</span>
                </div>
                <div class="danmaku-comment-meta">${escapeHtml(danmakuItem.color || '#ffffff')} | ${escapeHtml(danmakuItem.size || 'normal')} | ${escapeHtml(danmakuItem.position || 'scroll')}</div>
            `;

            commentElement.addEventListener('click', () => {
                let targetVideo = null;
                if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                    targetVideo = window.documentPiPManager.pipWindow.document.querySelector('video');
                } else {
                    targetVideo = video;
                }

                if (targetVideo && isFinite(danmakuItem.time)) {
                    if (typeof window.clearAllDanmaku === 'function') {
                        window.clearAllDanmaku();
                    }
                    targetVideo.currentTime = danmakuItem.time;
                    targetVideo.play();
                }
            });

            const existingComments = Array.from(commentsList.children);
            let insertIndex = existingComments.length;

            for (let i = 0; i < existingComments.length; i++) {
                const timeEl = existingComments[i].querySelector('.danmaku-comment-time');
                if (!timeEl) continue;
                const existingTime = parseFloat(timeEl.textContent.split(':').reduce((acc, time) => (60 * acc) + +time));
                if (danmakuItem.time < existingTime) {
                    insertIndex = i;
                    break;
                }
            }

            if (insertIndex === existingComments.length) {
                commentsList.appendChild(commentElement);
            } else {
                commentsList.insertBefore(commentElement, existingComments[insertIndex]);
            }

            if (commentsCount) {
                commentsCount.textContent = commentsList.children.length;
            }
        }

        const originalSendDanmaku = document.getElementById('sendDanmaku');
        if (originalSendDanmaku) {
            originalSendDanmaku.addEventListener('click', async () => {
                setTimeout(() => {
                    loadDanmakuComments();
                }, 100);
            });
        }

        const danmakuTextInput = document.getElementById('danmakuText');
        if (danmakuTextInput) {
            danmakuTextInput.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    if (originalSendDanmaku) {
                        originalSendDanmaku.click();
                    }
                }
            });
        }



        async function setupSubscriptionButton() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (!subscribeBtn || !window.currentChannelName) return;

            try {
                let subscriptions = await loadSubscriptionsFromFile();
                let db = null;

                if (!subscriptions) {
                    db = await openDB();
                    subscriptions = await getFromDB(db, 'subscriptions') || [];
                }

                if (!Array.isArray(subscriptions)) {
                    subscriptions = [];
                }

                const isSubscribed = subscriptions.includes(window.currentChannelName);
                debug.log('Current channel:', window.currentChannelName, 'Is subscribed:', isSubscribed);

                if (isSubscribed) {
                    subscribeBtn.textContent = i18n.t('video.subscribed', 'Subscribed');
                    subscribeBtn.classList.add('subscribed');
                } else {
                    subscribeBtn.textContent = i18n.t('video.subscribe', 'Subscribe');
                    subscribeBtn.classList.remove('subscribed');
                }

                let currentSubscriptionState = isSubscribed;

                subscribeBtn.addEventListener('click', async () => {
                    try {
                        debug.log('Subscription button clicked. Current state:', currentSubscriptionState);

                        if (!db) {
                            debug.log('Creating new database connection...');
                            db = await openDB();
                        }

                        if (!subscriptions || !Array.isArray(subscriptions)) {
                            subscriptions = await loadSubscriptionsFromFile() || [];
                            if (!Array.isArray(subscriptions)) {
                                subscriptions = [];
                            }
                        }

                        if (currentSubscriptionState) {
                            debug.log('Unsubscribing from channel:', window.currentChannelName);
                            const index = subscriptions.indexOf(window.currentChannelName);
                            if (index > -1) {
                                subscriptions.splice(index, 1);
                                debug.log('Updated subscriptions list after unsubscribe:', subscriptions);

                                await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);

                                subscribeBtn.textContent = i18n.t('video.subscribe', 'Subscribe');
                                subscribeBtn.classList.remove('subscribed');
                                currentSubscriptionState = false;

                                await renderSubscribedChannelsList();
                            }
                        } else {
                            debug.log('Subscribing to channel:', window.currentChannelName);
                            if (!subscriptions.includes(window.currentChannelName)) {
                                subscriptions.push(window.currentChannelName);
                            }
                            debug.log('Updated subscriptions list after subscribe:', subscriptions);

                            await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);

                            subscribeBtn.textContent = i18n.t('video.subscribed', 'Subscribed');
                            subscribeBtn.classList.add('subscribed');
                            currentSubscriptionState = true;

                            await renderSubscribedChannelsList();
                        }
                    } catch (e) {
                        debug.error('Error updating subscription:', e);
                    }
                });
            } catch (e) {
                debug.error('Error setting up subscription button:', e);
                subscribeBtn.textContent = i18n.t('video.subscribe', 'Subscribe');
                subscribeBtn.classList.remove('subscribed');
            }
        }
        async function loadSubscriptionsFromFile() {
            try {
                const localSubscriptions = localStorage.getItem('8site_subscriptions');
                if (localSubscriptions && localSubscriptions !== 'null' && localSubscriptions !== 'undefined') {
                    const parsed = JSON.parse(localSubscriptions);
                    if (Array.isArray(parsed)) {
                        return parsed;
                    }
                }

                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
                        const file = await subscriptionsFile.getFile();
                        const text = await file.text();
                        const fileSubscriptions = JSON.parse(text);

                        if (Array.isArray(fileSubscriptions)) {
                            localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
                            return fileSubscriptions;
                        }
                    } catch (fileError) {
                        debug.log('Could not load from .subscriptions.json:', fileError.message);
                    }
                }

                return [];
            } catch (e) {
                debug.error('Error loading subscriptions:', e);
                return [];
            }
        }

        const avatarCache = new Map();
        const MAX_CACHE_SIZE = 100;
        const CACHE_TTL = 5 * 60 * 1000;

        function cleanupAvatarCache() {
            const now = Date.now();
            for (let [key, value] of avatarCache) {
                if (now - value.timestamp > CACHE_TTL) {
                    if (value.url && value.url.startsWith('blob:')) {
                        URL.revokeObjectURL(value.url);
                    }
                    avatarCache.delete(key);
                }
            }
            if (avatarCache.size > MAX_CACHE_SIZE) {
                const entries = [...avatarCache.entries()];
                const toRemove = entries.slice(0, entries.length - MAX_CACHE_SIZE);
                toRemove.forEach(([key, value]) => {
                    if (value.url && value.url.startsWith('blob:')) {
                        URL.revokeObjectURL(value.url);
                    }
                    avatarCache.delete(key);
                });
            }
        }

        async function loadChannelAvatar(channelName) {
            const cacheKey = `avatar_${channelName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
                if (cached.url && cached.url.startsWith('blob:')) {
                    URL.revokeObjectURL(cached.url);
                }
                avatarCache.delete(cacheKey);
            }

            try {
                if (window.channelsDir) {
                    const channelDir = await window.channelsDir.getDirectoryHandle(channelName, { create: false });
                    const channelData = await readJSONFile(channelDir, 'channel.json', {});

                    if (channelData.avatar) {
                        const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                        if (avatarUrl) {
                            avatarCache.set(cacheKey, {
                                url: avatarUrl,
                                timestamp: Date.now()
                            });
                            return avatarUrl;
                        }
                    }
                }
            } catch (e) {
                debug.log('Could not read channel.json for', channelName, e);
            }

            return null;
        }

        async function renderSubscribedChannelsList() {
            const sidebarContainer = document.getElementById('subscribedChannelsContainer');
            if (!sidebarContainer) return;

            try {
                const savedSubscriptions = await loadSubscriptionsFromFile();
                const subscribedChannels = Array.isArray(savedSubscriptions) ? savedSubscriptions : [];

                sidebarContainer.innerHTML = '';

                if (subscribedChannels.length === 0) {
                    const noSubs = document.createElement('div');
                    noSubs.className = 'sidebar-item';
                    noSubs.textContent = ' ';
                    noSubs.style.fontStyle = 'italic';
                    noSubs.style.color = '#999';
                    sidebarContainer.appendChild(noSubs);
                    return;
                }

                subscribedChannels.forEach((channelName, index) => {
                    const link = document.createElement('a');
                    link.href = '#';
                    link.className = 'sidebar-item';
                    link.dataset.channel = channelName;
                    link.id = `sidebar_channel_${index}`;
                    link.style.display = 'flex';
                    link.style.alignItems = 'center';
                    link.style.gap = '8px';

                    const avatar = document.createElement('div');
                    avatar.style.cssText = `
                        width: 20px;
                        height: 20px;
                        border-radius: 0;
                        background: #ff69b4;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 10px;
                        flex-shrink: 0;
                        background-size: cover;
                        background-position: center;
                        background-repeat: no-repeat;
                        cursor: pointer;
                    `;
                    avatar.textContent = channelName.charAt(0).toUpperCase();
                    avatar.title = '  ';

                    const textSpan = document.createElement('span');
                    textSpan.textContent = channelName;
                    textSpan.style.overflow = 'hidden';
                    textSpan.style.textOverflow = 'ellipsis';
                    textSpan.style.whiteSpace = 'nowrap';
                    textSpan.style.flex = '1';

                    link.appendChild(avatar);
                    link.appendChild(textSpan);

                    avatar.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
                    });

                    textSpan.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
                    });

                    loadChannelAvatar(channelName).then(avatarUrl => {
                        if (avatarUrl) {
                            avatar.style.backgroundImage = `url(${avatarUrl})`;
                            avatar.textContent = '';
                        }
                    }).catch(() => {
                    });

                    sidebarContainer.appendChild(link);
                });
            } catch (e) {
                debug.error('Error loading subscriptions:', e);
                sidebarContainer.innerHTML = '<div class="sidebar-item" style="font-style: italic; color: #999;"> </div>';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            renderSubscribedChannelsList();
        });

    </script>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <img src="images/logo_youvi_ind_ex.png" alt="Youvi" loading="lazy">
                    <p data-i18n="footer.description">    . ,    .</p>
                </div>
                <div class="footer-sections">
                    <div class="footer-section">
                        <h3 data-i18n="footer.sections"></h3>
                        <ul>
                            <li><a href="youvi_main.html" data-i18n="footer.video"></a></li>
                            <li><a href="youvi_tags.html" data-i18n="footer.tags"></a></li>
                            <li><a href="youvi_feed_all.html">Feed</a></li>
                            <li><a href="index.html" data-i18n="footer.management"></a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="sidebar.library"></h3>
                        <ul>
                            <li><a href="youvi_ch_list.html" data-i18n="footer.channels"></a></li>
                            <li><a href="youvi_playlists_list.html" data-i18n="footer.playlists"></a></li>
                            <li><a href="youvi_subscriptions.html" data-i18n="footer.subscriptions"></a></li>
                            <li><a href="youvi_fav.html" data-i18n="footer.favorites"></a></li>
                            <li><a href="youvi_history.html" data-i18n="footer.history"></a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="nav.wiki">Wiki</h3>
                        <ul>
                            <li><a href="wiki/index.html" data-i18n="footer.home"></a></li>
                            <li><a href="wiki/player.html" data-i18n="footer.wiki.player"></a></li>
                            <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku"></a></li>
                            <li><a href="wiki/tags/general.html" data-i18n="footer.tags"></a></li>
                            <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules"> </a></li>
                            <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search"></a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.pgc">PGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
                            <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
                            <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
                            <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
                            <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.ugc">UGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
                            <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
                            <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
                            <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
                            <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
                            <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
                            <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.aboutSite"> </h3>
                        <ul>
                            <li><a href="wiki/about.html" data-i18n="footer.about"> </a></li>
                            <li><a href="wiki/docs.html" data-i18n="footer.docs"></a></li>
                            <li><a href="wiki/tech.html" data-i18n="footer.technologies"></a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="footer-right">
                <div class="footer-mascot">
                    <img src="images/mascot1.png" alt="Yuvi" loading="lazy">
                </div>
            </div>
        </div>
        <div class="footer-bottom">

        </div>
    </footer>

    <!-- Hotkeys Popover (Youvi) -->
    <div id="hotkeysPopoverYouvi"
        style="display:none;position:fixed;z-index:2000;min-width:420px;max-width:640px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.2);padding:10px 12px;">
        <button id="hotkeysYouviClose"
            style="position:absolute;top:6px;right:6px;background:transparent;border:none;color:#999;font-size:16px;width:26px;height:26px;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;"></button>
        <div style="padding-top:6px;max-height:60vh;overflow:auto;">
            <div class="hotkeys-section" style="margin-bottom:12px;">
                <h4 style="margin:0 0 6px 0;font-size:13px;color:#ff69b4;font-weight:600;text-transform:uppercase;" data-i18n="hotkeys.playback">Navigation and Playback</h4>
                <div class="hotkey-item"><span class="hotkey-key">Space / K</span>  <span data-i18n="hotkeys.playPause">Play/Pause</span></div>
                <div class="hotkey-item"><span class="hotkey-key">J / L</span>  <span data-i18n="hotkeys.seek10">Back/Forward 10 sec</span></div>
                <div class="hotkey-item"><span class="hotkey-key"> / </span>  <span data-i18n="hotkeys.seek5">Back/Forward 5 sec</span></div>
                <div class="hotkey-item"><span class="hotkey-key">09</span>  <span data-i18n="hotkeys.seekPercent">Jump to percentage</span></div>
                <div class="hotkey-item"><span class="hotkey-key">M</span>  <span data-i18n="hotkeys.mute">Mute/Unmute</span></div>
                <div class="hotkey-item"><span class="hotkey-key"> / </span>  <span data-i18n="hotkeys.volume">Volume 5%</span></div>
                <div class="hotkey-item"><span class="hotkey-key">F</span>  <span data-i18n="hotkeys.fullscreen">Fullscreen</span></div>
                <div class="hotkey-item"><span class="hotkey-key">T</span>  <span data-i18n="hotkeys.cinema">Cinema mode</span></div>
                <div class="hotkey-item"><span class="hotkey-key">W</span>  <span data-i18n="hotkeys.widescreen">Widescreen mode</span></div>
                <div class="hotkey-item"><span class="hotkey-key">Q</span>  <span data-i18n="hotkeys.pip">Picture-in-Picture</span></div>
                <div class="hotkey-item"><span class="hotkey-key">R</span>  <span data-i18n="hotkeys.fitMode">Change video fit mode</span></div>
            </div>
            <div class="hotkeys-section" style="margin-bottom:12px;">
                <h4 style="margin:0 0 6px 0;font-size:13px;color:#ff69b4;font-weight:600;text-transform:uppercase;" data-i18n="hotkeys.zoomPan">Zoom and Pan</h4>
                <div class="hotkey-item"><span class="hotkey-key">P</span>  <span data-i18n="hotkeys.zoomIn">Zoom in</span></div>
                <div class="hotkey-item"><span class="hotkey-key">O</span>  <span data-i18n="hotkeys.zoomOut">Zoom out</span></div>
                <div class="hotkey-item"><span class="hotkey-key">Shift + W/S/A/D</span>  <span data-i18n="hotkeys.pan">Pan Up/Down/Left/Right</span></div>
                <div class="hotkey-item"><span class="hotkey-key">Shift + I</span>  <span data-i18n="hotkeys.resetZoom">Reset zoom and position</span></div>
            </div>
            <div class="hotkeys-section" style="margin-bottom:0;">
                <h4 style="margin:0 0 6px 0;font-size:13px;color:#ff69b4;font-weight:600;text-transform:uppercase;" data-i18n="hotkeys.interface">Interface</h4>
                <div class="hotkey-item"><span class="hotkey-key">D</span>  <span data-i18n="hotkeys.danmaku">Danmaku on/off</span></div>
                <div class="hotkey-item"><span class="hotkey-key">Shift + W</span>  <span data-i18n="hotkeys.danmakuPrint">Danmaku print (cinema/fullscreen)</span></div>
                <div class="hotkey-item"><span class="hotkey-key">C</span>  <span data-i18n="hotkeys.subtitles">Subtitles on/off</span></div>
                <div class="hotkey-item"><span class="hotkey-key">H</span>  <span data-i18n="hotkeys.clock">Clock on/off</span></div>
                <div class="hotkey-item"><span class="hotkey-key">V</span>  <span data-i18n="hotkeys.logo">Logo on/off</span></div>
                <div class="hotkey-item"><span class="hotkey-key">X</span>  <span data-i18n="hotkeys.danmakuForm">Show/hide danmaku form (fullscreen only)</span></div>
            </div>
            <div class="hotkeys-section" style="margin-top:12px;margin-bottom:0;">
                <h4 style="margin:0 0 6px 0;font-size:13px;color:#ff69b4;font-weight:600;text-transform:uppercase;">Multiview</h4>
                <div class="hotkey-item"><span class="hotkey-key">N</span>  <span data-i18n="hotkeys.multiviewToggle">Open/Close Multiview</span></div>
                <div class="hotkey-item"><span class="hotkey-key">F</span>  <span data-i18n="hotkeys.multiviewFullscreen">Fullscreen (in Multiview)</span></div>
                <div class="hotkey-item"><span class="hotkey-key">Esc</span>  <span data-i18n="hotkeys.multiviewClose">Close Multiview</span></div>
            </div>
        </div>
    </div>
    <style>
        #hotkeysPopoverYouvi {
            background: #f9f9f9;
            border: 1px solid #eaeaea;
            color: #333;
        }

        #hotkeysPopoverYouvi .hotkeys-section {
            line-height: 1.35;
        }

        #hotkeysPopoverYouvi .hotkey-item {
            font-size: 13px;
            color: #444;
            margin: 3px 0;
        }

        #hotkeysPopoverYouvi .hotkey-key {
            display: inline-block;
            min-width: 82px;
            padding: 2px 6px;
            border: 1px solid #e6e6e6;
            border-radius: 4px;
            font-size: 12px;
            margin-right: 8px;
            color: #111;
            background: #fff;
        }

        body.dark-theme #hotkeysPopoverYouvi {
            background: #1c1c1c;
            border: 1px solid #333;
            color: #ddd;
        }

        body.dark-theme #hotkeysPopoverYouvi .hotkeys-section h4 {
            color: #ff8aba !important;
        }

        body.dark-theme #hotkeysPopoverYouvi .hotkey-item {
            color: #ccc;
        }

        body.dark-theme #hotkeysPopoverYouvi .hotkey-key {
            border-color: #444;
            color: #fff;
            background: #262626;
        }

        #hotkeysYouviClose {
            color: #777;
        }

        body.dark-theme #hotkeysYouviClose {
            color: #bbb;
        }
    </style>
    <script>
        (function () {
            const hotkeysLink = document.getElementById('hotkeysBtn');
            const pop = document.getElementById('hotkeysPopoverYouvi');
            const closeBtn = document.getElementById('hotkeysYouviClose');
            function positionPopover() {
                if (!hotkeysLink || !pop) return;
                const rect = hotkeysLink.getBoundingClientRect();
                const prefersUp = (rect.top > pop.offsetHeight + 16);
                const top = prefersUp ? (rect.top - pop.offsetHeight - 8) : (rect.bottom + 8);
                const left = Math.min(rect.left, window.innerWidth - pop.offsetWidth - 8);
                pop.style.top = Math.max(8, top) + 'px';
                pop.style.left = left + 'px';
            }
            if (hotkeysLink && pop) {
                hotkeysLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    pop.style.display = (pop.style.display === 'block') ? 'none' : 'block';
                    if (pop.style.display === 'block') {
                        positionPopover();
                        window.addEventListener('resize', positionPopover, { passive: true });
                        window.addEventListener('scroll', positionPopover, { passive: true });
                    }
                });
            }
            if (closeBtn && pop) {
                closeBtn.addEventListener('click', () => {
                    pop.style.display = 'none';
                });
            }
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && pop && pop.style.display === 'block') {
                    pop.style.display = 'none';
                }
            });
        })();
        
        (function() {
            const mvHeaderBtn = document.getElementById('multiviewHeaderBtn');
            if (mvHeaderBtn) {
                mvHeaderBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (document.fullscreenElement || document.webkitFullscreenElement) return;
                    if (window.Multiview) {
                        window.Multiview.toggle();
                    }
                });
            }
        })();
    </script>

    <!-- Danmaku Script -->
    <script src="player/danmaku/danmaku.js"></script>
    <!-- Drag-to-Seek Script -->
    <script src="player/drag-seek/drag-seek.js"></script>
    <!-- Multi-Audio Track Manager -->
    <script src="player/multi-audio/multi-audio.js"></script>
    <script>
        (function initMultiAudio() {
            debug.log('[MultiAudio Init] Starting initialization...');

            const video = document.getElementById('video');
            if (!video) {
                debug.warn('[MultiAudio Init] Video element not found');
                return;
            }

            let multiAudioManager = null;
            let initAttempts = 0;
            const maxAttempts = 50;

            function attemptInit() {
                initAttempts++;
                debug.log(`[MultiAudio Init] Attempt ${initAttempts}/${maxAttempts}...`);

                if (typeof MultiAudioTrackManager === 'undefined') {
                    if (initAttempts < maxAttempts) {
                        debug.log('[MultiAudio Init] MultiAudioTrackManager not ready yet, retrying...');
                        setTimeout(attemptInit, 100);
                        return;
                    } else {
                        debug.error('[MultiAudio Init] Failed to load MultiAudioTrackManager after', maxAttempts, 'attempts');
                        debug.error('[MultiAudio Init] Check if player/multi-audio/multi-audio.js is loading correctly');
                        return;
                    }
                }

                try {
                    debug.log('[MultiAudio Init] Creating MultiAudioTrackManager instance...');
                    multiAudioManager = new MultiAudioTrackManager(video);
                    debug.log('[MultiAudio Init] Manager created successfully');
                    setupMultiAudio();
                } catch (error) {
                    debug.error('[MultiAudio Init] Failed to create manager:', error);
                    return;
                }
            }

            function setupMultiAudio() {
                if (!multiAudioManager) {
                    debug.error('[MultiAudio Init] Manager not created, cannot setup');
                    return;
                }

                debug.log('[MultiAudio Init] Setting up multi-audio integration...');

                async function checkAudioTracksForCurrentVideo() {
                    debug.log('[MultiAudio] checkAudioTracksForCurrentVideo called');

                    debug.log('[MultiAudio] Waiting for FFmpeg to be ready...');
                    let waitAttempts = 0;
                    while (!multiAudioManager.state.loaded && waitAttempts < 100) {
                        await new Promise(r => setTimeout(r, 100));
                        waitAttempts++;
                    }

                    if (!multiAudioManager.state.loaded) {
                        debug.error('[MultiAudio] FFmpeg failed to load after 10 seconds');
                        multiAudioManager.createUI();
                        return;
                    }

                    debug.log('[MultiAudio] FFmpeg is ready! Creating UI...');

                    multiAudioManager.createUI();

                    if (!window.currentVideo || !window.currentVideo.file) {
                        debug.log('[MultiAudio] No video loaded yet');
                        return;
                    }

                    const videoFile = window.currentVideo.file;
                    const videoName = videoFile.name;

                    debug.log('[MultiAudio] Checking audio tracks for:', videoName);

                    if (!videoName.toLowerCase().endsWith('.mkv')) {
                        debug.log('[MultiAudio] Not an MKV file, skipping multi-audio analysis');
                        return;
                    }

                    debug.log('[MultiAudio] FFmpeg is ready! Proceeding with analysis...');

                    try {
                        multiAudioManager.originalVideoFile = videoFile;
                        multiAudioManager.videoFileName = videoName;

                        if (window.currentVideo.dirHandle) {
                            try {
                                multiAudioManager.tracksDirectoryHandle = await window.currentVideo.dirHandle.getDirectoryHandle('.tracks', { create: true });
                                debug.log('[MultiAudio] Tracks directory initialized (.tracks/ - created if not exists)');
                            } catch (e) {
                                debug.warn('[MultiAudio] Cannot create .tracks/ directory:', e);
                                debug.log('[MultiAudio] Will use IndexedDB cache only');
                            }
                        } else {
                            debug.log('[MultiAudio] No directory handle available, will use IndexedDB cache only');
                        }

                        debug.log('[MultiAudio] Starting FFmpeg analysis...');
                        await multiAudioManager.analyzeAudioTracks(videoFile);

                        debug.log('[MultiAudio] Analysis complete, audio menu should now be visible in settings');

                    } catch (error) {
                        debug.error('[MultiAudio] Failed to check tracks:', error);
                    }
                }



                window.multiAudioManager = multiAudioManager;
                window.checkAudioTracksForCurrentVideo = checkAudioTracksForCurrentVideo;

                const multiAudioLoadedHandler = async () => {
                    debug.log('[MultiAudio] Video loadedmetadata event fired');

                    if (multiAudioManager.revokeAllBlobURLs) {
                        multiAudioManager.revokeAllBlobURLs();
                    }

                    if (multiAudioManager.cleanupFFmpegFS) {
                        await multiAudioManager.cleanupFFmpegFS();
                    }

                    if (multiAudioManager.syncInterval) {
                        clearInterval(multiAudioManager.syncInterval);
                        multiAudioManager.syncInterval = null;
                    }

                    if (multiAudioManager.syncListeners) {
                        multiAudioManager.syncListeners.forEach(({ event, handler }) => {
                            video.removeEventListener(event, handler);
                        });
                        multiAudioManager.syncListeners = [];
                    }

                    if (multiAudioManager.audioElements) {
                        multiAudioManager.audioElements.forEach(audio => {
                            if (audio) {
                                audio.pause();
                                audio.remove();
                            }
                        });
                    }

                    multiAudioManager.audioTracks = [];
                    multiAudioManager.audioElements = [];
                    multiAudioManager.currentAudioIndex = 0;

                    await checkAudioTracksForCurrentVideo();
                };

                video.removeEventListener('loadedmetadata', multiAudioLoadedHandler);
                video.addEventListener('loadedmetadata', multiAudioLoadedHandler);

                debug.log('[MultiAudio] Setup complete');
            }

            attemptInit();
        })();
    </script>
    
    <!-- Subtitle Track Manager -->
    <script src="player/subtitles/subtitles.js"></script>
    <script>
        (function initSubtitles() {
            debug.log('[Subtitles Init] Starting initialization...');

            const video = document.getElementById('video');
            if (!video) {
                debug.warn('[Subtitles Init] Video element not found');
                return;
            }

            let subtitleManager = null;
            let initAttempts = 0;
            const maxAttempts = 50;

            function attemptInit() {
                initAttempts++;
                debug.log(`[Subtitles Init] Attempt ${initAttempts}/${maxAttempts}...`);

                if (typeof SubtitleTrackManager === 'undefined') {
                    if (initAttempts < maxAttempts) {
                        setTimeout(attemptInit, 100);
                        return;
                    } else {
                        debug.error('[Subtitles Init] Failed to load SubtitleTrackManager');
                        return;
                    }
                }

                try {
                    debug.log('[Subtitles Init] Creating SubtitleTrackManager instance...');
                    subtitleManager = new SubtitleTrackManager(video);
                    debug.log('[Subtitles Init] Manager created successfully');
                    setupSubtitles();
                } catch (error) {
                    debug.error('[Subtitles Init] Failed to create manager:', error);
                }
            }

            function setupSubtitles() {
                if (!subtitleManager) return;

                debug.log('[Subtitles Init] Setting up subtitle integration...');

                subtitleManager.createUI();

                async function checkSubtitlesForCurrentVideo() {
                    debug.log('[Subtitles] checkSubtitlesForCurrentVideo called');

                    subtitleManager.stopSubtitleDisplay();
                    subtitleManager.clearSubtitles();
                    subtitleManager.subtitleTracks = [];
                    subtitleManager.currentSubtitleIndex = -1;
                    subtitleManager.state.totalTracks = 0;

                    if (!window.currentVideo || !window.currentVideo.file) {
                        debug.log('[Subtitles] No video loaded yet');
                        subtitleManager.updateMenuOptions();
                        return;
                    }

                    const videoFile = window.currentVideo.file;
                    const videoName = videoFile.name;
                    subtitleManager.videoFileName = videoName;

                    debug.log('[Subtitles] Checking subtitles for:', videoName);

                    if (window.currentVideo.dirHandle) {
                        await subtitleManager.initSubsDirectory(window.currentVideo.dirHandle);
                        
                        await subtitleManager.checkExternalSubtitles(
                            window.currentVideo.dirHandle, 
                            videoName
                        );
                    }

                    if (videoName.toLowerCase().endsWith('.mkv')) {
                        let waitAttempts = 0;
                        while (!subtitleManager.state.loaded && waitAttempts < 100) {
                            await new Promise(r => setTimeout(r, 100));
                            waitAttempts++;
                        }

                        if (subtitleManager.state.loaded) {
                            debug.log('[Subtitles] Analyzing MKV for embedded subtitles...');
                            await subtitleManager.analyzeSubtitleTracks(videoFile);
                        }
                    }

                    subtitleManager.updateUI();
                    debug.log('[Subtitles] Check complete, found', subtitleManager.subtitleTracks.length, 'tracks');
                }

                window.subtitleManager = subtitleManager;
                window.checkSubtitlesForCurrentVideo = checkSubtitlesForCurrentVideo;

                const subtitleLoadedHandler = async () => {
                    debug.log('[Subtitles] Video loadedmetadata event fired');
                    await checkSubtitlesForCurrentVideo();
                };

                video.removeEventListener('loadedmetadata', subtitleLoadedHandler);
                video.addEventListener('loadedmetadata', subtitleLoadedHandler);

                debug.log('[Subtitles] Setup complete');
            }

            attemptInit();
        })();
    </script>
    <script>
        function loadCommentsSystem() {
            loadEmbeddedCommentsSystem();
        }

        function loadEmbeddedCommentsSystem() {
            const commentsContainer = document.getElementById('commentsContainer');
            if (!commentsContainer) return;

            commentsContainer.innerHTML = `
                <div class="comments-section">
                    <div class="comments-header">
                        <h3 class="comments-title"><span data-i18n="comments.comments"></span> (<span id="commentsCount">0</span>)</h3>
                        <div class="comments-sort-wrap">
                            <label for="commentsSort" class="comments-sort-label" data-i18n="comments.sorting">:</label>
                            <select id="commentsSort" class="comments-sort">
                                <option value="new" data-i18n="comments.sortNew"></option>
                                <option value="old" data-i18n="comments.sortOld"></option>
                                <option value="best" data-i18n="comments.sortBest"></option>
                                <option value="worst" data-i18n="comments.sortWorst"></option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="comment-input">
                        <input type="text" id="nickInput" data-i18n-placeholder="comments.enterNick" placeholder="     (/ka)  ..." />
                        
                        <textarea class="simple-editor" id="commentText" data-i18n-placeholder="comments.addComment" placeholder=" ..."></textarea>
                        
                        <input type="file" id="imageFileInput" accept="image/*" style="display:none" multiple>
                        <div id="mainCommentImagePreview" class="comment-image-preview" style="display:none;"></div>
                        
                        <div class="comment-actions" style="box-shadow:none; display: flex; align-items: center; gap: 8px; justify-content: space-between;">
                            <button type="button" id="insertImageBtn" class="reply-image-btn" data-i18n-title="comments.addImage" title="Add image" style="background: none; border: 1px solid #ddd; padding: 8px; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                                </svg>
                            </button>
                            <button type="button" id="insertKaomojiBtn" class="reply-image-btn" data-i18n-title="comments.insertKaomoji" title="Add kaomoji" style="background: none; border: 1px solid #ddd; padding: 8px; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 14px;">
                                (^^)
                            </button>
                            <button class="subscribe-btn" id="postComment" style="box-shadow:none; margin-left: auto;" data-i18n="comments.send"></button>
                        </div>
                    </div>
                    
                    <div id="commentsList" class="comments-list"></div>
                </div>
                
                
                <div id="imageModal" class="modal">
                    <span class="close">&times;</span>
                    <div class="modal-content">
                        <img id="modalImage" src="" alt="">
                    </div>
                </div>
            `;

            initEmbeddedComments();
        }

        function initEmbeddedComments() {
            const postCommentBtn = document.getElementById('postComment');
            const commentText = document.getElementById('commentText');
            const nickInput = document.getElementById('nickInput');

            if (postCommentBtn) {
                postCommentBtn.addEventListener('click', addComment);
            }


            if (commentText) {
                commentText.addEventListener('keydown', function (e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        addComment();
                    }
                });
            }

            if (nickInput) {
                nickInput.addEventListener('input', handleNickInput);
            }

            if (window.CommentImages) {
                window.CommentImages.init();
            }

            const sortEl = document.getElementById('commentsSort');
            if (sortEl) {
                const saved = localStorage.getItem('youvi_comments_sort') || 'new';
                sortEl.value = saved;
                sortEl.addEventListener('change', () => {
                    localStorage.setItem('youvi_comments_sort', sortEl.value);
                    window.renderComments();
                });
            }


            initImageModal();
        }


        let comments = [];

        function openImageCarousel(images, startIndex = 0) {
            if (window.imageViewer) {
                const imageData = images.map((url, i) => ({
                    src: url,
                    caption: `${i + 1}/${images.length}`,
                    alt: ''
                }));
                window.imageViewer.open(imageData, startIndex);
            }
        }

        function openImageModal(src) {
            if (window.imageViewer) {
                window.imageViewer.show(src);
            }
        }

        function insertReplyImage(commentId) {
            if (window.CommentImages) {
                window.CommentImages.insertReplyImage(commentId);
            }
        }

        function insertNestedReplyImage(replyId) {
            if (window.CommentImages) {
                window.CommentImages.insertNestedReplyImage(replyId);
            }
        }

        async function addComment() {
            const commentText = document.getElementById('commentText');
            const nickInput = document.getElementById('nickInput');

            if (!commentText || !nickInput) return;

            let text = commentText.value.trim();
            const nick = nickInput.value.trim();

            const selectedImages = window.CommentImages ? window.CommentImages.getSelectedImages() : [];
            debug.log('Selected images:', selectedImages);

            if (!text && selectedImages.length === 0) {
                alert(',     ');
                return;
            }

            if (!nick) {
                alert(',  ');
                return;
            }

            if (!window.currentVideoName) {
                alert('  ');
                return;
            }

            const comment = {
                id: Date.now().toString(),
                nick: nick,
                text: text,
                created: Date.now(),
                replies: [],
                images: []
            };

            try {
                if (selectedImages.length > 0) {
                    debug.log('Saving images...');
                    const imageFilenames = await saveCommentImages(selectedImages, comment.id);
                    debug.log('Image filenames:', imageFilenames);
                    comment.images = imageFilenames;
                }

                debug.log('Comment to save:', comment);
                await saveComment(comment);
                comments.push(comment);
                window.renderComments();

                commentText.value = '';

                const previewContainer = document.getElementById('mainCommentImagePreview');
                if (previewContainer) {
                    previewContainer.innerHTML = '';
                    previewContainer.style.display = 'none';
                }

                if (window.CommentImages) {
                    window.CommentImages.clearSelectedImages();
                }

                updateCommentsCount();

            } catch (error) {
                console.error('   :', error);
                alert('   ');
            }
        }

        async function handleNickInput(e) {
            const nick = e.target.value.trim();
            if (nick.endsWith(' ()') || nick.endsWith(' (ka)')) {
                const channelName = nick.replace(/ \((|ka)\)$/, '');
                await loadChannelAvatarForComment(channelName, e.target);
            } else {
                hideChannelAvatarPreview(e.target);
            }
        }


        async function loadChannelAvatarForComment(channelName, inputElement) {
            try {
                if (!window.videoDirectoryHandle) return;

                const channelsDir = await window.videoDirectoryHandle.getDirectoryHandle('.channels', { create: false });
                const channelDir = await channelsDir.getDirectoryHandle(channelName, { create: false });
                const channelData = await readJSONFile(channelDir, 'channel.json', {});

                if (channelData.avatar) {
                    const avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                    if (avatarUrl) {
                        showChannelAvatarPreview(inputElement, avatarUrl, channelName);
                        debug.log('  :', avatarUrl);
                    }
                }
            } catch (error) {
                console.error('   :', error);
                hideChannelAvatarPreview(inputElement);
            }
        }

        function goToChannelFeed(channelName) {
            try {
                if (!channelName) return;
                if (!/\(\)\s*$/i.test(channelName)) return;
                const clean = channelName.replace(/\(\)\s*$/i, '').trim();
                if (!clean) return;
                const url = `youvi_ch_view.html?channel=${encodeURIComponent(clean)}&tab=home`;
                window.location.href = url;
            } catch (e) {
                console.error('goToChannelFeed error', e);
            }
        }

        function showChannelAvatarPreview(inputElement, avatarUrl, channelName) {
            hideChannelAvatarPreview(inputElement);

            const previewContainer = document.createElement('div');
            previewContainer.className = 'channel-avatar-preview';
            previewContainer.innerHTML = `
                <img src="${avatarUrl}" alt="${channelName}" class="channel-avatar-small">
                <span class="channel-name-small">${channelName}</span>
            `;

            inputElement.parentNode.insertBefore(previewContainer, inputElement.nextSibling);
        }

        function hideChannelAvatarPreview(inputElement) {
            const existingPreview = inputElement.parentNode.querySelector('.channel-avatar-preview');
            if (existingPreview) {
                existingPreview.remove();
            }
        }

        function setupChannelInputHandlers() {
            document.querySelectorAll('input[id^="replyNick_"]').forEach(input => {
                input.addEventListener('input', handleNickInput);
            });

            document.querySelectorAll('input[id^="replyToReplyNick_"]').forEach(input => {
                input.addEventListener('input', handleNickInput);
            });
        }

        async function readJSONFile(dirHandle, fileName, defaultValue = null) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return defaultValue;
            }
        }

        async function loadImageFile(dirHandle, fileName) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                return URL.createObjectURL(file);
            } catch (e) {
                console.error('   :', e);
                return null;
            }
        }




        async function saveCommentImages(images, commentId) {
            debug.log('saveCommentImages called:', images, commentId);
            if (!window.currentPlaylistHandle || !window.currentVideoName) {
                console.error('No playlist handle or video name');
                return [];
            }
            if (!images || images.length === 0) {
                debug.log('No images to save');
                return [];
            }

            try {
                const metadataDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });

                const imagesFolderName = `.images_${window.currentVideoName}_comments`;
                debug.log('Creating folder:', imagesFolderName, 'inside .metadata');
                const imagesDir = await metadataDir.getDirectoryHandle(imagesFolderName, { create: true });

                const savedFilenames = [];

                for (let i = 0; i < images.length; i++) {
                    const imageData = images[i];
                    const file = imageData.file;

                    if (!file) {
                        console.error('No file object in image data:', imageData);
                        continue;
                    }

                    const ext = file.name.split('.').pop() || 'jpg';
                    const filename = `${commentId}_${Date.now()}_${i}.${ext}`;
                    debug.log('Saving file:', filename);

                    const fileHandle = await imagesDir.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(file);
                    await writable.close();

                    savedFilenames.push(filename);
                }

                debug.log('Saved files:', savedFilenames);
                return savedFilenames;
            } catch (error) {
                console.error('   :', error);
                return [];
            }
        }

        const commentImagesCache = new Map();

        async function loadCommentImages(imageFilenames) {
            if (!window.currentPlaylistHandle || !window.currentVideoName) return [];
            if (!imageFilenames || imageFilenames.length === 0) return [];

            const cacheKey = `${window.currentVideoName}_${imageFilenames.join('_')}`;

            if (commentImagesCache.has(cacheKey)) {
                return commentImagesCache.get(cacheKey);
            }

            try {
                const metadataDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: false });

                const imagesFolderName = `.images_${window.currentVideoName}_comments`;
                const imagesDir = await metadataDir.getDirectoryHandle(imagesFolderName, { create: false });

                const imageUrls = [];

                for (const filename of imageFilenames) {
                    try {
                        const fileHandle = await imagesDir.getFileHandle(filename);
                        const file = await fileHandle.getFile();
                        const url = URL.createObjectURL(file);
                        imageUrls.push(url);
                    } catch (e) {
                        console.error(`    ${filename}:`, e);
                    }
                }

                commentImagesCache.set(cacheKey, imageUrls);

                return imageUrls;
            } catch (error) {
                console.error('   :', error);
                return [];
            }
        }

        function clearCommentImagesCache() {
            for (const urls of commentImagesCache.values()) {
                urls.forEach(url => {
                    try {
                        URL.revokeObjectURL(url);
                    } catch (e) {
                    }
                });
            }
            commentImagesCache.clear();
        }

        async function saveComment(comment) {
            if (!window.currentPlaylistHandle || !window.currentVideoName) return;

            try {
                const metaDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });
                const commentsFileName = window.currentVideoName + '.comments.json';
                const commentsFile = await metaDir.getFileHandle(commentsFileName, { create: true });
                const writable = await commentsFile.createWritable();

                const existingComments = await loadComments();
                const updatedComments = [...existingComments, comment];

                await writable.write(JSON.stringify(updatedComments, null, 2));
                await writable.close();
            } catch (error) {
                console.error('   :', error);
                throw error;
            }
        }

        async function loadComments() {
            if (!window.currentPlaylistHandle || !window.currentVideoName) return [];

            try {
                const metaDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });
                const commentsFileName = window.currentVideoName + '.comments.json';
                const commentsFile = await metaDir.getFileHandle(commentsFileName);
                const file = await commentsFile.getFile();
                const text = await file.text();
                const data = JSON.parse(text);

                comments = Array.isArray(data) ? data : [];

                comments = ensureRepliesArrays(comments);

                return comments;
            } catch (error) {
                comments = [];
                return comments;
            }
        }

        function ensureRepliesArrays(commentsArray) {
            if (!Array.isArray(commentsArray)) return commentsArray;

            for (const comment of commentsArray) {
                if (!comment.replies) comment.replies = [];

                for (const reply of comment.replies) {
                    if (!reply.replies) reply.replies = [];
                    ensureNestedReplies(reply.replies);
                }
            }

            return commentsArray;
        }

        function ensureNestedReplies(replies) {
            if (!Array.isArray(replies)) return;
            for (const reply of replies) {
                if (!reply.replies) reply.replies = [];
                if (reply.replies.length > 0) ensureNestedReplies(reply.replies);
            }
        }

        function captureCommentsUIState() {
            try {
                const state = {
                    openThreads: new Set(),
                    openReplyForms: new Set(),
                    openReplyToReplyForms: new Set(),
                    inputValues: {}
                };
                document.querySelectorAll('.replies-toggle[data-open="1"]').forEach(btn => {
                    const id = (btn.id || '').replace('repliesToggle_', '');
                    if (id) state.openThreads.add(id);
                });
                document.querySelectorAll('.reply-form').forEach(form => {
                    if (form && form.style && form.style.display === 'block') {
                        const id = (form.id || '').replace('replyForm_', '');
                        if (id) state.openReplyForms.add(id);
                        const txt = document.getElementById(`replyText_${id}`);
                        if (txt) state.inputValues[`replyText_${id}`] = txt.value;
                        const nick = document.getElementById(`replyNick_${id}`);
                        if (nick) state.inputValues[`replyNick_${id}`] = nick.value;
                    }
                });
                document.querySelectorAll('.reply-to-reply-form').forEach(form => {
                    if (form && form.style && form.style.display === 'block') {
                        const id = (form.id || '').replace('replyToReplyForm_', '');
                        if (id) state.openReplyToReplyForms.add(id);
                        const txt = document.getElementById(`replyToReplyText_${id}`);
                        if (txt) state.inputValues[`replyToReplyText_${id}`] = txt.value;
                        const nick = document.getElementById(`replyToReplyNick_${id}`);
                        if (nick) state.inputValues[`replyToReplyNick_${id}`] = nick.value;
                    }
                });
                return state;
            } catch (_) {
                return { openThreads: new Set(), openReplyForms: new Set(), openReplyToReplyForms: new Set(), inputValues: {} };
            }
        }

        function restoreCommentsUIState(state) {
            try {
                if (state && state.openThreads && state.openThreads.size) {
                    state.openThreads.forEach(id => {
                        const toggleBtn = document.getElementById(`repliesToggle_${id}`);
                        const replies = document.getElementById(`replies_${id}`);
                        if (toggleBtn && replies && toggleBtn.dataset.open !== '1') {
                            replies.style.display = '';
                            toggleBtn.dataset.open = '1';
                            const count = toggleBtn.textContent.match(/\((\d+)\)/)?.[1] || '0';
                            toggleBtn.textContent = i18n.t('comments.hideReplies', ' ') + ` (${count})`;
                            toggleBtn.classList.add('open');
                        }
                    });
                }
                if (state && state.openReplyForms && state.openReplyForms.size) {
                    state.openReplyForms.forEach(id => {
                        const form = document.getElementById(`replyForm_${id}`);
                        if (form) form.style.display = 'block';
                    });
                }
                if (state && state.openReplyToReplyForms && state.openReplyToReplyForms.size) {
                    state.openReplyToReplyForms.forEach(id => {
                        const form = document.getElementById(`replyToReplyForm_${id}`);
                        if (form) form.style.display = 'block';
                    });
                }
                if (state && state.inputValues) {
                    Object.keys(state.inputValues).forEach(key => {
                        const el = document.getElementById(key);
                        if (el) el.value = state.inputValues[key];
                    });
                }
            } catch (_) { }
        }

        window.renderComments = async function renderComments(desiredState) {
            const commentsList = document.getElementById('commentsList');
            if (!commentsList) return;

            if (window._renderingComments) {
                debug.log('[renderComments] Already rendering, skipping duplicate call');
                return;
            }
            window._renderingComments = true;

            try {
                const scrollY = window.scrollY;

                const __uiState = desiredState || captureCommentsUIState();

                let order = 'new';
                try {
                    var sortEl = document.getElementById('commentsSort');
                    order = (sortEl && sortEl.value) || localStorage.getItem('youvi_comments_sort') || 'new';
                } catch (_) { }

                window._commentsCache = window._commentsCache || { version: 0, lists: {} };
                const version = `${comments.length}:${Math.max(0, ...comments.map(c => c.created || 0))}:${Math.max(0, ...comments.map(c => c.likes || 0))}:${Math.max(0, ...comments.map(c => c.dislikes || 0))}`;
                if (window._commentsCache.version !== version) {
                    window._commentsCache.version = version;
                    window._commentsCache.lists = {};
                }
                let sortedComments = window._commentsCache.lists[order];
                if (!sortedComments) {
                    sortedComments = [...comments];
                    if (order === 'old') {
                        sortedComments.sort((a, b) => a.created - b.created);
                    } else if (order === 'best') {
                        sortedComments.sort((a, b) => (b.likes || 0) - (a.likes || 0) || (b.created - a.created));
                    } else if (order === 'worst') {
                        sortedComments.sort((a, b) => (b.dislikes || 0) - (a.dislikes || 0) || (b.created - a.created));
                    } else {
                        sortedComments.sort((a, b) => b.created - a.created);
                    }
                    window._commentsCache.lists[order] = sortedComments;
                }
                commentsList.innerHTML = '';
                for (const comment of sortedComments) {
                    const commentElement = await createCommentElement(comment);
                    commentsList.appendChild(commentElement);
                    commentElement.querySelectorAll('[data-seek]').forEach(btn => {
                        btn.addEventListener('click', (ev) => {
                            ev.preventDefault();
                            ev.stopPropagation();

                            if (window.abSegmentA !== null || window.abSegmentB !== null) {
                                window.abSegmentA = null;
                                window.abSegmentB = null;
                                window.abSegmentMode = 0;
                                if (typeof window.updateABMarkers === 'function') {
                                    window.updateABMarkers();
                                }
                            }

                            const time = parseFloat(btn.dataset.seek);
                            if (!isNaN(time)) {
                                seekToTime(time);
                            }
                        });
                    });
                }
                setupChannelInputHandlers();
                restoreCommentsUIState(__uiState);

                if (window.YouviCommentsPagination && window.YouviCommentsPagination.paginateList) {
                    setTimeout(() => {
                        window.YouviCommentsPagination.paginateList(commentsList);
                        window.scrollTo(0, scrollY);
                    }, 0);
                } else {
                    window.scrollTo(0, scrollY);
                }
            } finally {
                window._renderingComments = false;
            }
        }
        async function createCommentElement(comment) {
            const div = document.createElement('div');
            div.className = 'comment-item';
            div.dataset.commentId = comment.id;

            const date = new Date(comment.created).toLocaleString('ru-RU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            const nickColor = getNickColor(comment.nick);

            let avatarHtml = `<div class="comment-avatar" style="background: ${nickColor}">${comment.nick.charAt(0).toUpperCase()}</div>`;

            const isChannelNick = /\s\((|ka)\)$/.test(comment.nick);
            if (isChannelNick) {
                const channelName = comment.nick.replace(/\s\((|ka)\)$/, '');
                try {
                    const avatarUrl = await loadChannelAvatar(channelName);
                    if (avatarUrl) {
                        avatarHtml = `<div class="comment-avatar"><img src="${avatarUrl}" alt="${channelName}" class="comment-avatar-img"></div>`;
                    }
                } catch (error) {
                    console.error('   :', error);
                }
            }

            let imagesHtml = '';
            if (comment.images && comment.images.length > 0) {
                const imageUrls = await loadCommentImages(comment.images);
                if (imageUrls.length > 0) {
                    const urlsJson = JSON.stringify(imageUrls).replace(/'/g, "\\'");
                    imagesHtml = '<div class="comment-images">' +
                        imageUrls.map((url, i) => `<img src="${url}" class="comment-image" onclick="openImageCarousel(${urlsJson.replace(/"/g, '&quot;')}, ${i})">`).join('') +
                        '</div>';
                }
            }

            const channelNickPattern = /\s\((|ka)\)$/;
            const isCommentChannelNick = channelNickPattern.test(comment.nick);
            const commentChannelName = isCommentChannelNick ? comment.nick.replace(channelNickPattern, '') : null;
            
            div.innerHTML = `
                ${avatarHtml}
                <div class="comment-content">
                    <div class="comment-bubble">
                        <div class="comment-header">
                            ${isCommentChannelNick
                    ? `<span class="comment-nick channel-nick" style="cursor:pointer" onclick="goToChannelFeed('${escapeHtml(comment.nick)}')">${escapeHtml(commentChannelName)}</span>`
                    : `<span class="comment-nick">${escapeHtml(comment.nick)}</span>`}
                            ${isCommentChannelNick && window.currentChannelName && commentChannelName === window.currentChannelName ? `<span class="author-badge">${i18n.t('comments.author', '')}</span>` : ''}
                            <span class="comment-date">${date}</span>
                        </div>
                        <div class="comment-text">${processCommentText(comment.text)}</div>
                        ${imagesHtml}
                        <div class="comment-actions">
                            <button onclick="toggleLike('${comment.id}')" class="like-btn" title="${i18n.t('comments.like', '')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                </svg>
                                <span class="like-count">${comment.likes || 0}</span>
                            </button>
                            <button onclick="toggleDislike('${comment.id}')" class="dislike-btn" title="${i18n.t('comments.dislike', '')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                </svg>
                                <span class="dislike-count">${comment.dislikes || 0}</span>
                            </button>
                            <button onclick="toggleReplyForm('${comment.id}')" class="reply-btn">${i18n.t('comments.reply', '')}</button>
                            <button onclick="deleteComment('${comment.id}')" class="delete-btn" title="${i18n.t('comments.delete', '')}">${i18n.t('comments.report', '')}</button>
                        </div>
                    </div>
                    <div class="reply-form" id="replyForm_${comment.id}" style="display: none;">
                        <input type="text" id="replyNick_${comment.id}" placeholder="${i18n.t('comments.yourNick', ' ...')}" class="reply-nick-input" />
                        <input type="file" id="replyImageInput_${comment.id}" accept="image/*" style="display:none" multiple class="reply-image-input">
                        <textarea class="reply-textarea" id="replyText_${comment.id}" placeholder="${i18n.t('comments.addReply', ' ...')}"></textarea>
                        <div id="replyImagePreview_${comment.id}" class="comment-image-preview" style="display:none;"></div>
                        <div class="reply-actions">
                            <button onclick="toggleReplyForm('${comment.id}')" class="reply-cancel-btn">${i18n.t('comments.cancel', '')}</button>
                            <button onclick="insertReplyImage('${comment.id}')" class="reply-image-btn" title="${i18n.t('comments.addImage', ' ')}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                                </svg>
                            </button>
                            <button onclick="addReply('${comment.id}')" class="reply-submit-btn">${i18n.t('comments.reply', '')}</button>
                        </div>
                    </div>
                    ${comment.replies && comment.replies.length > 0 ? `
                        <button type="button" class="replies-toggle" id="repliesToggle_${comment.id}" data-open="0">${i18n.t('comments.showReplies', ' ')} (${comment.replies.length})</button>
                        <div class="replies-container" id="replies_${comment.id}" style="display:none;">
                            <!--     -->
                        </div>
                    ` : ''}
                </div>
            `;

            if (comment.replies && comment.replies.length > 0) {
                const repliesContainer = div.querySelector(`#replies_${comment.id}`);
                const toggleBtn = div.querySelector(`#repliesToggle_${comment.id}`);
                if (repliesContainer) {
                    for (const reply of comment.replies) {
                        const replyElement = document.createElement('div');
                        replyElement.innerHTML = await createReplyElement(reply, comment.id, 1);
                        const replyNode = replyElement.firstElementChild;
                        repliesContainer.appendChild(replyNode);

                        await loadNestedReplies(replyNode, reply, 1);
                    }
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', () => {
                            const isHidden = repliesContainer.style.display === 'none';
                            repliesContainer.style.display = isHidden ? '' : 'none';
                            toggleBtn.dataset.open = isHidden ? '1' : '0';
                            toggleBtn.textContent = (isHidden ? i18n.t('comments.hideReplies', ' ') : i18n.t('comments.showReplies', ' ')) + ` (${comment.replies.length})`;
                            toggleBtn.classList.toggle('open', isHidden);

                            const nestedContainers = repliesContainer.querySelectorAll('.replies-container');
                            const nestedToggles = repliesContainer.querySelectorAll('.replies-toggle');
                            nestedContainers.forEach(container => {
                                container.style.display = isHidden ? '' : 'none';
                            });
                            nestedToggles.forEach(toggle => {
                                toggle.dataset.open = isHidden ? '1' : '0';
                                const count = toggle.textContent.match(/\((\d+)\)/)?.[1] || '0';
                                toggle.textContent = (isHidden ? i18n.t('comments.hideReplies', ' ') : i18n.t('comments.showReplies', ' ')) + ` (${count})`;
                                toggle.classList.toggle('open', isHidden);
                            });
                        });
                    }
                }
            }

            return div;
        }

        async function createReplyElement(reply, commentId, depth = 1) {
            const date = new Date(reply.created).toLocaleString('ru-RU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            const nickColor = getNickColor(reply.nick);

            let avatarHtml = `<div class="reply-avatar" style="background: ${nickColor}">${reply.nick.charAt(0).toUpperCase()}</div>`;

            const isReplyChannelNick = /\s\((|ka)\)$/.test(reply.nick);
            if (isReplyChannelNick) {
                const channelName = reply.nick.replace(/\s\((|ka)\)$/, '');
                try {
                    const avatarUrl = await loadChannelAvatar(channelName);
                    if (avatarUrl) {
                        avatarHtml = `<div class="reply-avatar"><img src="${avatarUrl}" alt="${channelName}" class="reply-avatar-img"></div>`;
                    }
                } catch (error) {
                    console.error('   :', error);
                }
            }

            let imagesHtml = '';
            if (reply.images && reply.images.length > 0) {
                const imageUrls = await loadCommentImages(reply.images);
                if (imageUrls.length > 0) {
                    const urlsJson = JSON.stringify(imageUrls).replace(/'/g, "\\'");
                    imagesHtml = '<div class="comment-images">' +
                        imageUrls.map((url, i) => `<img src="${url}" class="reply-image" onclick="openImageCarousel(${urlsJson.replace(/"/g, '&quot;')}, ${i})">`).join('') +
                        '</div>';
                }
            }

            let nestedRepliesHtml = '';
            if (reply.replies && reply.replies.length > 0 && depth < 5) {
                nestedRepliesHtml = `
                    <button type="button" class="replies-toggle" id="repliesToggle_${reply.id}" data-open="0">${i18n.t('comments.showReplies', ' ')} (${reply.replies.length})</button>
                    <div class="replies-container" id="replies_${reply.id}" style="display:none;" data-depth="${depth + 1}">
                        <!--      -->
                    </div>
                `;
            } else if (reply.replies && reply.replies.length > 0 && depth >= 5) {
                nestedRepliesHtml = `
                    <button type="button" class="replies-toggle" id="repliesToggle_${reply.id}" data-open="0">${i18n.t('comments.showReplies', ' ')} (${reply.replies.length})</button>
                    <div class="replies-container" id="replies_${reply.id}" style="display:none;" data-depth="${depth + 1}">
                        <!--      -->
                    </div>
                `;
            }

            const replyChannelNickPattern = /\s\((|ka)\)$/;
            const isReplyNickChannel = replyChannelNickPattern.test(reply.nick);
            const replyChannelName = isReplyNickChannel ? reply.nick.replace(replyChannelNickPattern, '') : null;

            return `
                <div class="reply-item" data-reply-id="${reply.id}" data-depth="${depth}">
                    ${avatarHtml}
                    <div class="reply-bubble">
                        <div class="reply-header">
                            ${isReplyNickChannel
                    ? `<span class="reply-nick channel-nick" style="cursor:pointer" onclick="goToChannelFeed('${escapeHtml(reply.nick)}')">${escapeHtml(replyChannelName)}</span>`
                    : `<span class="reply-nick">${escapeHtml(reply.nick)}</span>`}
                            ${isReplyNickChannel && window.currentChannelName && replyChannelName === window.currentChannelName ? `<span class="author-badge">${i18n.t('comments.author', '')}</span>` : ''}
                            <span class="reply-date">${date}</span>
                        </div>
                        <div class="reply-text">${processCommentText(reply.text)}</div>
                        ${imagesHtml}
                        <div class="reply-actions">
                            <button onclick="toggleReplyLike('${reply.id}')" class="like-btn" title="${i18n.t('comments.like', '')}">
                                <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                </svg>
                                <span class="like-count">${reply.likes || 0}</span>
                            </button>
                            <button onclick="toggleReplyDislike('${reply.id}')" class="dislike-btn" title="${i18n.t('comments.dislike', '')}">
                                <svg width="14" height="14" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                </svg>
                                <span class="dislike-count">${reply.dislikes || 0}</span>
                            </button>
                            <button onclick="toggleReplyToReplyForm('${reply.id}')" class="reply-btn">${i18n.t('comments.reply', '')}</button>
                            <button onclick="deleteReply('${reply.id}')" class="delete-btn" title="${i18n.t('comments.delete', '')}">${i18n.t('comments.report', '')}</button>
                        </div>
                        
                        
                        <div class="reply-to-reply-form" id="replyToReplyForm_${reply.id}" style="display: none;">
                            <input type="text" id="replyToReplyNick_${reply.id}" placeholder="${i18n.t('comments.yourNick', ' ...')}" class="reply-nick-input" />
                            <input type="file" id="nestedReplyImageInput_${reply.id}" accept="image/*" style="display:none" multiple class="nested-reply-image-input">
                            <textarea class="reply-textarea" id="replyToReplyText_${reply.id}" placeholder="${i18n.t('comments.replyTo', ' @{nick}...').replace('{nick}', escapeHtml(replyChannelName || reply.nick))}"></textarea>
                            <div id="nestedReplyImagePreview_${reply.id}" class="comment-image-preview" style="display:none;"></div>
                            <div class="reply-actions">
                                <button onclick="toggleReplyToReplyForm('${reply.id}')" class="reply-cancel-btn">${i18n.t('comments.cancel', '')}</button>
                                <button onclick="insertNestedReplyImage('${reply.id}')" class="reply-image-btn" title="${i18n.t('comments.addImage', ' ')}">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                                    </svg>
                                </button>
                                <button onclick="addReplyToReply('${reply.id}')" class="reply-submit-btn">${i18n.t('comments.reply', '')}</button>
                            </div>
                        </div>
                        ${nestedRepliesHtml}
                    </div>
                </div>
            `;
        }

        async function loadNestedReplies(parentElement, reply, depth) {
            if (!reply.replies || reply.replies.length === 0) return;

            const repliesContainer = parentElement.querySelector(`#replies_${reply.id}`);
            const toggleBtn = parentElement.querySelector(`#repliesToggle_${reply.id}`);

            if (repliesContainer && reply.replies.length > 0) {
                for (const nestedReply of reply.replies) {
                    const nestedReplyElement = document.createElement('div');
                    nestedReplyElement.innerHTML = await createReplyElement(nestedReply, reply.id, depth + 1);
                    const nestedReplyNode = nestedReplyElement.firstElementChild;
                    repliesContainer.appendChild(nestedReplyNode);

                    if (depth + 1 < 5) {
                        await loadNestedReplies(nestedReplyNode, nestedReply, depth + 1);
                    } else {
                        await loadNestedReplies(nestedReplyNode, nestedReply, depth + 1);
                    }
                }

                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => {
                        const isHidden = repliesContainer.style.display === 'none';
                        repliesContainer.style.display = isHidden ? '' : 'none';
                        toggleBtn.dataset.open = isHidden ? '1' : '0';
                        toggleBtn.textContent = (isHidden ? i18n.t('comments.hideReplies', ' ') : i18n.t('comments.showReplies', ' ')) + ` (${reply.replies.length})`;
                        toggleBtn.classList.toggle('open', isHidden);

                        const nestedContainers = repliesContainer.querySelectorAll('.replies-container');
                        const nestedToggles = repliesContainer.querySelectorAll('.replies-toggle');
                        nestedContainers.forEach(container => {
                            container.style.display = isHidden ? '' : 'none';
                        });
                        nestedToggles.forEach(toggle => {
                            toggle.dataset.open = isHidden ? '1' : '0';
                            const count = toggle.textContent.match(/\((\d+)\)/)?.[1] || '0';
                            toggle.textContent = (isHidden ? i18n.t('comments.hideReplies', ' ') : i18n.t('comments.showReplies', ' ')) + ` (${count})`;
                            toggle.classList.toggle('open', isHidden);
                        });
                    });
                }
            }
        }

        function toggleReplyForm(commentId) {
            const replyForm = document.getElementById(`replyForm_${commentId}`);
            const authorReplyForm = document.getElementById(`authorReplyForm_${commentId}`);

            if (replyForm) {
                const isOpening = replyForm.style.display === 'none';

                if (isOpening) {
                    document.querySelectorAll('.reply-form').forEach(form => {
                        if (form.id !== `replyForm_${commentId}`) {
                            form.style.display = 'none';
                        }
                    });
                    document.querySelectorAll('.reply-to-reply-form').forEach(form => {
                        form.style.display = 'none';
                    });
                }

                replyForm.style.display = replyForm.style.display === 'none' ? 'block' : 'none';
                if (authorReplyForm) {
                    authorReplyForm.style.display = 'none';
                }
                if (replyForm.style.display === 'block') {
                    const textarea = document.getElementById(`replyText_${commentId}`);
                    if (textarea) textarea.focus();
                }
            }
        }


        function toggleReplyToReplyForm(replyId) {
            const replyToReplyForm = document.getElementById(`replyToReplyForm_${replyId}`);
            if (replyToReplyForm) {
                const isOpening = replyToReplyForm.style.display === 'none';

                if (isOpening) {
                    document.querySelectorAll('.reply-form').forEach(form => {
                        form.style.display = 'none';
                    });
                    document.querySelectorAll('.reply-to-reply-form').forEach(form => {
                        if (form.id !== `replyToReplyForm_${replyId}`) {
                            form.style.display = 'none';
                        }
                    });
                }

                replyToReplyForm.style.display = replyToReplyForm.style.display === 'none' ? 'block' : 'none';
                if (replyToReplyForm.style.display === 'block') {
                    const textarea = document.getElementById(`replyToReplyText_${replyId}`);
                    if (textarea) textarea.focus();
                }
            }
        }

        function toggleReplyToReply(postId, replyId) {
            const replyToReplyForm = document.getElementById(`replyToReplyForm_${replyId}`);
            if (replyToReplyForm) {
                replyToReplyForm.style.display = replyToReplyForm.style.display === 'none' ? 'block' : 'none';
                if (replyToReplyForm.style.display === 'block') {
                    const textarea = document.getElementById(`replyToReplyText_${replyId}`);
                    if (textarea) textarea.focus();
                }
            }
        }

        async function addReply(commentId) {
            const replyText = document.getElementById(`replyText_${commentId}`);
            const replyNickInput = document.getElementById(`replyNick_${commentId}`);

            if (!replyText || !replyNickInput) return;

            let text = replyText.value.trim();
            const nick = replyNickInput.value.trim();

            const images = window.CommentImages ? window.CommentImages.getReplyImages(commentId) : [];

            if (!text && images.length === 0) {
                alert(',     ');
                return;
            }

            if (!nick) {
                alert(',  ');
                return;
            }

            const reply = {
                id: Date.now().toString(),
                nick: nick,
                text: text,
                created: Date.now(),
                images: [],
                replies: []
            };

            if (images.length > 0) {
                const imageFilenames = await saveCommentImages(images, reply.id);
                reply.images = imageFilenames;
            }

            const comment = comments.find(c => c.id === commentId);
            if (comment) {
                comment.replies = comment.replies || [];
                comment.replies.push(reply);

                try {
                    await saveAllComments();

                    window._commentsCache = null;

                    replyText.value = '';
                    replyNickInput.value = '';

                    if (window.CommentImages) {
                        window.CommentImages.clearReplyPreview(commentId);
                    }

                    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);

                    if (commentElement) {
                        const replyForm = document.getElementById(`replyForm_${commentId}`);
                        if (replyForm) {
                            replyForm.style.display = 'none';
                        }

                        let repliesContainer = document.getElementById(`replies_${commentId}`);
                        let repliesToggleBtn = document.getElementById(`repliesToggle_${commentId}`);

                        if (!repliesContainer || !repliesToggleBtn) {
                            const commentContent = commentElement.querySelector('.comment-content');
                            if (commentContent) {
                                repliesToggleBtn = document.createElement('button');
                                repliesToggleBtn.type = 'button';
                                repliesToggleBtn.className = 'replies-toggle open';
                                repliesToggleBtn.id = `repliesToggle_${commentId}`;
                                repliesToggleBtn.dataset.open = '1';
                                repliesToggleBtn.textContent = i18n.t('comments.hideReplies', ' ') + ` (${comment.replies.length})`;

                                repliesContainer = document.createElement('div');
                                repliesContainer.className = 'replies-container';
                                repliesContainer.id = `replies_${commentId}`;
                                repliesContainer.style.display = '';

                                commentContent.appendChild(repliesToggleBtn);
                                commentContent.appendChild(repliesContainer);

                                repliesToggleBtn.addEventListener('click', () => {
                                    const isHidden = repliesContainer.style.display === 'none';
                                    repliesContainer.style.display = isHidden ? '' : 'none';
                                    repliesToggleBtn.dataset.open = isHidden ? '1' : '0';
                                    repliesToggleBtn.textContent = (isHidden ? i18n.t('comments.hideReplies', ' ') : i18n.t('comments.showReplies', ' ')) + ` (${comment.replies.length})`;
                                    repliesToggleBtn.classList.toggle('open', isHidden);
                                });
                            }
                        }

                        if (repliesContainer) {
                            repliesContainer.innerHTML = '';
                            for (const r of comment.replies) {
                                const replyElement = document.createElement('div');
                                replyElement.innerHTML = await createReplyElement(r, commentId, 1);
                                const replyNode = replyElement.firstElementChild;
                                repliesContainer.appendChild(replyNode);

                                await loadNestedReplies(replyNode, r, 1);
                            }

                            repliesContainer.style.display = '';

                            if (repliesToggleBtn) {
                                repliesToggleBtn.textContent = i18n.t('comments.hideReplies', ' ') + ` (${comment.replies.length})`;
                                repliesToggleBtn.dataset.open = '1';
                                repliesToggleBtn.classList.add('open');
                            }

                            const lastReply = repliesContainer.lastElementChild;
                            if (lastReply) {
                                lastReply.style.display = '';
                            }
                        }
                    } else {
                        const __uiState = captureCommentsUIState();
                        window.renderComments(__uiState);
                    }

                    updateCommentsCount();

                } catch (error) {
                    console.error('   :', error);
                    alert('   ');
                }
            }
        }


        async function addReplyToReply(replyId) {
            const replyToReplyText = document.getElementById(`replyToReplyText_${replyId}`);
            const replyToReplyNickInput = document.getElementById(`replyToReplyNick_${replyId}`);

            if (!replyToReplyText || !replyToReplyNickInput) return;

            let text = replyToReplyText.value.trim();
            const nick = replyToReplyNickInput.value.trim();

            const images = window.CommentImages ? window.CommentImages.getNestedReplyImages(replyId) : [];

            if (!text && images.length === 0) {
                alert(',     ');
                return;
            }

            if (!nick) {
                alert(',  ');
                return;
            }

            function findReplyByIdWithDepth(replies, targetId, depth = 1) {
                if (!replies) return null;
                for (const reply of replies) {
                    if (reply.id === targetId) return { reply, depth };
                    if (reply.replies) {
                        const found = findReplyByIdWithDepth(reply.replies, targetId, depth + 1);
                        if (found) return found;
                    }
                }
                return null;
            }

            function findLevel5Parent(replies, targetId, path = []) {
                if (!replies) return null;
                for (const reply of replies) {
                    const currentPath = [...path, reply];
                    if (reply.id === targetId) {
                        if (currentPath.length >= 5) {
                            return currentPath[4];
                        }
                        return null;
                    }
                    if (reply.replies) {
                        const found = findLevel5Parent(reply.replies, targetId, currentPath);
                        if (found) return found;
                    }
                }
                return null;
            }

            for (const comment of comments) {
                const result = findReplyByIdWithDepth(comment.replies, replyId);
                if (result) {
                    const { reply: targetReply, depth } = result;

                    const mentionText = `@${targetReply.nick.replace(/\s\((|ka)\)$/, '')} ${text}`;

                    const reply = {
                        id: Date.now().toString(),
                        nick: nick,
                        text: mentionText,
                        created: Date.now(),
                        images: [],
                        replies: []
                    };

                    if (images.length > 0) {
                        const imageFilenames = await saveCommentImages(images, reply.id);
                        reply.images = imageFilenames;
                    }

                    if (depth >= 5) {
                        const level5Parent = findLevel5Parent(comment.replies, replyId);
                        if (level5Parent) {
                            if (!level5Parent.replies) level5Parent.replies = [];
                            level5Parent.replies.push(reply);
                        } else {
                            if (!targetReply.replies) targetReply.replies = [];
                            targetReply.replies.push(reply);
                        }
                    } else {
                        if (!targetReply.replies) {
                            targetReply.replies = [];
                        }
                        targetReply.replies.push(reply);
                    }

                    try {
                        await saveAllComments();

                        window._commentsCache = null;

                        replyToReplyText.value = '';
                        replyToReplyNickInput.value = '';

                        if (window.CommentImages) {
                            window.CommentImages.clearNestedReplyPreview(replyId);
                        }

                        const replyToReplyForm = document.getElementById(`replyToReplyForm_${replyId}`);
                        if (replyToReplyForm) {
                            replyToReplyForm.style.display = 'none';
                        }

                        const __uiState = captureCommentsUIState();
                        await window.renderComments(__uiState);

                        updateCommentsCount();

                    } catch (error) {
                        console.error('     :', error);
                        alert('     ');
                    }
                    return;
                }
            }
        }

        async function saveAllComments() {
            if (!window.currentPlaylistHandle || !window.currentVideoName) return;

            try {
                const metaDir = await window.currentPlaylistHandle.getDirectoryHandle('.metadata', { create: true });
                const commentsFileName = window.currentVideoName + '.comments.json';
                const commentsFile = await metaDir.getFileHandle(commentsFileName, { create: true });
                const writable = await commentsFile.createWritable();

                await writable.write(JSON.stringify(comments, null, 2));
                await writable.close();
            } catch (error) {
                console.error('   :', error);
                throw error;
            }
        }

        async function deleteComment(commentId) {
            if (confirm(i18n.t('comments.confirmDeleteComment', 'Are you sure you want to delete this comment?'))) {
                const commentIndex = comments.findIndex(c => c.id === commentId);
                if (commentIndex !== -1) {
                    comments.splice(commentIndex, 1);

                    try {
                        await saveAllComments();

                        const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
                        if (commentElement) {
                            commentElement.remove();
                            updateCommentsCount();
                        } else {
                            const scrollY = window.scrollY;
                            const __uiState = captureCommentsUIState();
                            window.renderComments(__uiState);
                            requestAnimationFrame(() => {
                                window.scrollTo(0, scrollY);
                            });
                        }
                    } catch (error) {
                        console.error('   :', error);
                        alert('   ');
                    }
                }
            }
        }

        function removeReplyRecursive(replies, replyId) {
            if (!replies) return false;
            const idx = replies.findIndex(r => r.id === replyId);
            if (idx !== -1) {
                replies.splice(idx, 1);
                return true;
            }
            for (const r of replies) {
                if (removeReplyRecursive(r.replies, replyId)) return true;
            }
            return false;
        }

        async function deleteReply(replyId) {
            if (confirm(i18n.t('comments.confirmDeleteReply', 'Are you sure you want to delete this reply?'))) {
                let deleted = false;

                for (const comment of comments) {
                    if (removeReplyRecursive(comment.replies, replyId)) {
                        deleted = true;
                        break;
                    }
                }

                if (!deleted) return;

                try {
                    await saveAllComments();

                    window._commentsCache = null;
                    const __uiState = captureCommentsUIState();
                    await window.renderComments(__uiState);
                    updateCommentsCount();
                } catch (error) {
                    console.error('   :', error);
                    alert('   ');
                }
            }
        }

        function countReplies(replies) {
            if (!replies) return 0;
            return replies.reduce((sum, r) => sum + 1 + countReplies(r.replies), 0);
        }

        function updateCommentsCount() {
            const countElement = document.getElementById('commentsCount');
            if (countElement) {
                const totalComments = comments.length + comments.reduce((sum, c) => sum + countReplies(c.replies), 0);
                countElement.textContent = totalComments;
            }
        }

        function processCommentText(text) {
            text = text.replace(/@([\w--0-9._-]+)/gu, '<span class="mention">@$1</span>');

            text = text.replace(/\[(\d{1,2}):(\d{2})(?::(\d{2}))?\]/g, (match, first, second, third) => {
                let total;
                if (third !== undefined) {
                    total = parseInt(first, 10) * 3600 + parseInt(second, 10) * 60 + parseInt(third, 10);
                } else {
                    total = parseInt(first, 10) * 60 + parseInt(second, 10);
                }
                return `<button class="btn" data-seek="${total}" style="padding:2px 6px;margin:0 2px;">${match}</button>`;
            });

            text = text.replace(/(\d{1,2}):(\d{2})(?::(\d{2}))?(?!\d)/g, (match, first, second, third) => {
                let total;
                if (third !== undefined) {
                    total = parseInt(first, 10) * 3600 + parseInt(second, 10) * 60 + parseInt(third, 10);
                } else {
                    total = parseInt(first, 10) * 60 + parseInt(second, 10);
                }
                return `<button class="time-code" data-seek="${total}">${match}</button>`;
            });

            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');

            text = text.replace(/__(.*?)__/g, '<u>$1</u>');

            text = text.replace(/\n/g, '<br>');

            return text;
        }


        function formatText(type) {
            const textarea = document.getElementById('commentText');
            if (!textarea) return;

            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);

            let formattedText = '';
            switch (type) {
                case 'bold':
                    formattedText = `**${selectedText}**`;
                    break;
                case 'italic':
                    formattedText = `*${selectedText}*`;
                    break;
                case 'underline':
                    formattedText = `__${selectedText}__`;
                    break;
            }

            textarea.value = textarea.value.substring(0, start) + formattedText + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + formattedText.length, start + formattedText.length);
        }

        function insertTimecode() {
            const textarea = document.getElementById('commentText');
            const video = document.querySelector('video');

            if (!textarea || !video) return;

            const currentTime = Math.floor(video.currentTime);
            let timecode;

            if (currentTime >= 3600) {
                const hours = Math.floor(currentTime / 3600);
                const minutes = Math.floor((currentTime % 3600) / 60);
                const seconds = currentTime % 60;
                timecode = `[${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}]`;
            } else {
                const minutes = Math.floor(currentTime / 60);
                const seconds = currentTime % 60;
                timecode = `[${minutes}:${seconds.toString().padStart(2, '0')}]`;
            }

            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;

            textarea.value = textarea.value.substring(0, start) + timecode + textarea.value.substring(end);
            textarea.focus();
            textarea.setSelectionRange(start + timecode.length, start + timecode.length);
        }


        function getNickColor(nick) {
            const colors = [
                '#d94b88', '#ff69b4', '#ff1493', '#c71585', '#db7093',
                '#ff6347', '#ff4500', '#ff8c00', '#ffa500', '#ffd700',
                '#32cd32', '#00ff7f', '#00ced1', '#1e90ff', '#4169e1',
                '#8a2be2', '#9932cc', '#da70d6', '#ff69b4', '#ff1493'
            ];

            let hash = 0;
            for (let i = 0; i < nick.length; i++) {
                hash = nick.charCodeAt(i) + ((hash << 5) - hash);
            }

            return colors[Math.abs(hash) % colors.length];
        }

        function toggleLike(commentId) {
            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            if (!comment.likes) comment.likes = 0;

            comment.likes++;

            const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
            if (commentElement) {
                const likeCountElement = commentElement.querySelector('.like-count');
                if (likeCountElement) {
                    likeCountElement.textContent = comment.likes;
                }
            }

            saveAllComments();
        }

        function toggleDislike(commentId) {
            const comment = comments.find(c => c.id === commentId);
            if (!comment) return;

            if (!comment.dislikes) comment.dislikes = 0;

            comment.dislikes++;

            const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
            if (commentElement) {
                const dislikeCountElement = commentElement.querySelector('.dislike-count');
                if (dislikeCountElement) {
                    dislikeCountElement.textContent = comment.dislikes;
                }
            }

            saveAllComments();
        }

        function reportComment(commentId) {
            if (confirm('   ?')) {
                alert('  ');
            }
        }

        function reportReply(replyId) {
            if (confirm('   ?')) {
                alert('  ');
            }
        }

        function toggleReplyLike(replyId) {
            for (const comment of comments) {
                if (comment.replies) {
                    const reply = comment.replies.find(r => r.id === replyId);
                    if (reply) {
                        if (!reply.likes) reply.likes = 0;

                        reply.likes++;

                        const replyElement = document.querySelector(`[data-reply-id="${replyId}"]`);
                        if (replyElement) {
                            const likeCountElement = replyElement.querySelector('.like-count');
                            if (likeCountElement) {
                                likeCountElement.textContent = reply.likes;
                            }
                        }

                        saveAllComments();
                        return;
                    }
                }
            }
        }

        function toggleReplyDislike(replyId) {
            for (const comment of comments) {
                if (comment.replies) {
                    const reply = comment.replies.find(r => r.id === replyId);
                    if (reply) {
                        if (!reply.dislikes) reply.dislikes = 0;

                        reply.dislikes++;

                        const replyElement = document.querySelector(`[data-reply-id="${replyId}"]`);
                        if (replyElement) {
                            const dislikeCountElement = replyElement.querySelector('.dislike-count');
                            if (dislikeCountElement) {
                                dislikeCountElement.textContent = reply.dislikes;
                            }
                        }

                        saveAllComments();
                        return;
                    }
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function initImageModal() {
            const modal = document.getElementById('imageModal');
            const closeBtn = document.querySelector('.close');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    modal.style.display = 'none';
                });
            }

            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            }
        }
        function setCurrentVideo(videoName, playlistHandle) {
            loadComments();
        }

        document.addEventListener('DOMContentLoaded', loadCommentsSystem);

        function initCommentKaomojiPicker() {
            if (window.KaomojiPicker) {
                if (window.KaomojiPicker.instances) {
                    window.KaomojiPicker.instances.forEach(instance => {
                        const btn = instance.button;
                        if (btn && btn.id === 'insertKaomojiBtn') {
                            instance.destroy();
                        }
                    });
                }

                const commentText = document.getElementById('commentText');
                const kaomojiBtn = document.getElementById('insertKaomojiBtn');

                if (commentText && kaomojiBtn) {
                    new window.KaomojiPicker(commentText, {
                        triggerElement: kaomojiBtn
                    });
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initCommentKaomojiPicker, 100);
        });

        window.initCommentKaomojiPicker = initCommentKaomojiPicker;
    </script>

    <!-- Tag Broadcast Sync - MUST BE LOADED BEFORE TAGS EDIT SCRIPT -->
    <script src="youvi/tags/tag-broadcast-sync.js"></script>

    <!-- Tags Edit Functionality -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const tagsEditForm = document.getElementById('tagsEditForm');
            const tagsEditInput = document.getElementById('tagsEditInput');
            const tagsEditCancel = document.getElementById('tagsEditCancel');
            const tagsEditSave = document.getElementById('tagsEditSave');
            const videoTags = document.getElementById('videoTags');

            if (!tagsEditForm || !tagsEditInput || !tagsEditCancel || !tagsEditSave || !videoTags) {
                console.warn('Tags edit elements not found');
                return;
            }

            if (window.TagInputAutocomplete) {
                window.tagsEditAutocomplete = new TagInputAutocomplete(tagsEditInput, {
                    minChars: 1,
                    maxResults: 10,
                    onSelect: (tag) => {
                        console.log('[TagsEdit] Autocomplete selected:', tag.canonical);
                    }
                });
            }

            tagsEditCancel.addEventListener('click', () => {
                tagsEditForm.style.display = 'none';
                const originalTags = window.originalVideoTags || [];
                window.updateVideoTagsDisplay(originalTags);
            });

            tagsEditSave.addEventListener('click', async () => {
                const newTagsText = tagsEditInput.value.trim();
                let newTags = newTagsText ? newTagsText.split(',').map(tag => tag.trim()).filter(tag => tag) : [];

                try {
                    const tagTypeAliases = {
                        '(ka)': '()',
                        '(gt)': '(gt)',
                        '(ch)': '(ch)',
                        '(au)': '(au)',
                        '(ge)': '(ge)',
                        '(ct)': '(ct)',
                    };
                    newTags = newTags.map(tag => {
                        if (tag.endsWith(' (ka)')) {
                            return tag.replace(' (ka)', ' ()');
                        }
                        return tag;
                    });

                    if (window.tagDatabaseManager && window.tagDatabaseManager.isLoaded) {
                        newTags = newTags.map(tag => {
                            const tagData = window.tagDatabaseManager.getTag(tag);
                            return tagData ? tagData.canonical : tag;
                        });
                    }

                    if (window.TagTypes) {
                        const validation = window.TagTypes.validateTags(newTags);
                        if (!validation.valid) {
                            alert('  :\n\n' + validation.errors.join('\n'));
                            return;
                        }
                    } else {
                        const authorTags = newTags.filter(tag => tag.endsWith(' ()'));
                        if (authorTags.length > 1) {
                            alert('       (  " ()")');
                            return;
                        }
                    }

                    if (window.applyTagImplications) {
                        const expandedTags = window.applyTagImplications(newTags);
                        newTags = expandedTags;
                    }

                    const currentVideoName = window.currentVideoName;
                    const currentPlaylistHandle = window.currentPlaylistHandle;

                    if (currentVideoName && currentPlaylistHandle) {
                        const metadata = await getVideoMetadata(currentPlaylistHandle, currentVideoName);
                        const oldTags = metadata.tags || [];
                        metadata.tags = Array.from(new Set(newTags));

                        await saveVideoMetadata(currentPlaylistHandle, currentVideoName, metadata);

                        let usedDirectDbUpdate = false;
                        if (window.tagDatabaseManager && window.tagDatabaseManager.isLoaded) {
                            const canon = (arr) => arr.map(t => {
                                const d = window.tagDatabaseManager.getTag(t);
                                return d ? d.canonical : t;
                            });
                            const oldC = canon(oldTags);
                            const newC = canon(newTags);
                            const removed = oldC.filter(t => !newC.includes(t));
                            const added = newC.filter(t => !oldC.includes(t));
                            if (removed.length > 0) {
                                await window.tagDatabaseManager.decrementUsageBatch(removed);
                            }
                            if (added.length > 0) {
                                const toIncrement = [];
                                for (const t of added) {
                                    const exists = window.tagDatabaseManager.getTag(t);
                                    if (exists) {
                                        toIncrement.push(t);
                                    } else {
                                        await window.tagDatabaseManager.addTag(t, { usageCount: 1, immediate: false });
                                    }
                                }
                                if (toIncrement.length > 0) {
                                    await window.tagDatabaseManager.incrementUsageBatch(toIncrement);
                                }
                            }
                            await window.tagDatabaseManager.saveDatabase(true);
                            usedDirectDbUpdate = true;
                        }
                        if (window.tagBroadcastSync) {
                            if (usedDirectDbUpdate) {
                                window.tagBroadcastSync.broadcastDatabaseUpdated();
                            } else {
                                window.tagBroadcastSync.broadcastTagsChanged(currentVideoName, oldTags, newTags);
                            }
                        }

                        window.updateVideoTagsDisplay(newTags);

                        if (window.currentVideo) {
                            window.currentVideo.tags = newTags;
                            
                            const uploaderNameEl = document.getElementById('uploaderName');
                            if (uploaderNameEl && window.TagTypes) {
                                const channelTag = newTags.find(t => t.endsWith(' ()'));
                                if (channelTag) {
                                    const channelName = channelTag.replace(' ()', '');
                                    window.currentChannelName = channelName;
                                    uploaderNameEl.innerHTML = `<a href="youvi_ch_view.html?channel=${encodeURIComponent(channelName)}" style="color:inherit;text-decoration:none;">${channelName}</a>`;
                                } else {
                                    window.currentChannelName = null;
                                    uploaderNameEl.textContent = i18n.t('video.noChannel', 'No channel');
                                }
                            }
                        }

                        tagsEditForm.style.display = 'none';
                        window.updateVideoTagsDisplay(newTags);

                        debug.log('Tags updated successfully');
                    } else {
                        alert(':       ');
                    }
                } catch (error) {
                    console.error('Error updating tags:', error);
                    alert('   : ' + error.message);
                }
            });

            tagsEditInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    if (window.tagsEditAutocomplete && window.tagsEditAutocomplete.isOpen) {
                        return;
                    }
                    e.preventDefault();
                    tagsEditSave.click();
                } else if (e.key === 'Escape') {
                    if (window.tagsEditAutocomplete && window.tagsEditAutocomplete.isOpen) {
                        return;
                    }
                    e.preventDefault();
                    tagsEditCancel.click();
                }
            });

            window.updateVideoTagsDisplay = function (tags) {
                window.originalVideoTags = tags;

                const tagsHtml = window.TagTypes ?
                    window.TagTypes.renderTags(tags, 24, true) :
                    tags.filter(tag => !tag.endsWith('()')).slice(0, 24).map(tag => {
                        const href = `youvi_main.html?tag=${encodeURIComponent(tag)}`;
                        return `<a class="video-tag" href="${href}">${escapeHtml(tag)}</a>`;
                    }).join('');

                const editButtonHtml = `
                    <button class="edit-tags-btn" id="editTagsBtn" data-i18n-title="video.editTags" title="Edit tags">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                        <span data-i18n="video.edit">Edit</span>
                    </button>
                `;

                videoTags.innerHTML = tagsHtml + editButtonHtml;

                const newEditBtn = document.getElementById('editTagsBtn');
                if (newEditBtn) {
                    newEditBtn.addEventListener('click', () => {
                        const currentTags = window.originalVideoTags || [];

                        tagsEditInput.value = currentTags.join(', ');

                        tagsEditForm.style.display = 'flex';
                        newEditBtn.style.display = 'none';

                        tagsEditInput.focus();
                    });
                }
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            window.addEventListener('beforeunload', () => {
                try {
                    if (clockTimer) {
                        clearInterval(clockTimer);
                        clockTimer = null;
                    }
                    if (speedHudTimer) {
                        clearTimeout(speedHudTimer);
                        speedHudTimer = null;
                    }
                    if (volumeHudTimer) {
                        clearTimeout(volumeHudTimer);
                        volumeHudTimer = null;
                    }
                    if (holdTimer) {
                        clearTimeout(holdTimer);
                        holdTimer = null;
                    }
                    if (seekHudTimer) {
                        clearTimeout(seekHudTimer);
                        seekHudTimer = null;
                    }
                    if (autoplayTimer) {
                        clearInterval(autoplayTimer);
                        autoplayTimer = null;
                    }

                    if (typeof avatarCache !== 'undefined') {
                        for (let [key, value] of avatarCache) {
                            if (value && value.url && value.url.startsWith('blob:')) {
                                try {
                                    URL.revokeObjectURL(value.url);
                                } catch (e) {
                                    console.warn('Failed to revoke blob URL:', e);
                                }
                            }
                        }
                        avatarCache.clear();
                    }

                    if (typeof carouselVideoPages !== 'undefined') {
                        carouselVideoPages.clear();
                    }
                    if (typeof allPlaylistCategories !== 'undefined') {
                        allPlaylistCategories.clear();
                    }

                    if (typeof allVideos !== 'undefined') {
                        allVideos.length = 0;
                    }
                    if (typeof allPlaylists !== 'undefined') {
                        allPlaylists.length = 0;
                    }

                    debug.log('Page cleanup completed');
                } catch (error) {
                    console.warn('Error during page cleanup:', error);
                }
            });

            setInterval(() => {
                try {
                    if (typeof cleanupAvatarCache === 'function') {
                        cleanupAvatarCache();
                    }
                    if (typeof checkStorageQuota === 'function') {
                        checkStorageQuota().catch(console.warn);
                    }
                } catch (error) {
                    console.warn('Error during periodic cleanup:', error);
                }
            }, 2 * 60 * 1000);
        });
    </script>

    <!-- Tag Implication Auto-Update Handler -->
    <script>
        if (window.tagBroadcastSync) {
            window.tagBroadcastSync.addEventListener(async (event) => {
                debug.log('[TagImplication]  Received broadcast event:', event);

                if (event.type === 'tag_implication_added') {
                    const { tagName, implications } = event.data;
                    debug.log('[TagImplication]  ImIplication added in another tab:', tagName, implications);

                    if (window.tagImplicationResolver) {
                        window.tagImplicationResolver.invalidateCache();
                        debug.log('[TagImplication]  Cache invalidated');
                    }

                    if (window.tagDatabaseManager && window.tagDatabaseManager.isLoaded) {
                        try {
                            await window.tagDatabaseManager.loadDatabase();
                            debug.log('[TagImplication]  Database reloaded');
                        } catch (error) {
                            console.warn('[TagImplication]  Failed to reload database:', error);
                        }
                    }

                    document.dispatchEvent(new CustomEvent('tagImplicationUpdated', {
                        detail: { tagName, implications }
                    }));
                }

                if (event.type === 'tag_implication_removed') {
                    const { tagName, removedImplication, implications } = event.data;
                    debug.log('[TagImplication]  Impliciation removed in another tab:', tagName, removedImplication);

                    if (window.tagImplicationResolver) {
                        window.tagImplicationResolver.invalidateCache();
                        debug.log('[TagImplication]  Cache invalidated');
                    }

                    if (window.tagDatabaseManager && window.tagDatabaseManager.isLoaded) {
                        try {
                            await window.tagDatabaseManager.loadDatabase();
                            debug.log('[TagImplication]  Database r eloaded');
                        } catch (error) {
                            console.warn('[TagImplication]  Failed to reload database:', error);
                        }
                    }

                    document.dispatchEvent(new CustomEvent('tagImplicationUpdated', {
                        detail: { tagName, implications }
                    }));

                    document.dispatchEvent(new CustomEvent('tagImplicationRemoved', {
                        detail: { tagName, removedImplication }
                    }));
                }
            });

            debug.log('[TagImplication]  Broadcast listener registered');
        } else {
            console.warn('[TagImplication]  tagBroadcastSync not available');
        }

        document.addEventListener('tagImplicationUpdated', async (e) => {
            const { tagName, implications } = e.detail;

            if (window.currentVideo && window.currentVideo.tags && Array.isArray(window.currentVideo.tags)) {
                const hasTag = window.currentVideo.tags.some(t => {
                    if (!window.tagDatabaseManager) return t === tagName;
                    const tData = window.tagDatabaseManager.getTag(t);
                    const tagData = window.tagDatabaseManager.getTag(tagName);
                    if (!tData || !tagData) return t === tagName;
                    return tData.canonical === tagData.canonical;
                });

                if (hasTag && window.applyTagImplications) {
                    const oldTags = [...window.currentVideo.tags];
                    const expandedTags = window.applyTagImplications(oldTags);

                    if (expandedTags.length > oldTags.length) {
                        const addedCount = expandedTags.length - oldTags.length;
                        debug.log(`[TagImplication]  Auto-updated current video: +${addedCount} tags`);

                        window.currentVideo.tags = expandedTags;

                        if (window.currentVideoName && window.currentPlaylistHandle) {
                            try {
                                const metadata = await getVideoMetadata(window.currentPlaylistHandle, window.currentVideoName);
                                metadata.tags = expandedTags;
                                await saveVideoMetadata(window.currentPlaylistHandle, window.currentVideoName, metadata);

                                if (window.updateVideoTagsDisplay) {
                                    window.updateVideoTagsDisplay(expandedTags);
                                }

                                debug.log('[TagImplication]  Video metadata updated with new implications');
                            } catch (error) {
                                console.error('[TagImplication]  Failed to save updated tags:', error);
                            }
                        }
                    }
                }
            }
        });

        document.addEventListener('tagImplicationRemoved', async (e) => {
            const { tagName, removedImplication } = e.detail;
            debug.log('[TagImplication] Implication removed:', tagName, '', removedImplication);

            if (window.currentVideo && window.currentVideo.tags && Array.isArray(window.currentVideo.tags)) {
                const hasTag = window.currentVideo.tags.some(t => {
                    if (!window.tagDatabaseManager) return t === tagName;
                    const tData = window.tagDatabaseManager.getTag(t);
                    const tagData = window.tagDatabaseManager.getTag(tagName);
                    if (!tData || !tagData) return t === tagName;
                    return tData.canonical === tagData.canonical;
                });

                if (hasTag && window.tagImplicationResolver) {
                    const otherTags = window.currentVideo.tags.filter(t => {
                        if (!window.tagDatabaseManager) return t !== tagName;
                        const tData = window.tagDatabaseManager.getTag(t);
                        const tagData = window.tagDatabaseManager.getTag(tagName);
                        if (!tData || !tagData) return t !== tagName;
                        return tData.canonical !== tagData.canonical;
                    });

                    const stillImplied = window.tagImplicationResolver.resolveImplicationsBatch(otherTags);
                    const removedImplicationNormalized = window.TagDatabaseSchema ?
                        window.TagDatabaseSchema.normalizeTagName(removedImplication) :
                        removedImplication.toLowerCase();

                    if (!stillImplied.has(removedImplicationNormalized)) {
                        const oldTags = [...window.currentVideo.tags];
                        const newTags = oldTags.filter(t => {
                            if (!window.tagDatabaseManager) return t !== removedImplication;
                            const tData = window.tagDatabaseManager.getTag(t);
                            const removedData = window.tagDatabaseManager.getTag(removedImplication);
                            if (!tData || !removedData) return t !== removedImplication;
                            return tData.canonical !== removedData.canonical;
                        });

                        if (newTags.length < oldTags.length) {
                            const removedCount = oldTags.length - newTags.length;
                            debug.log(`[TagImplication]  Auto-updated current video: -${removedCount} tags`);

                            window.currentVideo.tags = newTags;

                            if (window.currentVideoName && window.currentPlaylistHandle) {
                                try {
                                    const metadata = await getVideoMetadata(window.currentPlaylistHandle, window.currentVideoName);
                                    metadata.tags = newTags;
                                    await saveVideoMetadata(window.currentPlaylistHandle, window.currentVideoName, metadata);

                                    if (window.updateVideoTagsDisplay) {
                                        window.updateVideoTagsDisplay(newTags);
                                    }

                                    debug.log('[TagImplication]  Video metadata updated after implication removal');
                                } catch (error) {
                                    console.error('[TagImplication]  Failed to save updated tags:', error);
                                }
                            }
                        }
                    } else {
                        debug.log('[TagImplication] Tag still implied by other tags, keeping it');
                    }
                }
            }
        });
    </script>

    <!-- Header and Sidebar Scripts -->
    <script src="youvi/header/youvi-header.js"></script>
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/danmaku-counter.js"></script>
    
    <!-- i18n System -->
    <script src="youvi/i18n/ru.js"></script>
    <script src="youvi/i18n/en.js"></script>
    <script src="youvi/i18n/uk.js"></script>
    <script src="youvi/i18n/i18n.js"></script>
    <!-- Recommendations Module -->
    <script src="youvi/recommendations_video_watch.js"></script>

    <!-- Autocomplete -->
    <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
    <link rel="stylesheet" href="youvi/autocomplete/tag-input-autocomplete.css">
    <script src="youvi/autocomplete-data-loader.js"></script>
    <script src="youvi/autocomplete/autocomplete.js"></script>
    <script src="youvi/autocomplete/tag-input-autocomplete.js"></script>
    <script src="youvi/autocomplete/autocomplete-cache.js"></script>
    <script src="youvi/autocomplete/autocomplete-integration.js"></script>

    <!-- Theme Toggle Script -->
    <script src="youvi/themes/theme-toggle.js"></script>

    <!-- Universal Image Viewer Module -->
    <script src="youvi/image-viewer.js"></script>

    <!-- Comment Images Module -->
    <script src="youvi/comments/comment-images.js"></script>

    <!-- Tag Types Module -->
    <script src="youvi/tag-types/tag-types.js"></script>

    <!-- Kaomoji Picker Module -->
    <script src="youvi/kaomoji-picker/kaomoji-picker.js"></script>

    <!-- Tag Database System -->
    <script src="youvi/tags/tag-database-schema.js"></script>
    <script src="youvi/tags/tag-database-manager.js"></script>

    <!-- Tag Implication System -->
    <script src="youvi/tags/tag-implication-resolver.js"></script>
    <script src="youvi/tags/debug-implications.js"></script>
    <script src="youvi/tags/debug-aliases.js"></script>

    <!-- Timecode Loop Module -->
    <script src="youvi/timecode-loop/timecode-loop.js"></script>

    <!-- Virtual Playlist Module -->
    <script src="youvi/virtual-playlist/avatar-batch-loader.js"></script>
    <script src="youvi/virtual-playlist/virtual-playlist.js"></script>

    <!-- Wide Screen Mode -->
    <script src="youvi/danmaku-scroll-sync.js"></script>
    <script src="youvi/widescreen-mode.js"></script>

    <!-- Document Picture-in-Picture Module -->
    <script src="youvi/pip/document-pip.js"></script>

    <!-- Initialize Kaomoji Picker for Danmaku Input -->
    <script>
        let danmakuKaomojiPickerInstance = null;

        function initDanmakuKaomojiPicker() {
            debug.log('[KaomojiPicker] Init called');

            let targetDoc = document;
            let danmakuTextInput = null;
            let danmakuKaomojiBtn = null;

            if (window.documentPiPManager && window.documentPiPManager.pipWindow) {
                const pipDoc = window.documentPiPManager.pipWindow.document;
                danmakuTextInput = pipDoc.getElementById('danmakuText');
                danmakuKaomojiBtn = pipDoc.getElementById('danmakuKaomojiBtn');
                if (danmakuTextInput && danmakuKaomojiBtn) {
                    targetDoc = pipDoc;
                    debug.log('[KaomojiPicker] Elements found in PiP');
                }
            }

            if (!danmakuTextInput || !danmakuKaomojiBtn) {
                danmakuTextInput = document.getElementById('danmakuText');
                danmakuKaomojiBtn = document.getElementById('danmakuKaomojiBtn');
                targetDoc = document;
                debug.log('[KaomojiPicker] Elements found in main document');
            }

            if (!danmakuTextInput || !danmakuKaomojiBtn) {
                console.warn('Danmaku kaomoji elements not found');
                return;
            }

            if (!window.KaomojiPicker) {
                console.warn('KaomojiPicker not loaded yet');
                return;
            }

            if (window.KaomojiPicker.instances && window.KaomojiPicker.instances.length > 0) {
                const instances = [...window.KaomojiPicker.instances];
                instances.forEach(instance => {
                    try {
                        instance.destroy();
                    } catch (e) {
                        console.warn('Failed to destroy kaomoji picker instance:', e);
                    }
                });
            }

            if (danmakuKaomojiPickerInstance && danmakuKaomojiPickerInstance.destroy) {
                try {
                    danmakuKaomojiPickerInstance.destroy();
                } catch (e) {
                    console.warn('Failed to destroy stored kaomoji picker:', e);
                }
                danmakuKaomojiPickerInstance = null;
            }

            try {
                danmakuKaomojiPickerInstance = new window.KaomojiPicker(danmakuTextInput, {
                    compact: true,
                    position: 'top',
                    triggerElement: danmakuKaomojiBtn,
                    pipContext: targetDoc !== document ? targetDoc : null
                });
                debug.log('Danmaku kaomoji picker initialized in', targetDoc !== document ? 'PiP' : 'main window');
            } catch (e) {
                console.error('Failed to initialize danmaku kaomoji picker:', e);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDanmakuKaomojiPicker);
        } else {
            initDanmakuKaomojiPicker();
        }

        window.initDanmakuKaomojiPicker = initDanmakuKaomojiPicker;
    </script>

    <!-- Timecode Context Menu -->
    <div id="timecodeContextMenu" class="timecode-context-menu">
        <button class="timecode-context-menu-item" data-action="loop"></button>
        <button class="timecode-context-menu-item" data-action="exit-loop">  </button>
    </div>

    <!-- Multiview Overlay -->
    <div class="multiview-overlay" id="multiviewOverlay">
        <div class="multiview-header">
            <span class="multiview-title">
                <img src="images/logo_youvi_ind.png" alt="Youvi" style="height:32px;">
                <span class="multiview-title-text" style="color:#ff69b4;font-family:'VAGRoundedCyrillic',Arial,sans-serif;font-size:18px;">multiview</span>
            </span>
            <div class="multiview-controls">
                <button class="multiview-layout-btn" data-layout="1v2h" title="1  + 2 ">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="2" width="8" height="20" rx="1"/>
                        <rect x="12" y="2" width="10" height="9" rx="1"/>
                        <rect x="12" y="13" width="10" height="9" rx="1"/>
                    </svg>
                    1V+2H
                </button>
                <button class="multiview-layout-btn active" data-layout="2h" title="2 ">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="4" width="9" height="16" rx="1"/>
                        <rect x="13" y="4" width="9" height="16" rx="1"/>
                    </svg>
                    2H
                </button>
                <button class="multiview-layout-btn" data-layout="2v" title="2 ">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="4" y="2" width="16" height="9" rx="1"/>
                        <rect x="4" y="13" width="16" height="9" rx="1"/>
                    </svg>
                    2V
                </button>
                <button class="multiview-layout-btn" data-layout="2v2h" title="2  + 2 ">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="2" width="9" height="9" rx="1"/>
                        <rect x="2" y="13" width="9" height="9" rx="1"/>
                        <rect x="13" y="2" width="9" height="9" rx="1"/>
                        <rect x="13" y="13" width="9" height="9" rx="1"/>
                    </svg>
                    2V+2H
                </button>
                <button class="multiview-layout-btn" data-layout="4h" title="4 ">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="2" y="2" width="9" height="9" rx="1"/>
                        <rect x="13" y="2" width="9" height="9" rx="1"/>
                        <rect x="2" y="13" width="9" height="9" rx="1"/>
                        <rect x="13" y="13" width="9" height="9" rx="1"/>
                    </svg>
                    4H
                </button>
                <button class="multiview-fullscreen-btn" id="multiviewFullscreenBtn" data-i18n-title="player.fullscreen" title="Fullscreen (F)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3"/>
                        <path d="M21 8V5a2 2 0 0 0-2-2h-3"/>
                        <path d="M3 16v3a2 2 0 0 0 2 2h3"/>
                        <path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
                    </svg>
                </button>
                <button class="multiview-close-btn" id="multiviewCloseBtn" data-i18n="multiview.close">Close (Esc)</button>
            </div>
        </div>
        <div class="multiview-content">
            <div class="multiview-grid layout-2h" id="multiviewGrid">
                <!-- Slots will be generated by JS -->
            </div>
        </div>
        
        <!-- Search Panel INSIDE overlay for fullscreen support -->
        <div class="multiview-search-panel" id="multiviewSearchPanel">
            <div class="multiview-search-header">
                <h4 data-i18n="multiview.selectVideo">Select video</h4>
                <button class="multiview-search-close" id="multiviewSearchClose">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="multiview-search-body">
                <input type="text" class="multiview-search-input" id="multiviewSearchInput" data-i18n-placeholder="multiview.searchPlaceholder" placeholder="Search by title or tag..." autocomplete="off">
                <div class="multiview-search-results" id="multiviewSearchResults">
                    <!-- Results populated via JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Parent/Child Video Logic & Dependencies -->
    <script src="youvi/tag-types/tag-types.js"></script>
    <script src="youvi/search/search-logic.js"></script>
    <script>
        (function () {
            const pcState = {
                parents: [],
                children: [],
                selectedSearchResults: new Set(),
                searchQuery: '',
                currentVideoName: null,
                currentDirHandle: null,
                searchAbortController: null
            };

            let videoLookupMap = null;
            
            function getVideoByName(name) {
                if (!videoLookupMap && window.allVideos?.length) {
                    videoLookupMap = new Map(window.allVideos.map(v => [v.name, v]));
                }
                return videoLookupMap?.get(name) || null;
            }
            
            function invalidateVideoCache() {
                videoLookupMap = null;
            }

            const getViewsLabel = (n) => {
                return i18n.t('video.views', 'views');
            };

            const els = {
                section: document.getElementById('parentChildSection'),
                addBtn: document.getElementById('addRelatedVideoBtn'),
                searchPanel: document.getElementById('relatedVideoSearchPanel'),
                searchInput: document.getElementById('relatedSearchInput'),
                searchResults: document.getElementById('relatedSearchResults'),
                addChildrenBtn: document.getElementById('addSelectedToChildrenBtn'),
                addParentsBtn: document.getElementById('addSelectedToParentsBtn'),
                closeSearchBtn: document.getElementById('closeRelatedSearchBtn'),
                childCarousel: document.getElementById('childVideosCarousel'),
                parentCarousel: document.getElementById('parentVideosCarousel')
            };

            async function init() {
                if (!els.addBtn) return;

                bindEvents();

                if (!window.allVideos || window.allVideos.length === 0) {
                    if (window.AutocompleteDataLoader) {
                        try {
                            const data = await window.AutocompleteDataLoader.loadData();
                            window.allVideos = data.videos || [];
                            invalidateVideoCache();
                        } catch (e) {
                            console.warn('[ParentChild] Failed to load video data:', e);
                        }
                    }
                }

                const video = document.getElementById('video');
                if (video) {
                    video.addEventListener('loadedmetadata', onVideoLoaded);
                }

                if (window.currentVideo) {
                    onVideoLoaded();
                }

                window.addEventListener('youvi:videoChanged', () => {
                    if (window.currentVideo && window.currentVideo.name !== pcState.currentVideoName) {
                        onVideoLoaded();
                    }
                });
                
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden && window.currentVideo && window.currentVideo.name !== pcState.currentVideoName) {
                        onVideoLoaded();
                    }
                });
            }

            async function onVideoLoaded() {
                if (!window.currentVideo) return;
                if (pcState.currentVideoName === window.currentVideo.name) return;

                pcState.currentVideoName = window.currentVideo.name;
                pcState.currentDirHandle = window.currentVideo.dirHandle || window.currentPlaylistHandle;
                invalidateVideoCache();
                await loadData();
            }

            async function loadData() {
                if (!pcState.currentVideoName || !pcState.currentDirHandle) {
                    pcState.parents = [];
                    pcState.children = [];
                    renderCarousels();
                    return;
                }

                try {
                    const metaDir = await pcState.currentDirHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = pcState.currentVideoName + '.relations.json';
                    
                    let exists = false;
                    for await (const [name] of metaDir.entries()) {
                        if (name === fileName) {
                            exists = true;
                            break;
                        }
                    }
                    
                    if (exists) {
                        const fileHandle = await metaDir.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        pcState.parents = data.parents || [];
                        pcState.children = data.children || [];
                        debug.log('[ParentChild] Loaded relations:', { parents: pcState.parents.length, children: pcState.children.length });
                    } else {
                        pcState.parents = [];
                        pcState.children = [];
                    }
                } catch (e) {
                    console.warn('[ParentChild] Failed to load relations data:', e);
                    pcState.parents = [];
                    pcState.children = [];
                }
                
                renderCarousels();
            }

            async function saveData() {
                if (!pcState.currentVideoName || !pcState.currentDirHandle) return;

                try {
                    const metaDir = await pcState.currentDirHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = pcState.currentVideoName + '.relations.json';
                    const fileHandle = await metaDir.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    
                    const data = {
                        parents: pcState.parents,
                        children: pcState.children,
                        updated: Date.now()
                    };
                    
                    await writable.write(JSON.stringify(data, null, 2));
                    await writable.close();
                    
                    debug.log('[ParentChild] Relations saved to file');
                } catch (e) {
                    console.error('[ParentChild] Failed to save relations data:', e);
                }
            }

            let searchDebounceTimer = null;
            const debounce = (fn, delay) => {
                return (...args) => {
                    clearTimeout(searchDebounceTimer);
                    searchDebounceTimer = setTimeout(() => fn(...args), delay);
                };
            };

            function bindEvents() {
                els.addBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    els.searchPanel.style.display = 'flex';
                    els.searchInput.value = '';
                    els.searchInput.focus();
                    performSearch('');
                });

                els.closeSearchBtn.addEventListener('click', closeSearch);

                const debouncedSearch = debounce((val) => performSearch(val), 150);
                els.searchInput.addEventListener('input', (e) => {
                    debouncedSearch(e.target.value);
                });

                els.addChildrenBtn.addEventListener('click', () => addSelected('children'));
                els.addParentsBtn.addEventListener('click', () => addSelected('parents'));

                document.addEventListener('click', (e) => {
                    if (els.searchPanel.style.display === 'flex' &&
                        !els.searchPanel.contains(e.target) &&
                        !els.addBtn.contains(e.target)) {
                        closeSearch();
                    }
                });

                document.querySelectorAll('.pc-nav-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const carouselId = btn.dataset.carousel;
                        const carousel = document.getElementById(carouselId);
                        if (!carousel) return;
                        
                        const cardWidth = 170;
                        const visibleWidth = carousel.offsetWidth;
                        const scrollAmount = Math.floor(visibleWidth / cardWidth) * cardWidth;
                        
                        if (btn.classList.contains('prev')) {
                            carousel.scrollLeft -= scrollAmount;
                        } else {
                            carousel.scrollLeft += scrollAmount;
                        }
                        
                        setTimeout(() => updateNavButtons(carousel), 300);
                    });
                });
            }

            function updateNavButtons(carousel) {
                const wrapper = carousel.closest('.pc-carousel-wrapper');
                if (!wrapper) return;
                
                const prevBtn = wrapper.querySelector('.pc-nav-btn.prev');
                const nextBtn = wrapper.querySelector('.pc-nav-btn.next');
                
                if (prevBtn) {
                    prevBtn.disabled = carousel.scrollLeft <= 0;
                }
                if (nextBtn) {
                    nextBtn.disabled = carousel.scrollLeft >= carousel.scrollWidth - carousel.offsetWidth - 10;
                }
            }

            function closeSearch() {
                els.searchPanel.style.display = 'none';
                pcState.selectedSearchResults.clear();
                if (pcState.searchAbortController) {
                    pcState.searchAbortController.abort();
                    pcState.searchAbortController = null;
                }
            }

            function performSearch(query) {
                const sourceVideos = window.allVideos || [];

                if (typeof evaluateBooleanQuery !== 'function') {
                    const lowerQ = query.toLowerCase();
                    const results = sourceVideos.filter(v => v.name && v.name.toLowerCase().includes(lowerQ));
                    renderSearchResults(results.slice(0, 50));
                    return;
                }

                if (!query) {
                    renderSearchResults(sourceVideos.slice(0, 50));
                    return;
                }

                try {
                    const results = evaluateBooleanQuery(query, sourceVideos, (basicQuery) => {
                        const lowerQ = basicQuery.toLowerCase();
                        return sourceVideos.filter(v =>
                            (v.name && v.name.toLowerCase().includes(lowerQ)) ||
                            (v.tags && v.tags.some(t => t.toLowerCase().includes(lowerQ)))
                        );
                    });
                    renderSearchResults(results.slice(0, 50));
                } catch (e) {
                    console.error('[ParentChild] Search error:', e);
                    const lowerQ = query.toLowerCase();
                    const results = sourceVideos.filter(v => v.name && v.name.toLowerCase().includes(lowerQ));
                    renderSearchResults(results.slice(0, 50));
                }
            }

            function renderSearchResults(videos) {
                els.searchResults.innerHTML = '';
                if (videos.length === 0) {
                    els.searchResults.innerHTML = `<div style="padding:10px;text-align:center;color:#999;">${i18n.t('search.noResults', 'Nothing found')}</div>`;
                    return;
                }

                const fragment = document.createDocumentFragment();
                const thumbsToLoad = [];

                videos.forEach(v => {
                    const item = document.createElement('div');
                    item.className = 'pc-search-item';
                    if (pcState.selectedSearchResults.has(v.name)) {
                        item.classList.add('selected');
                    }

                    let tagsHtml = '';
                    if (window.TagTypes && v.tags && v.tags.length > 0) {
                        tagsHtml = `<div class="pc-video-tags" style="margin-top:4px;display:flex;gap:4px;flex-wrap:wrap;">
                            ${window.TagTypes.renderTags(v.tags, 6, false)}
                        </div>`;
                    }

                    item.innerHTML = `
                        <div class="pc-search-item-thumb loading"></div>
                        <div style="flex:1;min-width:0;">
                            <div style="font-size:13px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${removeExtension(v.name || '')}</div>
                            ${tagsHtml}
                        </div>
                    `;

                    const thumbEl = item.querySelector('.pc-search-item-thumb');
                    thumbsToLoad.push({ thumbEl, video: v });

                    item.addEventListener('click', () => {
                        if (pcState.selectedSearchResults.has(v.name)) {
                            pcState.selectedSearchResults.delete(v.name);
                            item.classList.remove('selected');
                        } else {
                            pcState.selectedSearchResults.add(v.name);
                            item.classList.add('selected');
                        }
                    });

                    fragment.appendChild(item);
                });

                els.searchResults.appendChild(fragment);

                if (typeof getPreviewAndDuration === 'function') {
                    const BATCH_SIZE = 5;
                    let batchIndex = 0;
                    
                    const loadBatch = () => {
                        const batch = thumbsToLoad.slice(batchIndex, batchIndex + BATCH_SIZE);
                        if (batch.length === 0) return;
                        
                        batch.forEach(({ thumbEl, video }) => {
                            getPreviewAndDuration(video).then(({ preview, duration }) => {
                                thumbEl.classList.remove('loading');
                                if (preview) {
                                    const img = document.createElement('img');
                                    img.src = preview;
                                    thumbEl.appendChild(img);
                                }
                                if (duration) {
                                    const durationEl = document.createElement('div');
                                    durationEl.className = 'pc-search-item-duration';
                                    durationEl.textContent = duration;
                                    thumbEl.appendChild(durationEl);
                                }
                            }).catch(() => {
                                thumbEl.classList.remove('loading');
                            });
                        });
                        
                        batchIndex += BATCH_SIZE;
                        if (batchIndex < thumbsToLoad.length) {
                            requestIdleCallback(loadBatch, { timeout: 100 });
                        }
                    };
                    
                    requestIdleCallback(loadBatch, { timeout: 50 });
                }
            }

            async function addSelected(targetType) {
                const sourceVideos = window.allVideos || [];
                const selectedNames = Array.from(pcState.selectedSearchResults);
                const videosToAdd = sourceVideos
                    .filter(v => selectedNames.includes(v.name))
                    .map(v => ({ name: v.name, dirHandle: v.dirHandle }));

                const currentNames = new Set(pcState[targetType].map(v => v.name));
                const uniqueToAdd = videosToAdd.filter(v => !currentNames.has(v.name));

                pcState[targetType] = [...pcState[targetType], ...uniqueToAdd.map(v => ({ name: v.name }))];
                await saveData();
                
                const reverseType = targetType === 'parents' ? 'children' : 'parents';
                for (const v of uniqueToAdd) {
                    await addReverseRelationship(v.name, v.dirHandle, pcState.currentVideoName, reverseType);
                }
                
                renderCarousels();
                closeSearch();
            }
            
            async function addReverseRelationship(targetVideoName, targetDirHandle, currentVideoName, relationshipType) {
               
                const dirHandle = targetDirHandle || pcState.currentDirHandle;
                if (!dirHandle) {
                    console.warn('[ParentChild] No directory handle available');
                    return;
                }
                
                try {
                    const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = targetVideoName + '.relations.json';
                    
                    let data = { parents: [], children: [] };
                    try {
                        const fileHandle = await metaDir.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        data = JSON.parse(text);
                    } catch (e) {
                    }
                    
                    const list = data[relationshipType] || [];
                    
                    if (!list.some(v => v.name === currentVideoName)) {
                        list.push({ name: currentVideoName });
                        data[relationshipType] = list;
                        data.updated = Date.now();
                        
                        const fileHandle = await metaDir.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(data, null, 2));
                        await writable.close();
                        
                        debug.log(`[ParentChild] Added reverse relationship: ${targetVideoName} -> ${relationshipType} -> ${currentVideoName}`);
                    }
                } catch (e) {
                    console.warn('[ParentChild] Failed to add reverse relationship:', e);
                }
            }
            
            async function removeReverseRelationship(targetVideoName, targetDirHandle, currentVideoName, relationshipType) {
                
                const dirHandle = targetDirHandle || pcState.currentDirHandle;
                if (!dirHandle) {
                    console.warn('[ParentChild] No directory handle available');
                    return;
                }
                
                try {
                    const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                    const fileName = targetVideoName + '.relations.json';
                    
                    let data = null;
                    try {
                        const fileHandle = await metaDir.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        const text = await file.text();
                        data = JSON.parse(text);
                    } catch (e) {
                        
                        return;
                    }
                    
                    if (data && data[relationshipType]) {
                        data[relationshipType] = data[relationshipType].filter(v => v.name !== currentVideoName);
                        data.updated = Date.now();
                        
                        const fileHandle = await metaDir.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(data, null, 2));
                        await writable.close();
                        
                        debug.log(`[ParentChild] Removed reverse relationship: ${targetVideoName} -> ${relationshipType} -> ${currentVideoName}`);
                    }
                } catch (e) {
                    console.warn('[ParentChild] Failed to remove reverse relationship:', e);
                }
            }

            async function removeVideo(type, name) {
                pcState[type] = pcState[type].filter(v => v.name !== name);
                await saveData();
                
                const sourceVideos = window.allVideos || [];
                const targetVideo = sourceVideos.find(v => v.name === name);
                const targetDirHandle = targetVideo?.dirHandle || null;
                
                const reverseType = type === 'parents' ? 'children' : 'parents';
                await removeReverseRelationship(name, targetDirHandle, pcState.currentVideoName, reverseType);
                
                renderCarousels();
            }

            function renderCarousels() {
                renderCarousel(els.childCarousel, pcState.children, 'children');
                renderCarousel(els.parentCarousel, pcState.parents, 'parents');
            }
            
            window.renderParentChildCarousels = renderCarousels;
            let pcThumbnailObserver = null;
            function getPcThumbnailObserver() {
                if (!pcThumbnailObserver) {
                    pcThumbnailObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const thumbEl = entry.target;
                                const videoName = thumbEl.dataset.videoName;
                                if (videoName && !thumbEl.dataset.loaded) {
                                    thumbEl.dataset.loaded = 'true';
                                    const fullVideo = getVideoByName(videoName);
                                    if (fullVideo && typeof getPreviewAndDuration === 'function') {
                                        getPreviewAndDuration(fullVideo).then(({ preview, duration }) => {
                                            thumbEl.classList.remove('loading');
                                            if (preview) {
                                                const img = document.createElement('img');
                                                img.src = preview;
                                                img.alt = removeExtension(videoName);
                                                const durationEl = thumbEl.querySelector('.pc-video-duration');
                                                thumbEl.insertBefore(img, durationEl);
                                            }
                                            const durationEl = thumbEl.querySelector('.pc-video-duration');
                                            if (duration && durationEl) {
                                                durationEl.textContent = duration;
                                            }
                                        }).catch(() => {
                                            thumbEl.classList.remove('loading');
                                        });
                                    } else {
                                        thumbEl.classList.remove('loading');
                                    }
                                    pcThumbnailObserver.unobserve(thumbEl);
                                }
                            }
                        });
                    }, { rootMargin: '100px' });
                }
                return pcThumbnailObserver;
            }

            function renderCarousel(container, videos, type) {
                container.innerHTML = '';
                if (videos.length === 0) {
                    const emptyText = type === 'parents' 
                        ? i18n.t('video.parentVideosEmpty', 'No parent videos added')
                        : i18n.t('video.childVideosEmpty', 'No child videos added');
                    container.innerHTML = `<div class="pc-empty-state">${emptyText}</div>`;
                    return;
                }

                const fragment = document.createDocumentFragment();
                const observer = getPcThumbnailObserver();

                videos.forEach(v => {
                    const card = document.createElement('div');
                    card.className = 'pc-video-card';
                    const videoUrl = window.VideoID 
                        ? window.VideoID.buildVideoUrl(v.name)
                        : `youvi_video.html?name=${encodeURIComponent(v.name)}`;
                    const fullVideo = getVideoByName(v.name);
                    
                    let channelName = '';
                    if (fullVideo && Array.isArray(fullVideo.tags)) {
                        if (window.TagTypes) {
                            channelName = window.TagTypes.getChannelFromTags(fullVideo.tags) || '';
                        } else {
                            const chTags = fullVideo.tags.filter(t => typeof t === 'string' && t.endsWith(' ()'));
                            if (chTags.length > 0) {
                                channelName = chTags.map(t => t.replace(' ()', '')).join(', ');
                            }
                        }
                    }
                    
                    const views = fullVideo?.views || 0;

                    card.innerHTML = `
                        <div class="pc-video-thumb loading" data-video-name="${v.name}">
                            <div class="pc-video-duration">0:00</div>
                        </div>
                        <div class="pc-video-info">
                            <div class="pc-video-title"><a href="${videoUrl}" title="${removeExtension(v.name)}">${removeExtension(v.name)}</a></div>
                            ${channelName ? `<div class="pc-video-channel" data-channel="${channelName}">${channelName}</div>` : ''}
                            <div class="pc-video-views">${views.toLocaleString()} ${getViewsLabel(views)}</div>
                        </div>
                        <button class="pc-remove-btn" title="${i18n.t('comments.delete', 'Delete')}"></button>
                    `;

                    const thumbEl = card.querySelector('.pc-video-thumb');
                    if (fullVideo) {
                        observer.observe(thumbEl);
                    } else {
                        thumbEl.classList.remove('loading');
                    }

                    card.querySelector('.pc-remove-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeVideo(type, v.name);
                    });

                    const channelEl = card.querySelector('.pc-video-channel');
                    if (channelEl) {
                        channelEl.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const ch = channelEl.dataset.channel;
                            if (ch) {
                                window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(ch)}`;
                            }
                        });
                    }

                    card.addEventListener('click', (e) => {
                        if (e.target.tagName === 'A') return;
                        if (e.target.classList.contains('pc-video-channel')) return;
                        if (e.target.closest('.pc-remove-btn')) return;
                        
                        if (fullVideo) {
                            window.location.href = videoUrl;
                        }
                    });

                    fragment.appendChild(card);
                });
                
                container.appendChild(fragment);
                
                updateNavButtons(container);
            }

            function stringToColor(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = str.charCodeAt(i) + ((hash << 5) - hash);
                }
                const c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
                return '#' + "00000".substring(0, 6 - c.length) + c;
            }

            function removeExtension(name) {
                return name ? name.replace(/\.[^/.]+$/, "") : "";
            }

            init();
        })();
    </script>

    <script src="youvi/multiview/multiview.js"></script>
</body>

</html>