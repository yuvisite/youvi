<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n-title="channelFeed.pageTitle">–õ–µ–Ω—Ç–∞ –∫–∞–Ω–∞–ª–∞ | Youvi</title>
    <script>
        (function() {
            var theme = localStorage.getItem('youvi-theme');
            var sidebar = localStorage.getItem('sidebarCollapsed');
            
            var htmlClasses = [];
            if (theme === 'dark') htmlClasses.push('dark-theme');
            else if (theme === 'skeuo') htmlClasses.push('skeuo-theme');
            if (sidebar === 'true') htmlClasses.push('sidebar-collapsed');
            if (htmlClasses.length) document.documentElement.className = htmlClasses.join(' ');
        })();
    </script>
    <link rel="stylesheet" href="youvi/header/youvi-header.css">
    <script src="youvi/sidebar-toggle.js"></script>
    <script src="youvi/sidebar-scroll.js"></script>
    <script src="youvi/header/youvi-header.js"></script>
    
    <!-- i18n System -->
    <script src="youvi/i18n/ru.js"></script>
    <script src="youvi/i18n/en.js"></script>
    <script src="youvi/i18n/uk.js"></script>
    <script src="youvi/i18n/i18n.js"></script>
    
    <link rel="stylesheet" href="youvi/sidebar.css">
    <link rel="stylesheet" href="youvi/pagination.css">
    
    <!-- Theme System -->
    <link rel="stylesheet" href="youvi/themes/dark-theme.css?v=2">
    <link rel="stylesheet" href="youvi/themes/theme-dropdown.css">
    
    <link rel="stylesheet" href="youvi_video_comments_feed_legacy.css">
    <style>
        
        .comment-image {
            transition: none;
            opacity: 1 !important;
            filter: none !important;
        }
        
        .comment-image.loaded {
            opacity: 1 !important;
            filter: none !important;
        }
        
        .image-container {
            position: relative;
            display: inline-block;
        }
        
        .comment-text img,
        .reply-text img,
        .nested-reply-text img {
            opacity: 1 !important;
            filter: none !important;
            background: none !important;
        }

        .loading {
            text-align: center;
            padding: 30px;
            color: #7a3c55;
        }

        .loading-spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #7a3c55;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comment-container.highlighted {
            background-color: #ffe7f4 !important;
            border-color: #ff69b4 !important;
            box-shadow: 0 0 10px rgba(255, 105, 180, 0.3);
            transition: background-color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

                body.dark-theme input.search-input {
  background: #4a3a34 !important;
  color: #fff !important;
  border-color: #555 !important;
}
    </style>
    
    <link rel="stylesheet" href="youvi/channel/youvi_ch_feed.css">
    <link rel="stylesheet" href="youvi/channel/youvi_ch_feed_social.css">
    <!-- Sidebar modules AFTER page-specific CSS -->
    <link rel="stylesheet" href="youvi/sidebar-scroll.css">
    <link rel="stylesheet" href="youvi/sticky-video.css">
    
    <style>

        
        .content-wrapper {
            display: flex;
            flex: 1;
            max-width: 1400px;
            margin: 0 auto;
            gap: 20px;
        }
        
        @media (min-width: 1700px) {
            .content-wrapper {
                max-width: 1500px;
            }
        }
        
        @media (min-width: 2000px) {
            .content-wrapper {
                max-width: 1600px;
            }
        }
        
        .main-content {
            flex: 1;
            width: 100%;
        }
        
        .header-content-wrapper,
        .top-nav-content {
            max-width: none !important;
            margin: 0 !important;
        }
        
        .lang-switcher {
            margin-left: auto;
        }
        
        .lang-select {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            outline: none;
        }
        
        .lang-select:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .lang-select option {
            background: #d94b88;
            color: #fff;
        }
    </style>
    
    <link rel="icon" href="favicon/youvi/favicon.ico" type="image/x-icon">
</head>
<body>
    <!-- Top Navigation Bar -->
    <div class="top-nav">
        <div class="top-nav-content">
      <a href="youvi_main.html" data-i18n="nav.video">–í–∏–¥–µ–æ</a>
      <a href="index.html" data-i18n="nav.management">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</a>
      <a href="youvi_ch_list.html" data-i18n="nav.channels">–ö–∞–Ω–∞–ª—ã</a>
      <a href="youvi_playlists_list.html" data-i18n="nav.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</a>
      <a href="youvi_feed_all.html" class="active" data-i18n="nav.feed">Feed</a> 
      <a href="wiki/index.html" data-i18n="nav.wiki">Wiki</a>
      <div class="lang-switcher">
        <select id="langSwitcher" class="lang-select">
          <option value="ru">üá∑üá∫ RU</option>
          <option value="en">üá¨üáß EN</option>
          <option value="uk">üá∫üá¶ UK</option>
        </select>
      </div>
        </div>
    </div>


    <!-- Header -->
    <header class="header">
        <div class="header-content-wrapper">
            <div class="header-left">
                <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle sidebar">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </button>
                
                <div class="logo">
                    <a href="youvi_main.html">
                        <img src="images/logo_youvi_ind.png" alt="Youvi logo">
                    </a>
                </div>
            </div>
            
            <div class="header-center">
                <div class="search-area autocomplete-wrapper">
                    <input type="text" id="globalSearch" placeholder="–ü–æ–∏—Å–∫ –≤–∏–¥–µ–æ..." class="search-input" data-i18n-placeholder="search.placeholder">
                    <button id="doSearch" class="search-btn" data-i18n="search.button">–ù–∞–π—Ç–∏</button>
                </div>
            </div>
            
            <div class="header-right">
                <div class="user-actions">
                    <div class="settings-container">
                        <a href="#" class="settings-btn">‚öô</a>
                        <div class="theme-dropdown">
                            <button class="theme-dropdown-item" data-theme="light">–ë–µ–ª–∞—è</button>
                            <button class="theme-dropdown-item" data-theme="dark">–ß–µ—Ä–Ω–∞—è</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Left Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.navigation">–ù–∞–≤–∏–≥–∞—Ü–∏—è</div>
                <a href="youvi_main.html" class="sidebar-item nav-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                        <polyline points="9,22 9,12 15,12 15,22"/>
                    </svg>
                    <span data-i18n="sidebar.home">–ì–ª–∞–≤–Ω–∞—è</span>
                </a>
                <a href="youvi_feed_all.html" class="sidebar-item nav-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M4 11a9 9 0 0 1 9 9"/>
                        <path d="M4 4a16 16 0 0 1 16 16"/>
                        <path d="M5 20a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                    </svg>
                    <span data-i18n="sidebar.feed">Feed</span>
                </a>
                <a href="youvi_tags.html" class="sidebar-item nav-item">
                  <svg viewBox="0 0 24 24" fill="none" stroke="#ff69b4" stroke-width="1.5">
                     <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                  <line x1="7" y1="7" x2="7.01" y2="7"/>
                 </svg>
                    <span data-i18n="sidebar.allTags">–í—Å–µ —Ç–µ–≥–∏</span>
                </a>
            </div>
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.library">–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞</div>
                <a href="youvi_history.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.history">–ò—Å—Ç–æ—Ä–∏—è</span>
                </a>
                <a href="youvi_fav.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
                    </svg>
                    <span data-i18n="sidebar.favorites">–ò–∑–±—Ä–∞–Ω–Ω–æ–µ</span>
                </a>
                <a href="youvi_playlists_list.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <line x1="8" y1="8" x2="16" y2="8"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                        <line x1="8" y1="16" x2="16" y2="16"/>
                        <circle cx="6" cy="8" r="1"/>
                        <circle cx="6" cy="12" r="1"/>
                        <circle cx="6" cy="16" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</span>
                </a>
                <a href="youvi_ch_list.html" class="sidebar-item library-item active">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 1-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span data-i18n="sidebar.channels">–ö–∞–Ω–∞–ª—ã</span>
                </a>
                <a href="youvi_subscriptions.html" class="sidebar-item library-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="2" y="7" width="20" height="15" rx="2" ry="2"/>
                        <polyline points="17,2 12,7 7,2"/>
                    </svg>
                    <span data-i18n="sidebar.subscriptions">–ü–æ–¥–ø–∏—Å–∫–∏</span>
                </a>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.subscriptionsTitle">–ü–æ–¥–ø–∏—Å–∫–∏</div>
                <div id="subscribedChannelsContainer"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="sidebar.sorting">–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞</div>
                <a href="#" class="sidebar-item library-item" id="sortNew">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12,6 12,12 16,14"/>
                    </svg>
                    <span data-i18n="sidebar.sortNew">–ù–æ–≤—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortBest">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
                    </svg>
                    <span data-i18n="feed.sortBest">–õ—É—á—à–∏–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortWorst">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <polygon points="12 22 8.91 15.74 2 14.73 7 9.86 5.82 2.98 12 6.23 18.18 2.98 17 9.86 22 14.73 15.09 15.74 12 22"/>
                    </svg>
                    <span data-i18n="feed.sortWorst">–•—É–¥—à–∏–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortOld">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                        <line x1="16" y1="2" x2="16" y2="6"/>
                        <line x1="8" y1="2" x2="8" y2="6"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                    </svg>
                    <span data-i18n="sidebar.sortOld">–°—Ç–∞—Ä—ã–µ</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="sortRandom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="1.5">
                        <rect x="3" y="3" width="18" height="18" rx="3" ry="3"/>
                        <circle cx="8" cy="8" r="1"/>
                        <circle cx="16" cy="8" r="1"/>
                        <circle cx="8" cy="16" r="1"/>
                        <circle cx="16" cy="16" r="1"/>
                        <circle cx="12" cy="12" r="1"/>
                    </svg>
                    <span data-i18n="sidebar.sortRandom">–°–ª—É—á–∞–π–Ω—ã–µ</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title" data-i18n="feed.viewMode">–†–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞</div>
                <a href="#" class="sidebar-item library-item" id="compactMode" data-i18n-title="feed.compactMode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="3" y="3" width="7" height="7"/>
                        <rect x="14" y="3" width="7" height="7"/>
                        <rect x="3" y="14" width="7" height="7"/>
                        <rect x="14" y="14" width="7" height="7"/>
                    </svg>
                    <span data-i18n="feed.compact">–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π</span>
                </a>
                <a href="#" class="sidebar-item library-item" id="socialMode" data-i18n-title="feed.timelineMode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <line x1="3" y1="3" x2="21" y2="3"/>
                        <line x1="3" y1="10" x2="21" y2="10"/>
                        <line x1="3" y1="17" x2="21" y2="17"/>
                    </svg>
                    <span data-i18n="feed.timeline">Timeline</span>
                </a>
            </div>

        </aside>

        <!-- Content Wrapper (centered) -->
        <div class="content-wrapper">
        <!-- Main Content -->
        <main class="main-content">
            <!-- Channel Header -->
            <div class="channel-header" id="channelHeader">
                <div class="channel-info">
                    <div class="channel-avatar" id="channelAvatar">?</div>
                    <div class="channel-details">
                        <h1 class="channel-name" id="channelName">–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞</h1>
                        <div class="channel-stats" id="channelStats">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                    </div>
                </div>
                <div class="channel-controls">
                    <button class="subscribe-btn" id="subscribeBtn">–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è</button>
                    
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab" data-tab="home" data-i18n="channelFeed.tabHome">–ì–ª–∞–≤–Ω–∞—è</button>
                <button class="tab" data-tab="videos" data-i18n="channelFeed.tabVideos">–í–∏–¥–µ–æ</button>
                <button class="tab" data-tab="analytics" data-i18n="channelFeed.tabAnalytics">–ê–Ω–∞–ª–∏—Ç–∏–∫–∞</button>
                <button class="tab active" data-tab="feed" onclick="window.location.href='youvi_ch_feed.html?channel='+encodeURIComponent(currentChannelName)" data-i18n="channelFeed.tabFeed">–õ–µ–Ω—Ç–∞</button>
                <button class="tab" data-tab="playlists" data-i18n="channelFeed.tabPlaylists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</button>
                <button class="tab" data-tab="description" data-i18n="channelFeed.tabDescription">–û–ø–∏—Å–∞–Ω–∏–µ</button>
            </div>

            <!-- Feed Tab Content -->
            <div id="feedTab" class="tab-content active">
                <div class="feed-form">
                    <div class="compact-editor-toolbar">
                        <button data-cmd="bold" data-i18n-title="channelFeed.editorBold"><b>B</b></button>
                        <button data-cmd="italic" data-i18n-title="channelFeed.editorItalic"><i>I</i></button>
                        <button data-cmd="underline" data-i18n-title="channelFeed.editorUnderline"><u>U</u></button>
                        <button data-cmd="formatBlock" data-value="h4" data-i18n-title="channelFeed.editorHeading">H</button>
                        <button id="createLinkBtnFeed" data-i18n-title="channelFeed.editorLink">üîó</button>
                        <button id="insertImageBtnFeed" data-i18n-title="channelFeed.editorImage">img</button>
                        <button id="centerImageBtnFeed" data-i18n-title="channelFeed.editorCenter">‚åò</button>
                        <input type="file" id="imageFileInputFeed" accept="image/*" style="display:none" multiple>
                    </div>
                    <div id="feedInput" class="compact-editor" contenteditable="true" data-i18n-placeholder="channelFeed.whatNew"></div>
                    <div style="display:flex;justify-content:space-between;align-items:center;gap:6px;margin-top:6px;">
                        <input type="text" id="feedNick" data-i18n-placeholder="channelFeed.yourNick" style="flex:1;max-width:100px;padding:3px 5px;border:1px solid #ddd;border-radius:3px;font-size:11px;background:#fff;">
                        <div style="display:flex;gap:6px;">
                            <button id="authorPostBtn" class="btn primary" style="padding:6px 12px;font-size:11px;font-weight:600;" data-i18n-title="channelFeed.publishAsChannel" data-i18n="feed.author">
                                –ê–≤—Ç–æ—Ä
                            </button>
                            <button id="postFeed" class="btn primary" style="padding:6px 12px;font-size:11px;" data-i18n-title="channelFeed.publishCtrlEnter" data-i18n="channelFeed.publish">–û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å</button>
                        </div>
                    </div>
                </div>
                
                <div id="feedSection" style="background:#fff;margin:0 20px;">
                    <!-- Feed items will be loaded here -->
                </div>
                
                <div style="padding:10px 20px;">
                    <button id="loadMoreFeedBtn" class="load-more-btn" style="display:none;" data-i18n="channelFeed.loadMore">–ü–æ–∫–∞–∑–∞—Ç—å –µ—â–µ 30 –ø–æ—Å—Ç–æ–≤</button>
                </div>
            </div>

            <!-- Other Tab Contents -->
            <div id="homeTab" class="tab-content">

            </div>

            <div id="videosTab" class="tab-content">
                
            </div>

            <div id="analyticsTab" class="tab-content">
              
            </div>

            <div id="playlistsTab" class="tab-content">
               
            </div>

            <div id="descriptionTab" class="tab-content">
                
            </div>
        </main>
        </div><!-- /content-wrapper -->
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <img src="images/logo_youvi_ind_ex.png" alt="Youvi" loading="lazy">
                    <p data-i18n="footer.description">–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤–∏–¥–µ–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ, –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∏—Ä—É–π—Ç–µ –∏ —Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∏–¥–µ–æ.</p>
                </div>
                <div class="footer-sections">
                    <div class="footer-section">
                        <h3 data-i18n="footer.sections">–†–∞–∑–¥–µ–ª—ã</h3>
                        <ul>
                            <li><a href="youvi_main.html" data-i18n="footer.video">–í–∏–¥–µ–æ</a></li>
                            <li><a href="youvi_tags.html" data-i18n="sidebar.tags">–¢–µ–≥–∏</a></li>
                            <li><a href="youvi_feed_all.html" data-i18n="nav.feed">Feed</a></li>
                            <li><a href="index.html" data-i18n="nav.management">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="sidebar.library">–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞</h3>
                        <ul>
                            <li><a href="youvi_ch_list.html" data-i18n="sidebar.channels">–ö–∞–Ω–∞–ª—ã</a></li>
                            <li><a href="youvi_playlists_list.html" data-i18n="sidebar.playlists">–ü–ª–µ–π–ª–∏—Å—Ç—ã</a></li>
                            <li><a href="youvi_subscriptions.html" data-i18n="sidebar.subscriptions">–ü–æ–¥–ø–∏—Å–∫–∏</a></li>
                            <li><a href="youvi_fav.html" data-i18n="sidebar.favorites">–ò–∑–±—Ä–∞–Ω–Ω–æ–µ</a></li>
                            <li><a href="youvi_history.html" data-i18n="sidebar.history">–ò—Å—Ç–æ—Ä–∏—è</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="nav.wiki">Wiki</h3>
                        <ul>
                            <li><a href="wiki/index.html" data-i18n="sidebar.home">–ì–ª–∞–≤–Ω–∞—è</a></li>
                            <li><a href="wiki/player.html" data-i18n="footer.wiki.player">–ü–ª–µ–µ—Ä</a></li>
                            <li><a href="wiki/danmaku.html" data-i18n="footer.wiki.danmaku">–î–∞–Ω–º–∞–∫—É</a></li>
                            <li><a href="wiki/tags/general.html" data-i18n="sidebar.tags">–¢–µ–≥–∏</a></li>
                            <li><a href="wiki/tags/rules.html" data-i18n="footer.wiki.taggingRules">–ü—Ä–∞–≤–∏–ª–∞ —Ç–µ–≥–∏—Ä–æ–≤–∞–Ω–∏—è</a></li>
                            <li><a href="wiki/search/general.html" data-i18n="footer.wiki.search">–ü–æ–∏—Å–∫</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.pgc">PGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Anime (ct)" data-i18n="footer.categories.anime">Anime</a></li>
                            <li><a href="youvi_main.html?tag=Animation (ct)" data-i18n="footer.categories.animation">Animation</a></li>
                            <li><a href="youvi_main.html?tag=Movies (ct)" data-i18n="footer.categories.movies">Movies</a></li>
                            <li><a href="youvi_main.html?tag=Series (ct)" data-i18n="footer.categories.series">Series</a></li>
                            <li><a href="youvi_main.html?tag=Music (ct)" data-i18n="footer.categories.music">Music</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.ugc">UGC</h3>
                        <ul>
                            <li><a href="youvi_main.html?tag=Games (ct)" data-i18n="footer.categories.games">Games</a></li>
                            <li><a href="youvi_main.html?tag=Technology (ct)" data-i18n="footer.categories.tech">Technology</a></li>
                            <li><a href="youvi_main.html?tag=Entertainment (ct)" data-i18n="footer.categories.entertainment">Entertainment</a></li>
                            <li><a href="youvi_main.html?tag=IRL (ct)" data-i18n="footer.categories.irl">IRL</a></li>
                            <li><a href="youvi_main.html?tag=TV (ct)" data-i18n="footer.categories.tv">TV</a></li>
                            <li><a href="youvi_main.html?tag=Education (ct)" data-i18n="footer.categories.education">Education</a></li>
                            <li><a href="youvi_main.html?tag=Other (ct)" data-i18n="footer.categories.other">Other</a></li>
                        </ul>
                    </div>
                    <div class="footer-section">
                        <h3 data-i18n="footer.about">–û —Å–∞–π—Ç–µ</h3>
                        <ul>
                            <li><a href="wiki/about.html" data-i18n="footer.aboutSite">–ü—Ä–æ —Å–∞–π—Ç</a></li>
                            <li><a href="wiki/docs.html" data-i18n="footer.docs">–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</a></li>
                            <li><a href="wiki/tech.html" data-i18n="footer.tech">–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="footer-right">
                <div class="footer-mascot">
                    <img src="images/mascot1.png" alt="Yuvi" loading="lazy">
                </div>
            </div>
        </div>

    </footer>

    <script>
    (function(){
        try{
            const input = document.getElementById('headerSearchInput');
            const btn = document.getElementById('headerSearchBtn');
            const go = () => {
                const q = (input?.value||'').trim();
                const params = new URLSearchParams();
                if (q) params.set('q', q);
                params.set('type','channels');
                window.location.href = `youvi_search.html?${params.toString()}`;
            };
            if (btn) btn.addEventListener('click', (e)=>{ e.preventDefault(); go(); });
            if (input) input.addEventListener('keypress', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); go(); } });
        }catch(_){ }
    })();
    </script>
    <script>
        
        /**
         * DEBUG_MODE flag - Controls console logging
         * Set to false to disable console.log statements in production
         * Set to true to enable debugging output
         * NOTE: console.error statements for critical errors will still show
         */
        const DEBUG_MODE = false;
        
        let currentChannelName = '';
        let channelData = {
            feed: [],
            avatar: null,
            header: null,
            stats: { videos: 0, views: 0 }
        };
        let videoDirectoryHandle = null;
        let allFeedPosts = [];
        let feedPage = 0;
        const feedPageSize = 30;
        const avatarCache = new Map();

        const channelDataCache = new Map();
        const postsCache = new Map();
        const imageLoadCache = new Map();
        let lastChannelDataLoad = 0;
        const CACHE_DURATION = 30000;

        let loadedFeedChunks = [];
        let totalFeedCount = 0;
        let isLoadingChunk = false;

        let virtualScrollTop = 0;
        let itemHeight = 120;
        let visibleItems = 10;
        
        let avatarsPreloaded = false;
        let avatarPreloadPromise = null;
        
        let postsIndexCache = null;
        let postsIndexLoaded = false;
        
        let avatarObserver = null;
        
        const imageOptimizationCache = new Map();
        const MAX_CACHE_SIZE = 100;
        
        function createDataURL(file) {
            return new Promise((resolve, reject) => {
                try {
                    if (!file || !(file instanceof File || file instanceof Blob)) {
                        console.error('Invalid file object for data URL creation');
                        reject(new Error('Invalid file object'));
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        if (DEBUG_MODE) console.log('Created data URL for file:', file.name);
                        resolve(e.target.result);
                    };
                    reader.onerror = function(e) {
                        console.error('Failed to read file:', e);
                        reject(e);
                    };
                    reader.readAsDataURL(file);
                } catch (error) {
                    console.error('Failed to create data URL:', error);
                    reject(error);
                }
            });
        }
        
        function createFileURL(filePath) {
            try {
                const fileUrl = `file:///${filePath.replace(/\\/g, '/')}`;
                if (DEBUG_MODE) console.log('Created file URL:', fileUrl);
                return fileUrl;
            } catch (error) {
                console.error('Failed to create file URL:', error);
                return null;
            }
        }
        
        window.addEventListener('error', function(event) {
            if (event.message && event.message.includes('Not allowed to load local resource')) {
                console.error('Local resource error detected:', event.message);
                if (DEBUG_MODE) console.log('This is expected for local file access without a server');
            }
        });
        
        async function clearAllBlobURLs() {
            try {
                clearImageCache();
                
                avatarCache.clear();
                
                if (window.indexedDB) {
                    const request = indexedDB.deleteDatabase('YouviDB');
                    request.onsuccess = () => {
                        if (DEBUG_MODE) console.log('IndexedDB cleared successfully');
                    };
                    request.onerror = () => {
                        if (DEBUG_MODE) console.log('IndexedDB clear failed or database does not exist');
                    };
                }
                
                if (DEBUG_MODE) console.log('All blob URLs and caches cleared');
            } catch (error) {
                console.error('Error clearing caches:', error);
            }
        }
        
        window.addEventListener('load', function() {
            clearAllBlobURLs();
        });

        function getChannelIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const channel = urlParams.get('channel');
            const id = urlParams.get('id');
            const result = channel || id || '';
            if (DEBUG_MODE) console.log(`getChannelIdFromUrl() = ${result} (channel: ${channel}, id: ${id})`);
            return result;
        }

        function getUrlParam(param) {
            const value = new URLSearchParams(window.location.search).get(param);
            if (DEBUG_MODE) console.log(`getUrlParam('${param}') =`, value);
            return value;
        }

        async function scrollToPost(postId) {
            if (DEBUG_MODE) console.log('Looking for post with ID:', postId);
            
            let attempts = 0;
            const maxAttempts = 50;
            
            while (attempts < maxAttempts) {
                const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                if (postElement) {
                    if (DEBUG_MODE) console.log('Found post element, scrolling to it');
                    
                    postElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                    
                    highlightPost(postElement);
                    
                    return true;
                }
                
                if (allFeedPosts.length > 50) {
                    const targetPost = allFeedPosts.find(post => post.id === postId);
                    if (targetPost) {
                        const targetIndex = allFeedPosts.findIndex(post => post.id === postId);
                        if (DEBUG_MODE) console.log('Found target post at index:', targetIndex);
                        
                        const container = document.querySelector('.main-content');
                        if (container) {
                            const targetScrollTop = targetIndex * itemHeight;
                            if (DEBUG_MODE) console.log('Scrolling to position:', targetScrollTop);
                            
                            virtualScrollTop = targetScrollTop;
                            container.scrollTop = targetScrollTop;
                            
                            await renderFeedPageVirtual();
                            
                            await new Promise(resolve => setTimeout(resolve, 200));
                            const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                            if (postElement) {
                                highlightPost(postElement);
                                return true;
                            }
                        }
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (DEBUG_MODE) console.log('Post not found after', attempts, 'attempts');
            return false;
        }

        async function loadMorePostsIfNeeded(targetPostId) {
            const targetPost = allFeedPosts.find(post => post.id === targetPostId);
            if (!targetPost) {
                if (DEBUG_MODE) console.log('Target post not in allFeedPosts, trying to load more');
                return;
            }
            
            const targetIndex = allFeedPosts.findIndex(post => post.id === targetPostId);
            if (targetIndex === -1) return;
            
            const currentLoadedCount = document.querySelectorAll('[data-post-id]').length;
            const postsNeeded = targetIndex - currentLoadedCount + 10;
            
            if (postsNeeded > 0) {
                if (DEBUG_MODE) console.log(`Need to load ${postsNeeded} more posts to reach target`);
            }
        }

        function highlightPost(postElement) {
            if (DEBUG_MODE) console.log('Highlighting post');
            
            postElement.classList.add('highlighted');
            
            setTimeout(() => {
                postElement.classList.remove('highlighted');
                if (DEBUG_MODE) console.log('Removed highlight from post');
            }, 2000);
        }

        async function openDB() {
            return new Promise((resolve, reject) => {
                if (DEBUG_MODE) console.log('Opening IndexedDB: 8SiteDB, version 1');
                const request = indexedDB.open('8SiteDB', 1);
                
                request.onupgradeneeded = () => {
                    if (DEBUG_MODE) console.log('IndexedDB upgrade needed');
                    const db = request.result;
                    if (!db.objectStoreNames.contains('handles')) {
                        if (DEBUG_MODE) console.log('Creating handles store');
                        db.createObjectStore('handles');
                    }
                    if (!db.objectStoreNames.contains('subscriptions')) {
                        if (DEBUG_MODE) console.log('Creating subscriptions store');
                        db.createObjectStore('subscriptions');
                    }
                };
                
                request.onsuccess = () => {
                    if (DEBUG_MODE) console.log('IndexedDB opened successfully');
                    resolve(request.result);
                };
                
                request.onerror = () => {
                    console.error('IndexedDB open error:', request.error);
                    reject(request.error);
                };
            });
        }

        async function getFromDB(db, key) {
            if (DEBUG_MODE) console.log(`Getting from DB: ${key}`);
            const storeName = key === 'subscriptions' ? 'subscriptions' : 'handles';
            if (DEBUG_MODE) console.log('Using store:', storeName);
            
            if (!db.objectStoreNames.contains(storeName)) {
                if (DEBUG_MODE) console.log('Store not found:', storeName);
                return null;
            }
            
            const tx = db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            if (DEBUG_MODE) console.log('Transaction and store created');
            
            return new Promise((resolve) => {
                const request = store.get(key);
                request.onsuccess = () => {
                    if (DEBUG_MODE) console.log(`DB get success for ${key}:`, request.result);
                    resolve(request.result);
                };
                request.onerror = () => {
                    if (DEBUG_MODE) console.log(`DB get error for ${key}:`, request.error);
                    resolve(null);
                };
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function getNickColor(nick) {
            if (!nick || typeof nick !== 'string') {
                return '#888888';
            }
            const colors = ['#4a90e2', '#7b68ee', '#20b2aa', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            let hash = 0;
            for (let i = 0; i < nick.length; i++) {
                hash = nick.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }
        
        function processContentWithImages(content) {
            if (!content || typeof content !== 'string') return '';
            
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = content;
                const images = tempDiv.querySelectorAll('img');
                
                images.forEach(img => {
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        img.style.maxWidth = '120px';
                        img.style.maxHeight = '80px';
                        img.style.cursor = 'pointer';
                        img.style.border = '1px solid #ddd';
                        img.style.borderRadius = '4px';
                        img.style.objectFit = 'cover';
                        img.style.display = 'block';
                        img.style.opacity = '1';
                        img.className = 'loaded';
                        
                    img.onclick = () => {
                        const fileName = img.getAttribute('data-filename');
                        const postId = img.getAttribute('data-post-id');
                        if (fileName && postId) {
                            openImageModal(img.src, fileName, postId, currentChannelName);
                        } else {
                            openImageModal(img.src);
                        }
                    };
                    }
                });
                
                return tempDiv.innerHTML;
            } catch (e) {
                console.error('Error processing content with images:', e);
            return content;
            }
        }

        function processImagesInPostContent(postElement) {
            const images = postElement.querySelectorAll('.comment-text img, .reply-text img, .nested-reply-text img');
            
            if (images.length > 0) {
                if (DEBUG_MODE) console.log('Processing', images.length, 'images in post/reply');
            }
            
            const isSocialMode = document.querySelector('.main-content')?.classList.contains('social-mode');
            
            images.forEach(img => {
                if (isSocialMode) {
                    return;
                }
                
                if (!img.getAttribute('data-expanded')) {
                    img.setAttribute('data-expanded', 'false');
                }
                img.style.cursor = 'pointer';
                img.style.transition = 'none';
                img.style.maxWidth = '120px';
                img.style.maxHeight = '80px';
                img.style.objectFit = 'cover';
                img.style.border = '1px solid #ddd';
                img.style.borderRadius = '0';
                img.style.margin = '4px 0';
                img.style.display = 'block';
                img.style.opacity = '1';
                
                img.classList.remove('lazy');
                img.classList.add('loaded');
                
                if (!img.getAttribute('data-fullsrc')) {
                    img.setAttribute('data-fullsrc', img.src);
                }
                
                img.onclick = (e) => {
                    e.stopPropagation();
                    toggleImageSize(img);
                };
            });
        }

        async function processImagesInContent(content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const images = tempDiv.querySelectorAll('img');
            
            if (images.length > 0) {
                if (DEBUG_MODE) console.log('Processing reply with', images.length, 'images');
                for (const img of images) {
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        if (!img.style.maxWidth) img.style.maxWidth = '120px';
                        if (!img.style.maxHeight) img.style.maxHeight = '80px';
                        if (!img.style.cursor) img.style.cursor = 'pointer';
                        if (!img.style.border) img.style.border = '1px solid #ddd';
                        if (!img.style.borderRadius) img.style.borderRadius = '0';
                        if (!img.style.objectFit) img.style.objectFit = 'cover';
                        if (!img.style.display) img.style.display = 'block';
                        if (!img.style.opacity) img.style.opacity = '1';
                        
                        if (!img.className.includes('loaded')) {
                            img.className = (img.className + ' loaded').trim();
                        }
                        
                        if (!img.getAttribute('data-fullsrc')) {
                            img.setAttribute('data-fullsrc', img.src);
                        }
                        if (!img.getAttribute('data-expanded')) {
                            img.setAttribute('data-expanded', 'false');
                        }
                        
                        img.setAttribute('data-thumbnail', 'true');
                    }
                }
                return tempDiv.innerHTML;
            }
            
            return content;
        }

        async function downscaleImageFile(file, maxW, maxH, quality = 0.8) {
            const cacheKey = `${file.name}_${file.size}_${file.lastModified}_${maxW}x${maxH}_${quality}`;
            
            if (imageOptimizationCache.has(cacheKey)) {
                return imageOptimizationCache.get(cacheKey);
            }
            
            return new Promise((resolve) => {
                createDataURL(file).then(dataUrl => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width, h = img.height;
                        
                        let scale = Math.min(maxW / w, maxH / h, 1);
                        if (scale < 1) {
                            w = Math.round(w * scale);
                            h = Math.round(h * scale);
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        
                        ctx.drawImage(img, 0, 0, w, h);
                        
                        const optimizedDataUrl = canvas.toDataURL(file.type || 'image/jpeg', quality);
                        
                        if (imageOptimizationCache.size >= MAX_CACHE_SIZE) {
                            const firstKey = imageOptimizationCache.keys().next().value;
                            imageOptimizationCache.delete(firstKey);
                        }
                        imageOptimizationCache.set(cacheKey, optimizedDataUrl);
                        
                        resolve(optimizedDataUrl);
                    };
                    img.onerror = () => {
                        imageOptimizationCache.set(cacheKey, dataUrl);
                        resolve(dataUrl);
                    };
                    
                    img.src = dataUrl;
                }).catch(error => {
                    console.error('Failed to downscale image:', error);
                    resolve(null);
                });
            });
        }

        async function processImagesInPost(item, post) {
            return;
        }

        async function writeJSONFile(dirHandle, fileName, data) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();
            } catch (e) {
                console.error('Error writing file:', e);
            }
        }

        async function createImagesDirectory() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) return null;
                
                const channelDir = await getChannelDirectory();
                try {
                    await channelDir.getDirectoryHandle('images', { create: true });
                    if (DEBUG_MODE) console.log('Images directory created/accessed');
                } catch (e) {
                    console.error('Error creating images directory:', e);
                }
                return channelDir;
            } catch (e) {
                console.error('Error accessing channel directory for images:', e);
                return null;
            }
        }

        async function saveOriginalImageFile(file, postId, replyId = null) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, using data URL fallback');
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts', { create: true });
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`, { create: true });
                const imagesDir = await postDir.getDirectoryHandle('images', { create: true });
                
                const timestamp = Date.now();
                const fileExtension = file.name.split('.').pop() || 'jpg';
                const fileName = replyId 
                    ? `image_${timestamp}_${postId}_${replyId}.${fileExtension}`
                    : `image_${timestamp}_${postId}.${fileExtension}`;

                const fileHandle = await imagesDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(file);
                await writable.close();

                if (DEBUG_MODE) console.log('Saved original image file to post images directory:', fileName);
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve) => {
                    img.onload = () => {
                        const maxWidth = 200;
                        const maxHeight = 150;
                        let { width, height } = img;
                        
                        if (width > maxWidth || height > maxHeight) {
                            const ratio = Math.min(maxWidth / width, maxHeight / height);
                            width *= ratio;
                            height *= ratio;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        const thumbnailDataUrl = canvas.toDataURL('image/jpeg', 0.8);
                        
                        const imageInfo = {
                            fileName: fileName,
                            originalSize: file.size,
                            thumbnailDataUrl: thumbnailDataUrl,
                            timestamp: timestamp
                        };
                        
                        saveImageInfo(imageInfo, postId, replyId);
                        
                        resolve(thumbnailDataUrl);
                    };
                    img.src = URL.createObjectURL(file);
                });
                
            } catch (e) {
                console.error('Error saving original image file:', e);
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            }
        }

        async function saveImageInfo(imageInfo, postId, replyId = null) {
            try {
                const channelDir = await getChannelDirectory();
                const imagesFile = 'images.json';
                
                let imagesData = {};
                try {
                    const existingFile = await channelDir.getFileHandle(imagesFile);
                    const file = await existingFile.getFile();
                    const content = await file.text();
                    imagesData = JSON.parse(content);
                } catch (e) {
                }
                
                const key = replyId ? `${postId}_${replyId}_${imageInfo.timestamp}` : `${postId}_${imageInfo.timestamp}`;
                imagesData[key] = imageInfo;
                
                await writeJSONFile(channelDir, imagesFile, imagesData);
                if (DEBUG_MODE) console.log('Saved image info to images.json');
                
            } catch (e) {
                console.error('Error saving image info:', e);
            }
        }

        async function loadFullImage(fileName, postId, channelName = null) {
            try {
                if (!videoDirectoryHandle) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load full image');
                    return null;
                }

                if (DEBUG_MODE) console.log('Loading full image:', { fileName, postId, channelName });

                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                
                if (channelName) {
                    try {
                        const channelHandle = await channelsDir.getDirectoryHandle(channelName);
                        const postsDir = await channelHandle.getDirectoryHandle('posts');
                        const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                        const imagesDir = await postDir.getDirectoryHandle('images');
                        const fileHandle = await imagesDir.getFileHandle(fileName);
                        const file = await fileHandle.getFile();
                        
                        if (DEBUG_MODE) console.log('Found image in specified channel:', channelName);
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.readAsDataURL(file);
                        });
                    } catch (e) {
                        if (DEBUG_MODE) console.log('Post not found in specified channel:', channelName, e);
                    }
                }
                
                for await (const [channelName, channelHandle] of channelsDir.entries()) {
                    if (channelHandle.kind === 'directory') {
                        try {
                            const postsDir = await channelHandle.getDirectoryHandle('posts');
                            const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                            const imagesDir = await postDir.getDirectoryHandle('images');
                            const fileHandle = await imagesDir.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            
                            if (DEBUG_MODE) console.log('Found image in channel:', channelName);
                            return new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                if (DEBUG_MODE) console.log('Post not found in any channel');
                return null;
                
            } catch (e) {
                console.error('Error loading full image:', e);
                return null;
            }
        }

        async function saveReplies() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save replies');
                    return;
                }

                const channelDir = await getChannelDirectory();
                
                const allReplies = {};
                if (channelData.feed) {
                    channelData.feed.forEach(post => {
                        if (post.replies && post.replies.length > 0) {
                            allReplies[post.id] = post.replies;
                        }
                    });
                }
                
                await writeJSONFile(channelDir, 'replies.json', allReplies);
                if (DEBUG_MODE) console.log('Saved replies to replies.json');
                
                if (channelData.feed) {
                    channelData.feed.forEach(post => {
                        if (post.replies) {
                            delete post.replies;
                        }
                    });
                }
                
            } catch (e) {
                console.error('Error saving replies:', e);
            }
        }

        async function loadReplies() {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load replies');
                    return;
                }

                const channelDir = await getChannelDirectory();
                const repliesData = await readJSONFile(channelDir, 'replies.json', {});
                
                if (channelData.feed && repliesData) {
                    channelData.feed.forEach(post => {
                        if (repliesData[post.id]) {
                            post.replies = repliesData[post.id];
                        }
                    });
                }
                
                if (DEBUG_MODE) console.log('Loaded replies from replies.json');
                
            } catch (e) {
                console.error('Error loading replies:', e);
            }
        }

        async function loadRepliesForPosts(posts, postsDir) {
            if (!posts || posts.length === 0 || !postsDir) return;
            
            const startTime = performance.now();
            
            const promises = posts.map(async (post) => {
                try {
                    const postDir = await postsDir.getDirectoryHandle(`post_${post.id}`);
                    const replies = await readJSONFile(postDir, 'replies.json', null);
                    if (replies && Array.isArray(replies) && replies.length > 0) {
                        post.replies = replies;
                    }
                } catch (e) {
                }
            });
            
            await Promise.all(promises);
            if (DEBUG_MODE) console.log(`Loaded replies in ${(performance.now() - startTime).toFixed(2)}ms`);
        }

        async function createPostDirectory(postId) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot create post directory');
                    return null;
                }

                if (!postId || postId === 'feed' || typeof postId !== 'string') {
                    console.error('Invalid postId:', postId);
                    return null;
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts', { create: true });
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`, { create: true });
                const imagesDir = await postDir.getDirectoryHandle('images', { create: true });
                
                if (DEBUG_MODE) console.log('Created post directory structure for:', postId);
                return { postDir, imagesDir };
                
            } catch (e) {
                console.error('Error creating post directory:', e);
                return null;
            }
        }

        async function savePostToDirectory(post) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save post');
                    return;
                }

                const { postDir, imagesDir } = await createPostDirectory(post.id);
                if (!postDir) return;

                const postData = {
                    id: post.id,
                    author: post.author,
                    content: post.content,
                    timestamp: post.timestamp,
                    likes: post.likes || 0,
                    dislikes: post.dislikes || 0,
                    edited: post.edited || false,
                    editedAt: post.editedAt || null,
                    isAuthorPost: post.isAuthorPost || false,
                    hasImages: post.hasImages || false
                };

                await writeJSONFile(postDir, 'post.json', postData);
                if (DEBUG_MODE) console.log('Saved post data to post.json');

                if (post.replies && post.replies.length > 0) {
                    await writeJSONFile(postDir, 'replies.json', post.replies);
                    if (DEBUG_MODE) console.log('Saved replies to replies.json');
                }

                if (post.content && post.content.includes('<img')) {
                    await processAndSavePostImages(post, imagesDir);
                }

            } catch (e) {
                console.error('Error saving post to directory:', e);
            }
        }

        async function saveRepliesToFile(postId, replies) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot save replies');
                    return;
                }

                const { postDir } = await createPostDirectory(postId);
                if (!postDir) return;

                if (replies && replies.length > 0) {
                    await writeJSONFile(postDir, 'replies.json', replies);
                    if (DEBUG_MODE) console.log('Saved replies to replies.json for post:', postId);
                } else {
                    await writeJSONFile(postDir, 'replies.json', []);
                    if (DEBUG_MODE) console.log('Saved empty replies array for post:', postId);
                }

            } catch (e) {
                console.error('Error saving replies to file:', e);
            }
        }

        async function processAndSavePostImages(post, imagesDir) {
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = post.content;
                const images = tempDiv.querySelectorAll('img');
                
                if (images.length === 0) return;

                if (DEBUG_MODE) console.log(`Processing ${images.length} images for post ${post.id}`);

                for (let i = 0; i < images.length; i++) {
                    const img = images[i];
                    if (img.src && (img.src.startsWith('data:') || img.src.startsWith('blob:'))) {
                        if (img.getAttribute('data-original-file') === 'true') {
                            const response = await fetch(img.src);
                            const blob = await response.blob();
                            const file = new File([blob], `image_${i + 1}.jpg`, { type: blob.type });
                            
                            const fileName = `image_${Date.now()}_${i + 1}.jpg`;
                            const fileHandle = await imagesDir.getFileHandle(fileName, { create: true });
                            const writable = await fileHandle.createWritable();
                            await writable.write(file);
                            await writable.close();

                            img.setAttribute('data-filename', fileName);
                            img.setAttribute('data-post-id', post.id);
                            img.removeAttribute('data-original-file');
                            
                            if (DEBUG_MODE) console.log('Saved post image:', fileName);
                        } else {
                            img.setAttribute('data-post-id', post.id);
                        }
                    }
                }

                post.content = tempDiv.innerHTML;

            } catch (e) {
                console.error('Error processing post images:', e);
            }
        }

        async function loadPostFromDirectory(postId) {
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load post');
                    return null;
                }

                const channelDir = await getChannelDirectory();
                const postsDir = await channelDir.getDirectoryHandle('posts');
                const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);

                const postData = await readJSONFile(postDir, 'post.json');
                if (!postData || !postData.id) {
                    console.error('Invalid post data for post:', postId);
                    return null;
                }
                
                if (postData.deleted) {
                    if (DEBUG_MODE) console.log(`Skipping deleted post: ${postId}`);
                    return null;
                }

                const replies = await readJSONFile(postDir, 'replies.json', []);
                postData.replies = replies || [];

                try {
                    const imagesDir = await postDir.getDirectoryHandle('images');
                    await loadPostImages(postData, imagesDir);
                } catch (e) {
                    if (DEBUG_MODE) console.log('No images directory for post:', postId);
                }

                if (DEBUG_MODE) console.log('Loaded post from directory:', postId);
                return postData;

            } catch (e) {
                console.error('Error loading post from directory:', e);
                return null;
            }
        }

        async function loadPostImages(post, imagesDir) {
            try {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = post.content;
                const images = tempDiv.querySelectorAll('img[data-filename]');

                for (const img of images) {
                    const fileName = img.getAttribute('data-filename');
                    if (fileName) {
                        try {
                            const fileHandle = await imagesDir.getFileHandle(fileName);
                            const file = await fileHandle.getFile();
                            const dataUrl = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(file);
                            });
                            img.src = dataUrl;
                            img.setAttribute('data-post-id', post.id);
                        } catch (e) {
                            console.error('Error loading post image:', fileName, e);
                        }
                    }
                }

                post.content = tempDiv.innerHTML;

            } catch (e) {
                console.error('Error loading post images:', e);
            }
        }

        async function readJSONFile(dirHandle, fileName, defaultValue = null) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return defaultValue;
            }
        }

        async function loadImageFile(dirHandle, fileName) {
            const cacheKey = `${dirHandle.name}_${fileName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
            }
            
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                const url = URL.createObjectURL(file);
                
                avatarCache.set(cacheKey, {
                    url,
                    timestamp: Date.now()
                });
                
                return url;
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    console.error('Error loading image file:', e);
                }
                return null;
            }
        }
        
        async function loadAvatarForChannelName(channelName) {
            try {
                if (!videoDirectoryHandle || !channelName) return null;
                
                const cacheKey = `avatar_${channelName}`;
                if (avatarCache.has(cacheKey)) {
                    const cached = avatarCache.get(cacheKey);
                    if (Date.now() - cached.timestamp < CACHE_DURATION) {
                        return cached.url;
                    }
                }
                
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                const chDir = await channelsDir.getDirectoryHandle(channelName, { create: true });
                const chData = await readJSONFile(chDir, 'channel.json', {});
                
                let url = null;
                if (chData && chData.avatar) {
                    url = await loadImageFile(chDir, chData.avatar);
                }
                
                avatarCache.set(cacheKey, { url, timestamp: Date.now() });
                return url;
            } catch (e) {
                if (e.name !== 'NotFoundError') {
                    console.error('Error loading avatar for channel', channelName, e);
                }
                avatarCache.set(`avatar_${channelName}`, { url: null, timestamp: Date.now() });
            }
            return null;
        }
        
        async function preloadAvatarsForPosts(posts) {
            if (!posts || posts.length === 0) return;
            
            const startTime = performance.now();
            
            const uniqueChannels = new Set();
            
            if (currentChannelName) {
                uniqueChannels.add(currentChannelName);
            }
            
            for (const post of posts) {
                if (post.isAuthorPost && currentChannelName) {
                    uniqueChannels.add(currentChannelName);
                }
                const author = post.author || post.nick || '';
                const isChannelNick = /\((–∫–∞|ka)\)\s*$/i.test(author);
                if (isChannelNick) {
                    const channelName = author.replace(/\((–∫–∞|ka)\)\s*$/i, '').trim();
                    if (channelName) uniqueChannels.add(channelName);
                }
            }
            
            const channelArray = Array.from(uniqueChannels);
            const BATCH_SIZE = 5;
            
            for (let i = 0; i < channelArray.length; i += BATCH_SIZE) {
                const batch = channelArray.slice(i, i + BATCH_SIZE);
                await Promise.all(batch.map(ch => loadAvatarForChannelName(ch)));
            }
            
            avatarsPreloaded = true;
            if (DEBUG_MODE) console.log(`Preloaded ${channelArray.length} avatars in ${(performance.now() - startTime).toFixed(2)}ms`);
        }
        
        function setupAvatarObserver() {
            if (avatarObserver) return;
            
            avatarObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const el = entry.target;
                        const channelName = el.dataset.channelAvatar;
                        if (channelName && !el.dataset.avatarLoaded) {
                            el.dataset.avatarLoaded = 'loading';
                            loadAvatarForChannelName(channelName).then(url => {
                                if (url) {
                                    el.style.backgroundImage = `url(${url})`;
                                    el.classList.add('custom-avatar');
                                    el.textContent = '';
                                }
                                el.dataset.avatarLoaded = 'true';
                            });
                            avatarObserver.unobserve(el);
                        }
                    }
                });
            }, { rootMargin: '100px' });
        }

        async function loadImageFromFileSystem(dirHandle, fileName) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                
                if (!file.type.startsWith('image/')) {
                    console.warn('File is not an image:', fileName);
                    return null;
                }
                
                const dataUrl = await createDataURL(file);
                if (dataUrl) {
                    return dataUrl;
                } else {
                    console.error('Failed to create data URL for:', fileName);
                    return null;
                }
            } catch (e) {
                console.error('Error loading image from file system:', e);
                return null;
            }
        }

        async function loadImageFileFromFileSystem(dirHandle, fileName) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName);
                const file = await fileHandle.getFile();
                if (DEBUG_MODE) console.log('Image file loaded from file system:', fileName, file.size, 'bytes');
                return file;
            } catch (e) {
                console.error('Error loading image file from file system:', e);
                return null;
            }
        }

        async function loadLazyImageFile(dirHandle, fileName, imgElement, className = '') {
            const url = await loadImageFile(dirHandle, fileName);
            if (url && imgElement) {
                if (imgElement.tagName === 'IMG') {
                    if (imgElement.dataset.src) {
                        imgElement.dataset.src = url;
                    } else {
                        imgElement.dataset.src = url;
                        imgElement.className = (imgElement.className + ' ' + className + ' lazy').trim();
                        imgElement.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiNGM0Y0RjYiLz4KPC9zdmc+Cg==';
                    }
                } else {
                    imgElement.dataset.src = url;
                    imgElement.className = (imgElement.className + ' ' + className + ' lazy-avatar').trim();
                }
            }
            return url;
        }

        let cachedChannelDir = null;
        let cachedChannelDirName = null;

        async function getChannelDirectory() {
            if (cachedChannelDir && cachedChannelDirName === currentChannelName) {
                return cachedChannelDir;
            }
            
            const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
            const channelDir = await channelsDir.getDirectoryHandle(currentChannelName, { create: true });
            
            cachedChannelDir = channelDir;
            cachedChannelDirName = currentChannelName;
            
            return channelDir;
        }

        async function loadChannelVideos() {
            if (!videoDirectoryHandle || !currentChannelName) return;
            
            const videos = [];
            const videoExtensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v'];
            
            try {
                async function scanDirectory(dirHandle, playlistName = '') {
                    try {
                        for await (const [name, handle] of dirHandle.entries()) {
                            if (handle.kind === 'file') {
                                const isVideo = videoExtensions.some(ext => name.toLowerCase().endsWith(ext));
                                if (isVideo) {
                                    const metadata = await getVideoMetadata(dirHandle, name);
                                    const hasChannelTag = (metadata.tags || []).some(tag => 
                                        tag === `${currentChannelName} (–∫–∞)`
                                    );
                                    
                                    if (hasChannelTag) {
                                        const file = await handle.getFile();
                                        videos.push({
                                            name,
                                            handle,
                                            file,
                                            size: file.size,
                                            modified: file.lastModified,
                                            ...metadata,
                                            playlist: playlistName
                                        });
                                    }
                                }
                            } else if (handle.kind === 'directory' && !name.startsWith('.')) {
                                await scanDirectory(handle, name);
                            }
                        }
                    } catch (e) {
                        console.error('Error scanning directory:', e);
                    }
                }
                
                await scanDirectory(videoDirectoryHandle);

                const totalViews = videos.reduce((sum, v) => sum + (v.views || 0), 0);
                const statsEl = document.getElementById('channelStats');
                if (statsEl) {
                    if (videos.length > 0) {
                        const statsText = i18n.t('channelFeed.stats', '{videos} –≤–∏–¥–µ–æ ‚Ä¢ {views} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤')
                            .replace('{videos}', videos.length)
                            .replace('{views}', totalViews.toLocaleString());
                        statsEl.textContent = statsText;
                    } else {
                        statsEl.textContent = i18n.t('channelFeed.noVideos', '–ù–µ—Ç –≤–∏–¥–µ–æ');
                    }
                }
                
                if (channelData) {
                    channelData.stats = {
                        videos: videos.length,
                        views: totalViews
                    };
                }
                
            } catch (e) {
                console.error('Error loading channel videos:', e);
            }
        }

        async function getVideoMetadata(dirHandle, fileName) {
            try {
                const metaDir = await dirHandle.getDirectoryHandle('.metadata', { create: true });
                const metaFileName = fileName + '.meta.json';
                const fileHandle = await metaDir.getFileHandle(metaFileName);
                const file = await fileHandle.getFile();
                const text = await file.text();
                return JSON.parse(text);
            } catch (e) {
                return {
                    views: 0,
                    likes: 0,
                    dislikes: 0,
                    tags: [],
                    created: Date.now()
                };
            }
        }

        async function loadChannelData() {
            if (!currentChannelName) return;
            
            if (DEBUG_MODE) console.log('Loading channel data for:', currentChannelName);
            const startTime = performance.now();
            
            const cacheKey = `channel_${currentChannelName}`;
            const now = Date.now();
            if (channelDataCache.has(cacheKey) && (now - lastChannelDataLoad) < CACHE_DURATION) {
                if (DEBUG_MODE) console.log('Using cached channel data');
                channelData = channelDataCache.get(cacheKey);
                const loadTime = performance.now() - startTime;
                if (DEBUG_MODE) console.log(`Channel data loaded from cache in ${loadTime.toFixed(2)}ms`);
                return;
            }
            
            try {
                const channelDir = await getChannelDirectory();
                if (DEBUG_MODE) console.log('Channel directory obtained:', channelDir);
                
                const defaultData = {
                    name: currentChannelName,
                    description: '',
                    avatar: null,
                    header: null,
                    background: null,
                    textColor: 'white',
                    theme: 'default',
                    feed: [],
                    playlists: [],
                    stats: { videos: 0, views: 0 },
                    created: Date.now()
                };
                
                const channelJsonPromise = readJSONFile(channelDir, 'channel.json', defaultData);
                const timeoutPromise = new Promise(resolve => setTimeout(() => resolve(defaultData), 5000));
                
                channelData = await Promise.race([channelJsonPromise, timeoutPromise]);
                if (DEBUG_MODE) console.log('Channel data loaded from file system');
                
                setTimeout(() => {
                    const channelId = getChannelIdFromUrl();
                    const storedData = localStorage.getItem(`channel_${channelId}`);
                    if (storedData) {
                        try {
                            const parsedData = JSON.parse(storedData);
                            channelData = { 
                                ...channelData, 
                                ...parsedData,
                                name: channelData.name || parsedData.name,
                                created: channelData.created || parsedData.created
                            };
                            
                            channelDataCache.set(cacheKey, channelData);
                            if (DEBUG_MODE) console.log('Channel data merged with localStorage');
                        } catch (e) {
                            console.error('Error parsing stored data:', e);
                        }
                    }
                }, 0);
                
                channelDataCache.set(cacheKey, channelData);
                lastChannelDataLoad = now;
                
                const loadTime = performance.now() - startTime;
                if (DEBUG_MODE) console.log(`Channel data loaded in ${loadTime.toFixed(2)}ms`);
                
                setTimeout(() => loadPostsFromDirectories(), 0);
                
            } catch (e) {
                console.error('Error loading channel data:', e);
                const channelId = getChannelIdFromUrl();
                const storedData = localStorage.getItem(`channel_${channelId}`);
                if (storedData) {
                    try {
                        channelData = JSON.parse(storedData);
                        channelDataCache.set(cacheKey, channelData);
                        if (DEBUG_MODE) console.log('Fallback: Using localStorage data');
                    } catch (e) {
                        console.error('Error parsing stored data:', e);
                    }
                }
                
                setTimeout(() => loadPostsFromDirectories(), 0);
            }
        }

        async function loadPostsFromDirectories() {
            const startTime = performance.now();
            
            try {
                if (!videoDirectoryHandle || !currentChannelName) {
                    if (DEBUG_MODE) console.log('No file system access, cannot load posts from directories');
                    return;
                }

                const cacheKey = `posts_${currentChannelName}`;
                const now = Date.now();
                if (postsCache.has(cacheKey) && (now - lastChannelDataLoad) < CACHE_DURATION) {
                    if (DEBUG_MODE) console.log('Using cached posts data');
                    const cachedPosts = postsCache.get(cacheKey);
                    channelData.feed = cachedPosts;
                    allFeedPosts = cachedPosts;
                    const loadTime = performance.now() - startTime;
                    if (DEBUG_MODE) console.log(`Posts loaded from cache in ${loadTime.toFixed(2)}ms`);
                    return;
                }

                const channelDir = await getChannelDirectory();
                
                try {
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    
                    let postsIndex = null;
                    try {
                        postsIndex = await readJSONFile(postsDir, 'index.json', null);
                    } catch (e) {
                    }
                    
                    let loadedPosts = [];
                    
                    if (postsIndex && Array.isArray(postsIndex.posts)) {
                        if (DEBUG_MODE) console.log('Using posts index for fast loading');
                        loadedPosts = postsIndex.posts.filter(p => p && p.id && !p.deleted);
                        await loadRepliesForPosts(loadedPosts, postsDir);
                    } else {
                        if (DEBUG_MODE) console.log('Posts directory found, loading individual posts');
                        
                        const postDirs = [];
                        for await (const [name, handle] of postsDir.entries()) {
                            if (handle.kind === 'directory' && name.startsWith('post_')) {
                                postDirs.push([name, handle]);
                            }
                        }
                        
                        if (DEBUG_MODE) console.log(`Found ${postDirs.length} post directories`);
                        
                        const POST_BATCH_SIZE = 10;
                        
                        for (let i = 0; i < postDirs.length; i += POST_BATCH_SIZE) {
                            const batch = postDirs.slice(i, i + POST_BATCH_SIZE);
                            
                            const batchPromises = batch.map(async ([postDirName, postDirHandle]) => {
                                const postId = postDirName.replace('post_', '');
                                
                                try {
                                    const postData = await readJSONFile(postDirHandle, 'post.json');
                                    if (postData && postData.id && !postData.deleted) {
                                        return {
                                            ...postData,
                                            author: postData.author || '–ê–Ω–æ–Ω–∏–º',
                                            content: postData.content || '',
                                            timestamp: postData.timestamp || Date.now(),
                                            replies: postData.replies || [],
                                            likes: postData.likes || 0,
                                            dislikes: postData.dislikes || 0,
                                            isAuthorPost: postData.isAuthorPost || false,
                                            hasImages: postData.hasImages || false
                                        };
                                    }
                                } catch (e) {
                                }
                                return null;
                            });
                            
                            const batchResults = await Promise.all(batchPromises);
                            loadedPosts.push(...batchResults.filter(post => post !== null));
                        }
                        
                        await loadRepliesForPosts(loadedPosts, postsDir);
                        
                        try {
                            const indexData = { posts: loadedPosts, updated: Date.now() };
                            const indexHandle = await postsDir.getFileHandle('index.json', { create: true });
                            const writable = await indexHandle.createWritable();
                            await writable.write(JSON.stringify(indexData));
                            await writable.close();
                            if (DEBUG_MODE) console.log('Posts index saved for future fast loading');
                        } catch (e) {
                        }
                    }
                    
                    loadedPosts.sort((a, b) => b.timestamp - a.timestamp);
                    
                    channelData.feed = loadedPosts;
                    allFeedPosts = loadedPosts;
                    
                    postsCache.set(cacheKey, loadedPosts);
                    
                    preloadAvatarsForPosts(loadedPosts);
                    
                    const loadTime = performance.now() - startTime;
                    if (DEBUG_MODE) console.log(`Loaded ${loadedPosts.length} posts in ${loadTime.toFixed(2)}ms`);
                    
                } catch (e) {
                    if (DEBUG_MODE) console.log('No posts directory found, using existing feed data');
                }
                
            } catch (e) {
                console.error('Error loading posts from directories:', e);
            }
        }

        async function loadChannelDataIncremental(startIndex = 0, chunkSize = 50) {
            if (isLoadingChunk) return;
            isLoadingChunk = true;

            try {
                const channelDir = await getChannelDirectory();
                const channelData = await readJSONFile(channelDir, 'channel.json', {});

                if (!channelData.feed) {
                    channelData.feed = [];
                }

                totalFeedCount = channelData.feed.length;
                const endIndex = Math.min(startIndex + chunkSize, totalFeedCount);
                const chunk = channelData.feed.slice(startIndex, endIndex);

                loadedFeedChunks.push(...chunk);

                allFeedPosts = [...loadedFeedChunks].sort((a, b) => b.timestamp - a.timestamp);

                isLoadingChunk = false;
                return endIndex < totalFeedCount;
            } catch (e) {
                console.error('Error loading channel data chunk:', e);
                isLoadingChunk = false;
                return false;
            }
        }

        function countRepliesDeep(replies) {
            let total = 0;
            (function walk(arr) {
                if (!Array.isArray(arr)) return;
                for (const r of arr) {
                    total += 1;
                    if (Array.isArray(r?.nestedReplies) && r.nestedReplies.length > 0) {
                        walk(r.nestedReplies);
                    }
                }
            })(replies);
            return total;
        }

        async function createFeedItem(post) {
            if (!post || !post.id) {
                console.error('Invalid post data:', post);
                return null;
            }

            const item = document.createElement('div');
            item.className = 'feed-comment';
            item.setAttribute('data-post-id', post.id);

            const timestamp = post.timestamp || post.created || Date.now();
            const date = new Date(timestamp).toLocaleString('ru-RU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            const isAuthorPost = post.isAuthorPost || false;
            const author = post.author || post.nick || i18n.t('channelFeed.anonymous', '–ê–Ω–æ–Ω–∏–º');
            const isChannelNick = /\((–∫–∞|ka)\)\s*$/i.test(author);
            const channelNameFromNick = isChannelNick ? author.replace(/\((–∫–∞|ka)\)\s*$/i, '').trim() : null;
            const nickColor = (isAuthorPost || isChannelNick) ? '#d94b88' : getNickColor(author);
            const replyCount = countRepliesDeep(post.replies || []);
            
            const repliesText = replyCount > 0 ? `${replyCount} ${i18n.t('feed.replies', '–æ—Ç–≤–µ—Ç–æ–≤')}` : i18n.t('feed.noReplies', '–ù–µ—Ç –æ—Ç–≤–µ—Ç–æ–≤');
            const likeTitle = i18n.t('feed.like', '–õ–∞–π–∫');
            const dislikeTitle = i18n.t('feed.dislike', '–î–∏–∑–ª–∞–π–∫');
            const imageText = i18n.t('feed.image', '–ö–∞—Ä—Ç–∏–Ω–∫–∞');
            const reportText = i18n.t('channelFeed.report', '–ü–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è');
            const openText = i18n.t('feed.open', '–û—Ç–∫—Ä—ã—Ç—å');
            const authorBadge = i18n.t('feed.author', '–ê–≤—Ç–æ—Ä');
            const boldTitle = i18n.t('channelFeed.editorBold', '–ñ–∏—Ä–Ω—ã–π');
            const italicTitle = i18n.t('channelFeed.editorItalic', '–ö—É—Ä—Å–∏–≤');
            const underlineTitle = i18n.t('channelFeed.editorUnderline', '–ü–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–π');
            const linkTitle = i18n.t('channelFeed.editorLink', '–°—Å—ã–ª–∫–∞');
            const imageTitle = i18n.t('channelFeed.editorImage', '–ö–∞—Ä—Ç–∏–Ω–∫–∞');
            const centerTitle = i18n.t('channelFeed.editorCenter', '–í—ã—Ä–æ–≤–Ω—è—Ç—å –ø–æ —Ü–µ–Ω—Ç—Ä—É');
            const closeTitle = i18n.t('channelFeed.close', '–ó–∞–∫—Ä—ã—Ç—å');
            const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', '–û—Ç–≤–µ—Ç–∏—Ç—å...');
            const yourNickPlaceholder = i18n.t('channelFeed.yourNick', '–í–∞—à –Ω–∏–∫');
            const replyBtnText = i18n.t('channelFeed.reply', '–û—Ç–≤–µ—Ç–∏—Ç—å');

            item.innerHTML = `
                <div class="comment-container">
                    <div class="comment-avatar" id="postAvatar_${post.id}" style="background-color: ${nickColor}" ${(isAuthorPost || isChannelNick) ? `data-channel-avatar="${escapeHtml(isAuthorPost ? currentChannelName : channelNameFromNick)}"` : ''}>
                        ${isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(author).charAt(0).toUpperCase()}
                    </div>
                    <div class="comment-bubble">
                        <div class="comment-header">
                            <span class="comment-nick ${(isAuthorPost || isChannelNick) ? 'channel-nick' : ''}" ${isAuthorPost ? `data-channel-name="${escapeHtml(currentChannelName)}"` : (/\((–∫–∞|ka)\)\s*$/i.test(author) ? `data-channel-name="${escapeHtml(author.replace(/\((–∫–∞|ka)\)\s*$/i,'').trim())}"` : '')}>${escapeHtml(isAuthorPost ? currentChannelName : author.replace(/\((–∫–∞|ka)\)\s*$/i, '').trim())}</span>
                            ${isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                            <span class="comment-date">${date}</span>
                        </div>
                        <div class="comment-text">${processContentWithImages(post.content || post.text)}</div>
                        <div class="comment-actions">
                            <button onclick="toggleLike('${post.id}')" class="like-btn" title="${likeTitle}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                </svg>
                                <span class="like-count">${post.likes || 0}</span>
                            </button>
                            <button onclick="toggleDislike('${post.id}')" class="dislike-btn" title="${dislikeTitle}">
                                <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                    <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                </svg>
                                <span class="dislike-count">${post.dislikes || 0}</span>
                            </button>
                            <span class="replies-count" style="color:#999;font-size:10px;margin-left:8px;">${repliesText}</span>
                            ${post.hasImages ? `<button onclick=\"togglePostImage('${post.id}')\" class=\"delete-btn\" title=\"${imageTitle}\" data-post-id=\"${post.id}\">${imageText}</button>` : ''}
                            <button onclick="deleteFeedPost('${post.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                            <a href="youvi_ch_feed_rep.html?channel=${encodeURIComponent(currentChannelName)}&post_id=${encodeURIComponent(post.id)}" class="open-post-btn">${openText}</a>
                        </div>
                        <div class="reply-form" id="replyForm_${post.id}" style="display:none;margin-top:8px;padding-left:16px;">
                            <div class="compact-editor-toolbar" id="replyToolbar_${post.id}">
                                <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>

                                <button class="create-link-btn" data-post-id="${post.id}" title="${linkTitle}">üîó</button>
                                <button class="insert-image-btn" data-post-id="${post.id}" title="${imageTitle}">img</button>
                                <button class="center-image-btn" data-post-id="${post.id}" title="${centerTitle}">‚åò</button>
                                <button class="close-reply-btn" data-post-id="${post.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                <input type="file" class="image-file-input" data-post-id="${post.id}" accept="image/*" style="display:none" multiple>
                            </div>
                            <div id="replyInput_${post.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                            <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                <input type="text" id="replyNick_${post.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border:1px solid #ddd;border-radius:4px;font-size:11px;background:#fff;height:26px;">
                                <div style="display:flex;gap:6px;">
                                    <button onclick="postAuthorReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                    <button onclick="postReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                </div>
                            </div>
                        </div>
                        <!-- –†–µ–ø–ª–∞–∏ –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –≤ —Ñ–∏–¥–µ –∫–∞–Ω–∞–ª–∞, —Ç–æ–ª—å–∫–æ —Å—á–µ—Ç—á–∏–∫ -->
                    </div>
                </div>
            `;

            processImagesInPostContent(item);

            const postAvatarEl = item.querySelector(`#postAvatar_${post.id}`);
            if (postAvatarEl && (isAuthorPost || isChannelNick)) {
                const targetChannel = isAuthorPost ? currentChannelName : channelNameFromNick;
                const cacheKey = `avatar_${targetChannel}`;
                
                if (avatarCache.has(cacheKey)) {
                    const cached = avatarCache.get(cacheKey);
                    if (cached.url) {
                        postAvatarEl.style.backgroundImage = `url(${cached.url})`;
                        postAvatarEl.classList.add('custom-avatar');
                        postAvatarEl.textContent = '';
                        postAvatarEl.dataset.avatarLoaded = 'true';
                    }
                } else {
                    setupAvatarObserver();
                    if (avatarObserver) {
                        avatarObserver.observe(postAvatarEl);
                    }
                }
            }

            return item;
        }

        async function renderFeedPageVirtual() {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;

            const totalItems = allFeedPosts.length;
            const startIndex = Math.max(0, Math.floor(virtualScrollTop / itemHeight) - visibleItems);
            const endIndex = Math.min(totalItems, startIndex + visibleItems * 2);

            const offset = startIndex * itemHeight;

            feedSection.style.transform = `translateY(${offset}px)`;
            feedSection.style.height = `${totalItems * itemHeight}px`;

            const postsToShow = allFeedPosts.slice(startIndex, endIndex);
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < postsToShow.length; i++) {
                const post = postsToShow[i];
                const item = await createFeedItem(post);
                item.style.position = 'absolute';
                item.style.top = `${(startIndex + i) * itemHeight}px`;
                fragment.appendChild(item);
            }

            feedSection.innerHTML = '';
            feedSection.appendChild(fragment);

            clearTimeout(window.virtualScrollTimeout);
            window.virtualScrollTimeout = setTimeout(() => {
                setupImageLazyLoading();
            }, 100);
        }

        function setupVirtualScroll() {
            const container = document.querySelector('.main-content');
            if (container) {
                let scrollTimeout;
                container.addEventListener('scroll', (e) => {
                    virtualScrollTop = e.target.scrollTop;
                    
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(() => {
                    renderFeedPageVirtual();
                    }, 16);
                });
            }
        }

        function forceLoadAllImages() {
            const images = document.querySelectorAll('img[data-src]');
            images.forEach(img => {
                if (img.dataset.src) {
                    img.src = img.dataset.src;
                    img.classList.remove('lazy');
                    img.classList.add('loaded');
                }
            });
        }

        function forceLoadVisibleImages() {
            const lazyImages = document.querySelectorAll('img[data-src]');
            const container = document.querySelector('.main-content');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();

            lazyImages.forEach(img => {
                const imgRect = img.getBoundingClientRect();
                if (imgRect.top < containerRect.bottom + 100 && 
                    imgRect.bottom > containerRect.top - 100) {
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.classList.remove('lazy');
                        img.classList.add('loaded');
                    }
                }
            });
            
            if (DEBUG_MODE) console.log('Force loaded', loadedCount, 'visible images');
        }

        function clearImageCache() {
            imageOptimizationCache.clear();
            if (DEBUG_MODE) console.log('Image optimization cache cleared');
        }

        function setupImageLazyLoading() {
            const lazyImages = document.querySelectorAll('img[data-src]');
            const loadedImages = document.querySelectorAll('img[src]:not([data-src])');
            const totalImages = lazyImages.length + loadedImages.length;
            if (DEBUG_MODE) console.log('Setting up lazy loading for', totalImages, 'images (', lazyImages.length, 'lazy,', loadedImages.length, 'loaded)');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        const originalSrc = img.dataset.src;
                        if (DEBUG_MODE) console.log('Loading lazy image:', originalSrc);
                        
                        const testImg = new Image();
                        testImg.onload = function() {
                            if (DEBUG_MODE) console.log('Lazy image loaded successfully:', originalSrc);
                            img.src = originalSrc;
                            img.classList.remove('lazy');
                            img.classList.add('loaded');
                        };
                        testImg.onerror = function() {
                            if (DEBUG_MODE) console.log('Lazy image failed to load:', originalSrc);
                            img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTIwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZjBmMGYwIi8+Cjx0ZXh0IHg9IjYwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjY2NjIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+0J3QtdC+0LHRgNCw0LbQtdC90LjQtTwvdGV4dD4KPC9zdmc+Cg==';
                            img.classList.remove('lazy');
                            img.classList.add('error');
                        };
                        testImg.src = originalSrc;
                        
                        observer.unobserve(img);
                    }
                });
            }, {
                rootMargin: '50px 0px',
                threshold: 0.01
            });
            lazyImages.forEach(img => {
                if (!img.dataset.observed) {
                    img.dataset.observed = 'true';
                    imageObserver.observe(img);
                    if (DEBUG_MODE) console.log('Observing image:', img.dataset.src);
                }
            });

            const bgImages = document.querySelectorAll('[data-src].lazy-avatar');
            const bgImageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const el = entry.target;
                        const originalSrc = el.dataset.src;
                        
                        const testImg = new Image();
                        testImg.onload = function() {
                            el.style.backgroundImage = `url(${originalSrc})`;
                            el.classList.remove('lazy-avatar');
                            el.classList.add('loaded');
                        };
                        testImg.onerror = function() {
                            el.classList.remove('lazy-avatar');
                            el.classList.add('error');
                        };
                        testImg.src = originalSrc;
                        
                        observer.unobserve(el);
                    }
                });
            }, {
                rootMargin: '50px 0px',
                threshold: 0.01
            });
            bgImages.forEach(el => bgImageObserver.observe(el));
        }

        async function createLazyImage(src, className = '') {
            const img = document.createElement('img');
            img.className = (className + ' loaded').trim();
            img.alt = '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ';
            img.style.maxWidth = '120px';
            img.style.maxHeight = '80px';
            img.style.cursor = 'pointer';
            img.style.border = '1px solid #ddd';
            img.style.borderRadius = '0';
            img.style.objectFit = 'cover';
            img.style.display = 'block';
            img.style.opacity = '1';
            
            img.setAttribute('data-fullsrc', src);
            img.setAttribute('data-expanded', 'false');
            img.onclick = (e) => {
                e.stopPropagation();
                toggleImageSize(img);
            };
            
            img.onerror = function() {
                this.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiB2aWV3Qm94PSIwIDAgMTIwIDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cmVjdCB3aWR0aD0iMTIwIiBoZWlnaHQ9IjgwIiBmaWxsPSIjZjBmMGYwIi8+Cjx0ZXh0IHg9IjYwIiB5PSI0MCIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjY2NjIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+0J3QtdC+0LHRgNCw0LbQtdC90LjQtTwvdGV4dD4KPC9zdmc+Cg==';
                this.onerror = null;
            };
            
            img.src = src;
            
            return img;
        }


        async function openImageModal(src, fileName = null, postId = null, channelName = null) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;display:flex;align-items:center;justify-content:center;';
            
            modal.innerHTML = `
                <div style="color:white;text-align:center;">
                    <div style="margin-bottom:20px;">${i18n.t('feed.loadingImage', '–ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...')}</div>
                    <div style="width:50px;height:50px;border:3px solid #333;border-top:3px solid white;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto;"></div>
                </div>
                <style>
                    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
                </style>
            `;
            modal.onclick = () => modal.remove();
            document.body.appendChild(modal);
            
            let imageSrc = src;
            if (fileName && postId) {
                const fullImage = await loadFullImage(fileName, postId, channelName);
                if (fullImage) {
                    imageSrc = fullImage;
                    if (DEBUG_MODE) console.log('Loaded full resolution image from post directory');
                }
            }
            
            modal.innerHTML = `<img src="${imageSrc}" style="max-width:90%;max-height:90%;object-fit:contain;cursor:pointer;">`;
        }

        window.openImageModal = openImageModal;

        function toggleImageSize(imgElement) {
            const isExpanded = imgElement.getAttribute('data-expanded') === 'true';
            const fullSrc = imgElement.getAttribute('data-fullsrc');
            
            if (!isExpanded) {
                imgElement.style.maxWidth = '100%';
                imgElement.style.maxHeight = '400px';
                imgElement.style.width = 'auto';
                imgElement.style.height = 'auto';
                imgElement.style.objectFit = 'contain';
                imgElement.style.opacity = '1';
                imgElement.style.filter = 'none';
                imgElement.setAttribute('data-expanded', 'true');
                
                if (fullSrc && imgElement.src !== fullSrc) {
                    imgElement.src = fullSrc;
                }
            } else {
                imgElement.style.maxWidth = '120px';
                imgElement.style.maxHeight = '80px';
                imgElement.style.width = 'auto';
                imgElement.style.height = 'auto';
                imgElement.style.objectFit = 'cover';
                imgElement.style.opacity = '1';
                imgElement.style.filter = 'none';
                imgElement.setAttribute('data-expanded', 'false');
            }
        }

        function togglePostImage(postId) {
            const postContainer = document.querySelector(`[data-post-id="${postId}"]`)?.closest('.feed-comment');
            if (!postContainer) return;
            
            const images = postContainer.querySelectorAll('.comment-text img');
            if (images.length === 0) return;
            
            let allExpanded = true;
            images.forEach(img => {
                toggleImageSize(img);
                if (img.getAttribute('data-expanded') !== 'true') {
                    allExpanded = false;
                }
            });
            
            const button = document.querySelector(`[data-post-id="${postId}"].delete-btn`);
            if (button) {
                button.textContent = i18n.t('feed.image', '–ö–∞—Ä—Ç–∏–Ω–∫–∞');
                button.title = allExpanded ? i18n.t('feed.closeImages', '–ó–∞–∫—Ä—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è') : i18n.t('feed.openImages', '–û—Ç–∫—Ä—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
            }
        }
        
        async function renderFeed() {
            const startTime = performance.now();
            
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) {
                console.error('RenderFeed: feedSection not found');
                return;
            }

            feedSection.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <div>${i18n.t('feed.loadingPosts', '–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ—Å—Ç–æ–≤...')}</div>
                </div>
            `;

            loadedFeedChunks = [];
            totalFeedCount = 0;
            isLoadingChunk = false;

            if (!channelData.feed || channelData.feed.length === 0) {
                try {
                    await loadPostsFromDirectories();
                } catch (e) {
                    console.error('Error loading posts:', e);
                }
            }
            
            allFeedPosts = (channelData.feed || []).filter(post => post && post.id);

            if (allFeedPosts.length === 0) {
                feedSection.innerHTML = '<div style="text-align:center;color:#7a3c55;padding:40px;font-size:14px;">–õ–µ–Ω—Ç–∞ –ø—É—Å—Ç–∞</div>';
                return;
            }

            if (DEBUG_MODE) console.log(`RenderFeed: Setup in ${(performance.now() - startTime).toFixed(2)}ms, ${allFeedPosts.length} posts`);
            
            setupAvatarObserver();
            
            if (allFeedPosts.length > 50) {
                virtualScrollTop = 0;
                renderFeedPageVirtual();
            } else {
                renderFeedPageOptimized();
            }
        }
        
        async function renderFeedPageOptimized() {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;
            
            const startTime = performance.now();
            const fragment = document.createDocumentFragment();
            
            const CHUNK_SIZE = 10;
            let currentIndex = 0;
            
            const renderChunk = async () => {
                const endIndex = Math.min(currentIndex + CHUNK_SIZE, allFeedPosts.length);
                const chunk = allFeedPosts.slice(currentIndex, endIndex);
                
                const items = await Promise.all(chunk.map(post => createFeedItem(post).catch(() => null)));
                items.filter(Boolean).forEach(item => fragment.appendChild(item));
                
                currentIndex = endIndex;
                
                if (currentIndex < allFeedPosts.length) {
                    requestAnimationFrame(renderChunk);
                } else {
                    feedSection.innerHTML = '';
                    feedSection.appendChild(fragment);
                    
                    if (DEBUG_MODE) console.log(`Feed rendered in ${(performance.now() - startTime).toFixed(2)}ms`);
                    
                    setTimeout(() => setupImageLazyLoading(), 0);
                }
            };
            
            renderChunk();
        }
        
        function processImagesInPosts() {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;
            
            const postElements = feedSection.querySelectorAll('.comment-container:not([data-images-processed])');
            postElements.forEach(postElement => {
                processImagesInPostContent(postElement);
                postElement.setAttribute('data-images-processed', 'true');
            });
        }
        
        async function renderFeedPage() {
            const feedSection = document.getElementById('feedSection');
            const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
            if (!feedSection) return;
            
            setupAvatarObserver();
            
            const startIndex = feedPage * feedPageSize;
            const endIndex = startIndex + feedPageSize;
            const postsToShow = allFeedPosts.slice(startIndex, endIndex);
            
            if (feedPage === 0) {
                feedSection.innerHTML = '';
            }
            
            for (const post of postsToShow) {
                if (!post || !post.id) continue;

                const item = document.createElement('div');
                item.className = 'feed-comment';
                
                const timestamp = post.timestamp || post.created || Date.now();
                const date = new Date(timestamp).toLocaleString(i18n.getCurrentLanguage() === 'en' ? 'en-US' : (i18n.getCurrentLanguage() === 'uk' ? 'uk-UA' : 'ru-RU'), {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                const isAuthorPost = post.isAuthorPost || false;
                const author = post.author || post.nick || i18n.t('feed.anonymous', '–ê–Ω–æ–Ω–∏–º');
                const isChannelNick = /\((–∫–∞|ka)\)\s*$/i.test(author);
                const channelNameFromNick = isChannelNick ? author.replace(/\((–∫–∞|ka)\)\s*$/i, '').trim() : null;
                const nickColor = (isAuthorPost || isChannelNick) ? '#d94b88' : getNickColor(author);
                
                const replyCount = post.replies ? countRepliesDeepLocal(post.replies) : 0;
                const repliesText = replyCount > 0 ? `${replyCount} ${i18n.t('feed.replies', '–æ—Ç–≤–µ—Ç–æ–≤')}` : i18n.t('feed.noReplies', '–ù–µ—Ç –æ—Ç–≤–µ—Ç–æ–≤');
                const likeTitle = i18n.t('feed.like', '–õ–∞–π–∫');
                const dislikeTitle = i18n.t('feed.dislike', '–î–∏–∑–ª–∞–π–∫');
                const replyBtnText = i18n.t('channelFeed.reply', '–û—Ç–≤–µ—Ç–∏—Ç—å');
                const collapseTitle = i18n.t('feed.collapseReplies', '–°–≤–µ—Ä–Ω—É—Ç—å –æ—Ç–≤–µ—Ç—ã');
                const imageText = i18n.t('feed.image', '–ö–∞—Ä—Ç–∏–Ω–∫–∞');
                const openImageTitle = i18n.t('feed.openImage', '–û—Ç–∫—Ä—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ');
                const reportText = i18n.t('channelFeed.report', '–ü–æ–∂–∞–ª–æ–≤–∞—Ç—å—Å—è');
                const openText = i18n.t('feed.open', '–û—Ç–∫—Ä—ã—Ç—å');
                const authorBadge = i18n.t('feed.author', '–ê–≤—Ç–æ—Ä');
                const boldTitle = i18n.t('channelFeed.editorBold', '–ñ–∏—Ä–Ω—ã–π');
                const italicTitle = i18n.t('channelFeed.editorItalic', '–ö—É—Ä—Å–∏–≤');
                const underlineTitle = i18n.t('channelFeed.editorUnderline', '–ü–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–π');
                const linkTitle = i18n.t('channelFeed.editorLink', '–°—Å—ã–ª–∫–∞');
                const imageTitle = i18n.t('channelFeed.editorImage', '–ö–∞—Ä—Ç–∏–Ω–∫–∞');
                const centerTitle = i18n.t('channelFeed.editorCenter', '–í—ã—Ä–æ–≤–Ω—è—Ç—å –ø–æ —Ü–µ–Ω—Ç—Ä—É');
                const closeTitle = i18n.t('channelFeed.close', '–ó–∞–∫—Ä—ã—Ç—å');
                const replyPlaceholder = i18n.t('channelFeed.replyPlaceholder', '–û—Ç–≤–µ—Ç–∏—Ç—å...');
                const yourNickPlaceholder = i18n.t('channelFeed.yourNick', '–í–∞—à –Ω–∏–∫');
                
                item.innerHTML = `
                    <div class="comment-container">
                        <div class="comment-avatar" id="postAvatar_${post.id}" style="background-color: ${nickColor}">
                            ${isAuthorPost ? currentChannelName.charAt(0).toUpperCase() : escapeHtml(author).charAt(0).toUpperCase()}
                        </div>
                        <div class="comment-bubble">
                            <div class="comment-header">
                                <span class="comment-nick ${(isAuthorPost || isChannelNick) ? 'channel-nick' : ''}" ${isAuthorPost ? `data-channel-name="${escapeHtml(currentChannelName)}"` : (channelNameFromNick ? `data-channel-name="${escapeHtml(channelNameFromNick)}"` : '')}>${escapeHtml(isAuthorPost ? currentChannelName : (channelNameFromNick || author))}</span>
                                ${isAuthorPost ? `<span class="author-badge">${authorBadge}</span>` : ''}
                                <span class="comment-date">${date}</span>
                            </div>
                            <div class="comment-text">${processContentWithImages(post.content || post.text)}</div>
                            <div class="comment-actions">
                                <button onclick="toggleLike('${post.id}')" class="like-btn" title="${likeTitle}">
                                    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 4l-8 8h6v8h4v-8h6l-8-8z" fill="currentColor"/>
                                    </svg>
                                    <span class="like-count">${post.likes || 0}</span>
                                </button>
                                <button onclick="toggleDislike('${post.id}')" class="dislike-btn" title="${dislikeTitle}">
                                    <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
                                        <path d="M12 20l8-8h-6V4h-4v8H4l8 8z" fill="currentColor"/>
                                    </svg>
                                    <span class="dislike-count">${post.dislikes || 0}</span>
                                </button>
                                <button onclick="toggleReplyForm('${post.id}')" class="reply-btn" title="${replyBtnText}">${replyBtnText}</button>
                                ${post.replies && post.replies.length > 0 ? `<button onclick=\"toggleRepliesVisibility('${post.id}')\" class=\"collapse-btn\" title=\"${collapseTitle}\" data-post-id=\"${post.id}\">${imageText} (${post.replies.length})</button>` : ''}
                                <span class="replies-count" style="color:#999;font-size:10px;margin-left:8px;">${repliesText}</span>
                                ${post.hasImages ? `<button onclick=\"togglePostImage('${post.id}')\" class=\"delete-btn\" title=\"${openImageTitle}\" data-post-id=\"${post.id}\">${imageText}</button>` : ''}
                                <button onclick="deleteFeedPost('${post.id}')" class="delete-btn" title="${reportText}">${reportText}</button>
                                <a href="youvi_ch_feed_rep.html?channel=${encodeURIComponent(currentChannelName)}&post_id=${encodeURIComponent(post.id)}" class="open-post-btn">${openText}</a>
                            </div>
                            <div class="reply-form" id="replyForm_${post.id}" style="display:none;margin-top:8px;padding-left:16px;">
                                <div class="compact-editor-toolbar" id="replyToolbar_${post.id}">
                                    <button data-cmd="bold" title="${boldTitle}"><b>B</b></button>
                                    <button data-cmd="italic" title="${italicTitle}"><i>I</i></button>
                                    <button data-cmd="underline" title="${underlineTitle}"><u>U</u></button>

                                    <button class="create-link-btn" data-post-id="${post.id}" title="${linkTitle}">üîó</button>
                                    <button class="insert-image-btn" data-post-id="${post.id}" title="${imageTitle}">img</button>
                                    <button class="center-image-btn" data-post-id="${post.id}" title="${centerTitle}">‚åò</button>
                                    <button class="close-reply-btn" data-post-id="${post.id}" title="${closeTitle}" style="margin-left: auto;">${closeTitle}</button>
                                    <input type="file" class="image-file-input" data-post-id="${post.id}" accept="image/*" style="display:none" multiple>
                                </div>
                                <div id="replyInput_${post.id}" class="compact-editor" contenteditable="true" placeholder="${replyPlaceholder}" style="min-height:50px;max-height:100px;"></div>
                                <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                                    <input type="text" id="replyNick_${post.id}" placeholder="${yourNickPlaceholder}" style="width:100px;padding:4px 6px;border:1px solid #ddd;border-radius:4px;font-size:11px;background:#fff;height:26px;">
                                    <div style="display:flex;gap:6px;">
                                        <button onclick="postAuthorReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;background:#ff69b4;">${authorBadge}</button>
                                        <button onclick="postReply('${post.id}')" class="btn primary" style="padding:4px 8px;font-size:11px;height:26px;">${replyBtnText}</button>
                                    </div>
                                </div>
                            </div>
                            
                        </div>
                    </div>
                `;
                
                feedSection.appendChild(item);
                
                processImagesInPostContent(item);
                item.querySelector('.comment-container')?.setAttribute('data-images-processed', 'true');
                
                const postAvatarEl = document.getElementById(`postAvatar_${post.id}`);
                if (postAvatarEl && (isAuthorPost || channelNameFromNick)) {
                    const targetChannel = isAuthorPost ? currentChannelName : channelNameFromNick;
                    const cacheKey = `avatar_${targetChannel}`;
                    
                    if (avatarCache.has(cacheKey)) {
                        const cached = avatarCache.get(cacheKey);
                        if (cached.url) {
                            postAvatarEl.style.backgroundImage = `url(${cached.url})`;
                            postAvatarEl.classList.add('custom-avatar');
                            postAvatarEl.textContent = '';
                        }
                    } else {
                        postAvatarEl.dataset.channelAvatar = targetChannel;
                        if (avatarObserver) avatarObserver.observe(postAvatarEl);
                    }
                }
            }
            
            if (loadMoreBtn && allFeedPosts.length <= 50) {
                loadMoreBtn.style.display = endIndex < allFeedPosts.length ? 'block' : 'none';
            }

            setTimeout(() => setupImageLazyLoading(), 50);
        }
        
        async function loadMoreFeedPosts() {
            if (allFeedPosts.length > 50) return;

            const currentEndIndex = (feedPage + 1) * feedPageSize;

            if (currentEndIndex >= loadedFeedChunks.length && loadedFeedChunks.length < totalFeedCount) {
                const startIndex = loadedFeedChunks.length;
                await loadChannelDataIncremental(startIndex, 50);
                allFeedPosts = [...loadedFeedChunks].sort((a, b) => b.timestamp - a.timestamp);
            }

            feedPage++;
            await renderFeedPage();
        }

        async function loadMorePostsFromServer() {
            const channelId = getChannelIdFromUrl();
            const storedData = localStorage.getItem(`channel_${channelId}`);
            
            if (storedData) {
                try {
                    const data = JSON.parse(storedData);
                    if (data.feed && data.feed.length > allFeedPosts.length) {
                        allFeedPosts = [...data.feed].sort((a, b) => b.timestamp - a.timestamp);
                        await renderFeedPage();
                    }
                } catch (e) {
                    console.error('Error loading more posts:', e);
                }
            }
        }
        
        function toggleReplyForm(postId) {
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = replyForm.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        function toggleRepliesVisibility(postId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const feedComment = collapseBtn.closest('.feed-comment');
            if (!feedComment) return;
            
            const repliesContainer = feedComment.querySelector('.replies-container');
            if (!repliesContainer) return;
            
            const isCollapsed = repliesContainer.classList.contains('collapsed');
            const replyCount = repliesContainer.querySelectorAll('.reply-item').length;
            
            if (isCollapsed) {
                repliesContainer.classList.remove('collapsed');
                collapseBtn.innerHTML = `‚ñº –°–≤–µ—Ä–Ω—É—Ç—å (${replyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                repliesContainer.classList.add('collapsed');
                collapseBtn.innerHTML = `‚ñ∂ –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å (${replyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        function toggleReplyToReply(postId, replyId) {
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = nestedReplyForm.style.display === 'none' ? 'block' : 'none';
                if (nestedReplyForm.style.display === 'block') {
                    const input = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                    if (input) input.focus();
                }
            }
        }

        function toggleNestedRepliesVisibility(postId, replyId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"][data-reply-id="${replyId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const replyContainer = collapseBtn.closest('.reply-item');
            if (!replyContainer) return;
            
            const nestedReplies = replyContainer.querySelector('.nested-replies');
            if (!nestedReplies) return;
            
            const isCollapsed = nestedReplies.classList.contains('collapsed');
            const nestedReplyCount = nestedReplies.querySelectorAll('.nested-reply-item').length;
            
            if (isCollapsed) {
                nestedReplies.classList.remove('collapsed');
                collapseBtn.innerHTML = `‚ñº –°–≤–µ—Ä–Ω—É—Ç—å (${nestedReplyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                nestedReplies.classList.add('collapsed');
                collapseBtn.innerHTML = `‚ñ∂ –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å (${nestedReplyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        function toggleDeepNestedRepliesVisibility(postId, parentReplyId, replyId) {
            const collapseBtn = document.querySelector(`[data-post-id="${postId}"][data-parent-reply-id="${parentReplyId}"][data-reply-id="${replyId}"].collapse-btn`);
            if (!collapseBtn) return;
            
            const nestedReplyContainer = collapseBtn.closest('.nested-reply-item');
            if (!nestedReplyContainer) return;
            
            const nestedReplies = nestedReplyContainer.querySelector('.nested-replies');
            if (!nestedReplies) return;
            
            const isCollapsed = nestedReplies.classList.contains('collapsed');
            const nestedReplyCount = nestedReplies.querySelectorAll('.nested-reply-item').length;
            
            if (isCollapsed) {
                nestedReplies.classList.remove('collapsed');
                collapseBtn.innerHTML = `‚ñº –°–≤–µ—Ä–Ω—É—Ç—å (${nestedReplyCount})`;
                collapseBtn.classList.remove('collapsed');
            } else {
                nestedReplies.classList.add('collapsed');
                collapseBtn.innerHTML = `‚ñ∂ –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å (${nestedReplyCount})`;
                collapseBtn.classList.add('collapsed');
            }
        }

        async function postNestedReply(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const reply = findReplyRecursively(post.replies, replyId);
            if (!reply) return;
            
            const nestedReplyInput = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
            const nestedReplyNick = document.getElementById(`nestedReplyNick_${postId}_${replyId}`);
            
            if (!nestedReplyInput || !nestedReplyNick) return;
            
            const replyText = nestedReplyInput.innerHTML.trim();
            const nick = nestedReplyNick.value.trim();
            
            if (!replyText || !nick) return;
            
            const processedText = await processImagesInContent(replyText);
            
            const nestedReply = {
                id: Date.now().toString(),
                nick: nick,
                text: processedText,
                created: Date.now(),
                isAuthorPost: false
            };
            
            if (!reply.nestedReplies) reply.nestedReplies = [];
            reply.nestedReplies.push(nestedReply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            nestedReplyInput.innerHTML = '';
            nestedReplyNick.value = '';
            
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = 'none';
            }
            
            await renderFeed();
        }

        function findReplyRecursively(replies, replyId) {
            if (!replies) return null;
            
            for (const reply of replies) {
                if (reply.id === replyId) {
                    return reply;
                }
                if (reply.nestedReplies) {
                    const found = findReplyRecursively(reply.nestedReplies, replyId);
                    if (found) return found;
                }
            }
            return null;
        }

        async function postAuthorNestedReply(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const reply = findReplyRecursively(post.replies, replyId);
            if (!reply) return;
            
            const nestedReplyInput = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
            
            if (!nestedReplyInput) return;
            
            const replyText = nestedReplyInput.innerHTML.trim();
            
            if (!replyText) return;
            
            const processedText = await processImagesInContent(replyText);
            
            const nestedReply = {
                id: Date.now().toString(),
                nick: channelData.name || currentChannelName,
                text: processedText,
                created: Date.now(),
                isAuthorPost: true
            };
            
            if (!reply.nestedReplies) reply.nestedReplies = [];
            reply.nestedReplies.push(nestedReply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            nestedReplyInput.innerHTML = '';
            
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = 'none';
            }
            
            await renderFeed();
        }

        async function deleteNestedReply(postId, parentReplyId, nestedReplyId) {
            const confirmMsg = window.i18n ? window.i18n.t('channelFeed.confirmDeleteReply') : '–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç?';
            if (!confirm(confirmMsg)) return;
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const replies = await readJSONFile(postDir, 'replies.json', []);
                    
                    const updatedReplies = deleteNestedReplyFromArray(replies, parentReplyId, nestedReplyId);
                    
                    await writeJSONFile(postDir, 'replies.json', updatedReplies);
                    if (DEBUG_MODE) console.log('Updated nested replies in post directory');
                }
            } catch (e) {
                console.error('Error updating nested replies in post directory:', e);
            }
            
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const parentReply = findReplyRecursively(post.replies, parentReplyId);
            if (parentReply && parentReply.nestedReplies) {
                parentReply.nestedReplies = parentReply.nestedReplies.filter(nr => nr.id !== nestedReplyId);
                
                const allFeedPost = allFeedPosts.find(p => p.id === postId);
                if (allFeedPost) {
                    const allFeedParentReply = findReplyRecursively(allFeedPost.replies, parentReplyId);
                    if (allFeedParentReply && allFeedParentReply.nestedReplies) {
                        allFeedParentReply.nestedReplies = allFeedParentReply.nestedReplies.filter(nr => nr.id !== nestedReplyId);
                    }
                }
                
                await saveChannelData();
                await renderFeed();
            }
        }

        function deleteNestedReplyFromArray(replies, parentReplyId, nestedReplyId) {
            return replies.map(reply => {
                if (reply.id === parentReplyId && reply.nestedReplies) {
                    return {
                        ...reply,
                        nestedReplies: reply.nestedReplies.filter(nr => nr.id !== nestedReplyId)
                    };
                }
                if (reply.nestedReplies) {
                    return {
                        ...reply,
                        nestedReplies: deleteNestedReplyFromArray(reply.nestedReplies, parentReplyId, nestedReplyId)
                    };
                }
                return reply;
            });
        }

        function toggleNestedReplyToReply(postId, parentReplyId, replyId) {
            const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
            if (nestedReplyForm) {
                nestedReplyForm.style.display = nestedReplyForm.style.display === 'none' ? 'block' : 'none';
                if (nestedReplyForm.style.display === 'block') {
                    const input = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                    if (input) input.focus();
                }
            }
        }

        function renderNestedReplies(replies, postId, parentReplyId, depth = 1) {
            return '';
        }
        
        async function loadNestedRepliesAvatars(replies, postId, parentReplyId, depth = 1) {
            return;
        }
        
        async function postReply(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const replyInput = document.getElementById(`replyInput_${postId}`);
            const replyNick = document.getElementById(`replyNick_${postId}`);
            
            if (!replyInput || !replyNick) return;
            
            const replyText = replyInput.innerHTML.trim();
            const nick = replyNick.value.trim();
            
            if (DEBUG_MODE) console.log('Reply text:', replyText);
            if (DEBUG_MODE) console.log('Nick:', nick);
            
            if (!replyText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞');
                return;
            }
            
            if (!nick) {
                alert('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫');
                return;
            }
            
            const processedText = await processImagesInContent(replyText);
            if (DEBUG_MODE) console.log('Processed text:', processedText);
            
            const reply = {
                id: Date.now().toString(),
                nick: nick,
                text: processedText,
                created: Date.now(),
                isAuthorPost: false
            };
            
            if (!post.replies) post.replies = [];
            post.replies.push(reply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            replyInput.innerHTML = '';
            replyNick.value = '';
            
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = 'none';
            }
            
            await renderFeed();
        }
        
        async function postAuthorReply(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            const replyInput = document.getElementById(`replyInput_${postId}`);
            
            if (!replyInput) return;
            
            const replyText = replyInput.innerHTML.trim();
            
            if (!replyText) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞');
                return;
            }
            
            const processedText = await processImagesInContent(replyText);
            
            const reply = {
                id: Date.now().toString(),
                nick: channelData.name || currentChannelName,
                text: processedText,
                created: Date.now(),
                isAuthorPost: true
            };
            
            if (!post.replies) post.replies = [];
            post.replies.push(reply);
            
            await saveChannelData();
            await saveRepliesToFile(postId, post.replies);
            
            replyInput.innerHTML = '';
            
            const replyForm = document.getElementById(`replyForm_${postId}`);
            if (replyForm) {
                replyForm.style.display = 'none';
            }
            
            await renderFeed();
        }
        
                        async function deleteReply(postId, replyId) {
            const confirmMsg = window.i18n ? window.i18n.t('channelFeed.confirmDeleteReply') : '–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ—Ç –æ—Ç–≤–µ—Ç?';
            if (!confirm(confirmMsg)) return;
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const replies = await readJSONFile(postDir, 'replies.json', []);
                    const updatedReplies = replies.filter(r => r.id !== replyId);
                    
                    await writeJSONFile(postDir, 'replies.json', updatedReplies);
                    if (DEBUG_MODE) console.log('Updated replies in post directory');
                }
            } catch (e) {
                console.error('Error updating replies in post directory:', e);
            }
            
            const post = channelData.feed.find(p => p.id === postId);
            if (post && post.replies) {
                post.replies = post.replies.filter(r => r.id !== replyId);
                
                const allFeedPost = allFeedPosts.find(p => p.id === postId);
                if (allFeedPost && allFeedPost.replies) {
                    allFeedPost.replies = allFeedPost.replies.filter(r => r.id !== replyId);
                }
                
                await saveChannelData();
                
                await renderFeed();
            }
        }
        
        async function deleteFeedPost(postId) {
            const confirmMsg = window.i18n ? window.i18n.t('channelFeed.confirmDeletePost') : '–£–¥–∞–ª–∏—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ?';
            if (!confirm(confirmMsg)) {
                return;
            }
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    if (DEBUG_MODE) console.log('Post directory will be left in file system (not deletable via API)');
                }
            } catch (e) {
                console.error('Error deleting post directory:', e);
            }
            
            try {
                if (videoDirectoryHandle && currentChannelName) {
                    const channelDir = await getChannelDirectory();
                    const postsDir = await channelDir.getDirectoryHandle('posts');
                    const postDir = await postsDir.getDirectoryHandle(`post_${postId}`);
                    
                    const postData = await readJSONFile(postDir, 'post.json', {});
                    
                    postData.deleted = true;
                    postData.deletedAt = Date.now();
                    
                    await writeJSONFile(postDir, 'post.json', postData);
                    if (DEBUG_MODE) console.log(`Marked post ${postId} as deleted in post.json`);
                }
            } catch (e) {
                console.error('Error marking post as deleted:', e);
            }
            
            const beforeCount = channelData.feed ? channelData.feed.length : 0;
            channelData.feed = channelData.feed.filter(post => post.id !== postId);
            const afterCount = channelData.feed ? channelData.feed.length : 0;
            if (DEBUG_MODE) console.log(`Deleted post ${postId}: ${beforeCount} -> ${afterCount} posts`);
            
            const beforeAllCount = allFeedPosts ? allFeedPosts.length : 0;
            allFeedPosts = allFeedPosts.filter(post => post.id !== postId);
            const afterAllCount = allFeedPosts ? allFeedPosts.length : 0;
            if (DEBUG_MODE) console.log(`Deleted from allFeedPosts: ${beforeAllCount} -> ${afterAllCount} posts`);
            
            await saveChannelMetadata();
            
            await renderFeed();
        }

        async function toggleLike(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            if (!post.likes) post.likes = 0;
            
            post.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleLike('${postId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = post.likes;
            }
            
            await savePostToDirectory(post);
        }
        
        async function toggleDislike(postId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post) return;
            
            if (!post.dislikes) post.dislikes = 0;
            
            post.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleDislike('${postId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = post.dislikes;
            }
            
            await savePostToDirectory(post);
        }

        async function toggleReplyLike(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const reply = post.replies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.likes) reply.likes = 0;
            reply.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleReplyLike('${postId}', '${replyId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = reply.likes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function toggleReplyDislike(postId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const reply = post.replies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.dislikes) reply.dislikes = 0;
            reply.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleReplyDislike('${postId}', '${replyId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = reply.dislikes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }

        async function toggleNestedReplyLike(postId, parentReplyId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const parentReply = post.replies.find(r => r.id === parentReplyId);
            if (!parentReply || !parentReply.nestedReplies) return;
            
            const reply = parentReply.nestedReplies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.likes) reply.likes = 0;
            reply.likes++;
            
            const likeCountElement = document.querySelector(`button[onclick="toggleNestedReplyLike('${postId}', '${parentReplyId}', '${replyId}')"] .like-count`);
            if (likeCountElement) {
                likeCountElement.textContent = reply.likes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function toggleNestedReplyDislike(postId, parentReplyId, replyId) {
            const post = channelData.feed.find(p => p.id === postId);
            if (!post || !post.replies) return;
            
            const parentReply = post.replies.find(r => r.id === parentReplyId);
            if (!parentReply || !parentReply.nestedReplies) return;
            
            const reply = parentReply.nestedReplies.find(r => r.id === replyId);
            if (!reply) return;
            
            if (!reply.dislikes) reply.dislikes = 0;
            reply.dislikes++;
            
            const dislikeCountElement = document.querySelector(`button[onclick="toggleNestedReplyDislike('${postId}', '${parentReplyId}', '${replyId}')"] .dislike-count`);
            if (dislikeCountElement) {
                dislikeCountElement.textContent = reply.dislikes;
            }
            
            await saveRepliesToFile(postId, post.replies);
        }
        
        async function createFeedPost(isAuthor = false) {
            const feedInput = document.getElementById('feedInput');
            const feedNick = document.getElementById('feedNick');
            
            if (!feedInput) return;
            
            const text = feedInput.innerHTML.trim();
            const nick = isAuthor ? currentChannelName : (feedNick ? feedNick.value.trim() : '');
            
            if (!text) {
                alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏');
                return;
            }
            
            if (!isAuthor && !nick) {
                alert('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–∏–∫');
                return;
            }
            
            const processedText = await processImagesInContent(text);
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            const images = tempDiv.querySelectorAll('img');
            const hasImages = images.length > 0;
            
            const post = {
                id: Date.now().toString(),
                author: nick,
                content: processedText,
                timestamp: Date.now(),
                likes: 0,
                dislikes: 0,
                replies: [],
                edited: false,
                editedAt: null,
                isAuthorPost: isAuthor,
                hasImages: hasImages
            };
            
            channelData.feed = channelData.feed || [];
            channelData.feed.push(post);
            
            channelData.feed.sort((a, b) => b.timestamp - a.timestamp);
            
            await savePostToDirectory(post);
            
            await saveChannelData();
            
            await renderFeed();
            
            feedInput.innerHTML = '';
            if (feedNick && !isAuthor) {
                feedNick.value = '';
            }
        }

        function clearOldLocalStorageData() {
            try {
                const keys = Object.keys(localStorage);
                const channelKeys = keys.filter(key => key.startsWith('channel_'));
                
                if (channelKeys.length > 10) {
                    if (DEBUG_MODE) console.log('Clearing old localStorage data...');
                    channelKeys.forEach(key => {
                        localStorage.removeItem(key);
                    });
                    if (DEBUG_MODE) console.log('Cleared', channelKeys.length, 'old channel entries');
                }
            } catch (e) {
                console.error('Error clearing localStorage:', e);
            }
        }

        async function saveChannelData() {
            const channelId = getChannelIdFromUrl();
            if (DEBUG_MODE) console.log('Saving channel data:', channelData);
            try {
                
                const minimalChannelData = {
                    name: channelData.name,
                    description: channelData.description,
                    avatar: channelData.avatar,
                    header: channelData.header,
                    background: channelData.background,
                    textColor: channelData.textColor,
                    theme: channelData.theme,
                    playlists: channelData.playlists || [],
                    stats: channelData.stats || { videos: 0, views: 0 },
                    created: channelData.created,
                    postIds: channelData.feed ? channelData.feed.map(post => post.id) : []
                };
                
                const dataString = JSON.stringify(minimalChannelData);
                const dataSize = new Blob([dataString]).size;
                if (DEBUG_MODE) console.log('Minimal channel data size:', dataSize, 'bytes');
                
                if (dataSize > 5 * 1024 * 1024) {
                    console.warn('Data too large for localStorage, saving only to file system');
                    clearOldLocalStorageData();
                } else {
                    localStorage.setItem(`channel_${channelId}`, dataString);
                    if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage');
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to file system');
                    } catch (e) {
                        console.error('Error saving to file system:', e);
                    }
                }
            } catch (e) {
                console.error('Error saving channel data:', e);
                if (e.name === 'QuotaExceededError') {
                    if (DEBUG_MODE) console.log('localStorage quota exceeded, clearing old data...');
                    clearOldLocalStorageData();
                    try {
                        localStorage.setItem(`channel_${channelId}`, JSON.stringify(minimalChannelData));
                        if (DEBUG_MODE) console.log('Saved to localStorage after clearing old data');
                    } catch (retryError) {
                        console.error('Still failed after clearing old data:', retryError);
                    }
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved to file system as fallback');
                    } catch (fileError) {
                        console.error('Error saving to file system as fallback:', fileError);
                    }
                }
            }
        }

        async function saveChannelMetadata() {
            const channelId = getChannelIdFromUrl();
            if (DEBUG_MODE) console.log('Saving channel metadata only');
            try {
                const minimalChannelData = {
                    name: channelData.name,
                    description: channelData.description,
                    avatar: channelData.avatar,
                    header: channelData.header,
                    background: channelData.background,
                    textColor: channelData.textColor,
                    theme: channelData.theme,
                    playlists: channelData.playlists || [],
                    stats: channelData.stats || { videos: 0, views: 0 },
                    created: channelData.created,
                    postIds: channelData.feed ? channelData.feed.map(post => post.id) : []
                };
                
                const dataString = JSON.stringify(minimalChannelData);
                const dataSize = new Blob([dataString]).size;
                if (DEBUG_MODE) console.log('Minimal channel data size:', dataSize, 'bytes');
                
                try {
                    localStorage.setItem(`channel_${channelId}`, dataString);
                    if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage');
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        if (DEBUG_MODE) console.log('localStorage quota exceeded, clearing old data');
                        await clearOldLocalStorageData();
                        localStorage.setItem(`channel_${channelId}`, dataString);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to localStorage after clearing');
                    } else {
                        throw e;
                    }
                }
                
                if (videoDirectoryHandle && currentChannelName) {
                    try {
                        const channelDir = await getChannelDirectory();
                        await writeJSONFile(channelDir, 'channel.json', minimalChannelData);
                        if (DEBUG_MODE) console.log('Saved minimal channel data to file system');
                    } catch (e) {
                        console.error('Error saving to file system:', e);
                    }
                }
            } catch (e) {
                console.error('Error saving channel metadata:', e);
            }
        }
        
        document.addEventListener('DOMContentLoaded', async function() {
            if (DEBUG_MODE) console.log('Channel page initialized');
            if (DEBUG_MODE) console.log('Current URL:', window.location.href);
            if (DEBUG_MODE) console.log('URL search params:', window.location.search);
            if (DEBUG_MODE) console.log('URL hash:', window.location.hash);

            if (DEBUG_MODE) console.log('Starting channel initialization...');
            await initializeChannelWithFileSystem();
            if (DEBUG_MODE) console.log('Channel initialization completed');

            setupTabs();

            setupChannelControls();

            setupEventListeners();

            setupEditorToolbars();

            setupEnterKeyHandling();

            setupVirtualScroll();

            setupImageLazyLoading();

            setupSorting();

            setupViewModeToggle();

            setupBannerEvents();

            const savedMode = localStorage.getItem('youvi_channel_view_mode') || 'compact';
            applyViewMode(savedMode);




            window.addEventListener('beforeunload', () => {
                clearImageCache();
            });

            setInterval(() => {
                if (imageOptimizationCache.size > MAX_CACHE_SIZE * 0.8) {
                    clearImageCache();
                }
            }, 300000);

            if (window.i18n && window.i18n.subscribe) {
                window.i18n.subscribe(updateDynamicI18n);
            }
        });
        
        function updateDynamicI18n() {
            if (channelData && channelData.stats) {
                const stats = channelData.stats;
                let statsText = window.i18n 
                    ? window.i18n.t('channelFeed.stats')
                    : '{videos} –≤–∏–¥–µ–æ ‚Ä¢ {views} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤';
                statsText = statsText
                    .replace('{videos}', stats.videos)
                    .replace('{views}', stats.views.toLocaleString());
                const statsEl = document.getElementById('channelStats');
                if (statsEl) statsEl.textContent = statsText;
            }
            
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (subscribeBtn) {
                const isSubscribed = subscribeBtn.classList.contains('subscribed');
                subscribeBtn.textContent = window.i18n 
                    ? window.i18n.t(isSubscribed ? 'channels.subscribed' : 'channels.subscribe')
                    : (isSubscribed ? '–ü–æ–¥–ø–∏—Å–∞–Ω' : '–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è');
            }
        }
        
        function setupSorting() {
            setActiveSort('sortNew');

            const sortNew = document.getElementById('sortNew');
            const sortBest = document.getElementById('sortBest');
            const sortOld = document.getElementById('sortOld');
            const sortRandom = document.getElementById('sortRandom');
            const sortWorst = document.getElementById('sortWorst');

            if (sortNew) {
                sortNew.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortNew');
                    await sortFeed('new');
                });
            }

            if (sortBest) {
                sortBest.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortBest');
                    await sortFeed('best');
                });
            }

            if (sortOld) {
                sortOld.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortOld');
                    await sortFeed('old');
                });
            }

            if (sortRandom) {
                sortRandom.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortRandom');
                    await sortFeed('random');
                });
            }

            if (sortWorst) {
                sortWorst.addEventListener('click', async (e) => {
                    e.preventDefault();
                    setActiveSort('sortWorst');
                    await sortFeed('worst');
                });
            }
        }

        function setupViewModeToggle() {
            const compactBtn = document.getElementById('compactMode');
            const socialBtn = document.getElementById('socialMode');
            const mainContent = document.querySelector('.main-content');
            if (!compactBtn || !socialBtn || !mainContent) return;

            const savedMode = localStorage.getItem('youvi_channel_view_mode') || 'compact';
            applyViewMode(savedMode);

            compactBtn.addEventListener('click', (e) => {
                e.preventDefault();
                applyViewMode('compact');
            });
            socialBtn.addEventListener('click', (e) => {
                e.preventDefault();
                applyViewMode('social');
            });
        }

        function applyViewMode(mode) {
            const compactBtn = document.getElementById('compactMode');
            const socialBtn = document.getElementById('socialMode');
            const mainContent = document.querySelector('.main-content');
            const feedSection = document.getElementById('feedSection');
            if (!compactBtn || !socialBtn || !mainContent || !feedSection) return;

            compactBtn.classList.remove('active');
            socialBtn.classList.remove('active');
            mainContent.classList.toggle('social-mode', mode === 'social');
            feedSection.classList.toggle('social-mode', mode === 'social');
            if (mode === 'social') socialBtn.classList.add('active'); else compactBtn.classList.add('active');
            localStorage.setItem('youvi_channel_view_mode', mode);

            if (mode === 'social') {
                setTimeout(() => handleScroll(), 100);
            } else {
                hideBanner();
            }

            setTimeout(() => {
                const images = feedSection.querySelectorAll('.comment-text img, .reply-text img, .nested-reply-text img');
                images.forEach(img => {
                    if (mode === 'social') {
                        img.onclick = null;
                        img.style.cursor = 'default';
                        img.style.maxWidth = '';
                        img.style.maxHeight = '';
                        img.style.width = '';
                        img.style.height = '';
                        img.style.objectFit = '';
                    } else {
                        img.onclick = (e) => { e.stopPropagation(); toggleImageSize(img); };
                        img.style.cursor = 'pointer';
                    }
                });
            }, 0);
        }

        function countRepliesDeepLocal(replies) {
            let total = 0;
            (function walk(arr) {
                if (!Array.isArray(arr)) return;
                for (const r of arr) {
                    total += 1;
                    if (Array.isArray(r?.nestedReplies) && r.nestedReplies.length > 0) {
                        walk(r.nestedReplies);
                    }
                }
            })(replies || []);
            return total;
        }

        let bannerEnabled = true;
        function showBanner() {
            if (!bannerEnabled) return;
            const banner = document.getElementById('floatingBanner');
            const feedPosts = document.getElementById('feedSection');
            if (!banner || !feedPosts || !feedPosts.classList.contains('social-mode')) return;
            banner.classList.add('visible');
        }

        function hideBanner() {
            const banner = document.getElementById('floatingBanner');
            if (banner) banner.classList.remove('visible');
        }

        function handleScroll() {
            const feedSection = document.getElementById('feedSection');
            const banner = document.getElementById('floatingBanner');
            if (!feedSection || !banner || !feedSection.classList.contains('social-mode') || !bannerEnabled) return;

            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollThreshold = 300;
            if (scrollTop >= scrollThreshold) {
                showBanner();
            } else {
                hideBanner();
            }

            const footer = document.querySelector('.footer');
            if (footer && banner.classList.contains('visible')) {
                const footerRect = footer.getBoundingClientRect();
                const triggerDistance = 100;
                const footerDistanceFromBottom = footerRect.top - window.innerHeight;
                const shouldMoveBanner = footerDistanceFromBottom < triggerDistance;
                if (shouldMoveBanner) {
                    const moveDistance = Math.max(0, triggerDistance - footerDistanceFromBottom);
                    banner.style.bottom = (20 + moveDistance) + 'px';
                } else {
                    banner.style.bottom = '20px';
                }
            }
        }

        function setupBannerEvents() {
            window.addEventListener('scroll', handleScroll);
            document.addEventListener('keydown', (e) => {
                if (e.keyCode === 66 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                    if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) return;
                    e.preventDefault();
                    bannerEnabled = !bannerEnabled;
                    if (!bannerEnabled) {
                        hideBanner();
                    } else {
                        setTimeout(() => handleScroll(), 100);
                    }
                }
            });
        }

        function setActiveSort(activeId) {
            document.querySelectorAll('#sortNew, #sortBest, #sortOld, #sortRandom, #sortWorst').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.getElementById(activeId);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        async function sortFeed(sortType) {
            if (!channelData.feed) return;
            
            let sortedPosts = [...channelData.feed];
            
            switch (sortType) {
                case 'new':
                    sortedPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    break;
                case 'old':
                    sortedPosts.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
                    break;
                case 'best':
                    sortedPosts.sort((a, b) => {
                        const aLikes = a.likes || 0;
                        const bLikes = b.likes || 0;
                        return bLikes - aLikes;
                    });
                    break;
                case 'worst':
                    sortedPosts.sort((a, b) => {
                        const aDislikes = a.dislikes || 0;
                        const bDislikes = b.dislikes || 0;
                        return bDislikes - aDislikes;
                    });
                    break;
                case 'random':
                    sortedPosts.sort(() => Math.random() - 0.5);
                    break;
                default:
                    sortedPosts.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            }
            
            await renderFeedWithPosts(sortedPosts);
        }

        async function renderFeedWithPosts(posts) {
            const feedSection = document.getElementById('feedSection');
            if (!feedSection) return;
            
            feedSection.innerHTML = '';
            
            if (posts.length === 0) {
                feedSection.innerHTML = '<div style="text-align:center;color:#666;padding:40px;">–ù–µ—Ç –ø–æ—Å—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</div>';
                return;
            }
            
            setupAvatarObserver();
            
            const fragment = document.createDocumentFragment();
            const BATCH_SIZE = 10;
            
            for (let i = 0; i < posts.length; i += BATCH_SIZE) {
                const batch = posts.slice(i, i + BATCH_SIZE);
                const items = await Promise.all(batch.map(post => createFeedItem(post).catch(() => null)));
                items.filter(Boolean).forEach(item => fragment.appendChild(item));
            }
            
            feedSection.appendChild(fragment);
            
            setTimeout(() => setupImageLazyLoading(), 100);
            
            setupEventListeners();
        }


        
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;
                    
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    const targetContent = document.getElementById(targetTab + 'Tab');
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });
        }
        
        function setupChannelControls() {
            const controlBtns = document.querySelectorAll('.control-btn');
            controlBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const action = btn.id;
                    if (DEBUG_MODE) console.log('Channel control clicked:', action);
                });
            });
        }

        async function setupSubscriptionButton() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (!subscribeBtn || !currentChannelName) return;

            try {
                let subscriptions = await loadSubscriptionsFromFile();
                let db = null;
                
                if (!subscriptions) {
                    db = await openDB();
                    subscriptions = await getFromDB(db, 'subscriptions') || [];
                }
                
                if (!Array.isArray(subscriptions)) {
                    subscriptions = [];
                }
                
                const isSubscribed = subscriptions.includes(currentChannelName);
                if (DEBUG_MODE) console.log('Current channel:', currentChannelName, 'Is subscribed:', isSubscribed);

                if (isSubscribed) {
                    subscribeBtn.textContent = i18n.t('channels.subscribed');
                    subscribeBtn.classList.add('subscribed');
                } else {
                    subscribeBtn.textContent = i18n.t('channels.subscribe');
                    subscribeBtn.classList.remove('subscribed');
                }

                let currentSubscriptionState = isSubscribed;

                subscribeBtn.addEventListener('click', async () => {
                    try {
                        if (DEBUG_MODE) console.log('Subscription button clicked. Current state:', currentSubscriptionState);
                        
                        if (!db) {
                            if (DEBUG_MODE) console.log('Creating new database connection...');
                            db = await openDB();
                        }
                        
                        if (!subscriptions || !Array.isArray(subscriptions)) {
                            subscriptions = await loadSubscriptionsFromFile() || [];
                            if (!Array.isArray(subscriptions)) {
                                subscriptions = [];
                            }
                        }
                        
                        if (currentSubscriptionState) {
                            if (DEBUG_MODE) console.log('Unsubscribing from channel:', currentChannelName);
                            const index = subscriptions.indexOf(currentChannelName);
                            if (index > -1) {
                                subscriptions.splice(index, 1);
                                if (DEBUG_MODE) console.log('Updated subscriptions list after unsubscribe:', subscriptions);
                                
                                await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);
                                
                                subscribeBtn.textContent = i18n.t('channels.subscribe');
                                subscribeBtn.classList.remove('subscribed');
                                currentSubscriptionState = false;

                                await renderSubscribedChannelsList();

                                const verification = localStorage.getItem('8site_subscriptions');
                                if (DEBUG_MODE) console.log('Verification - localStorage after unsubscribe:', verification);
                            }
                        } else {
                            if (DEBUG_MODE) console.log('Subscribing to channel:', currentChannelName);
                            if (!subscriptions.includes(currentChannelName)) {
                                subscriptions.push(currentChannelName);
                            }
                            if (DEBUG_MODE) console.log('Updated subscriptions list after subscribe:', subscriptions);
                            
                            await saveToDB(db, 'subscriptions', 'subscriptions', subscriptions);
                            
                            subscribeBtn.textContent = i18n.t('channels.subscribed');
                            subscribeBtn.classList.add('subscribed');
                            currentSubscriptionState = true;

                            await renderSubscribedChannelsList();

                            const verification = localStorage.getItem('8site_subscriptions');
                            if (DEBUG_MODE) console.log('Verification - localStorage after subscribe:', verification);
                        }
                    } catch (e) {
                        console.error('Error updating subscription:', e);
                    }
                });
            } catch (e) {
                console.error('Error setting up subscription button:', e);
                subscribeBtn.textContent = i18n.t('channels.subscribe');
                subscribeBtn.classList.remove('subscribed');
            }
        }
        
        function initializeChannel() {
            loadChannelData();
            
            document.getElementById('channelName').textContent = currentChannelName;
            document.getElementById('channelAvatar').textContent = currentChannelName.charAt(0).toUpperCase();
            
            const stats = channelData.stats || { videos: 0, views: 0 };
            let statsText = window.i18n 
                ? window.i18n.t('channelFeed.stats')
                : '{videos} –≤–∏–¥–µ–æ ‚Ä¢ {views} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤';
            statsText = statsText
                .replace('{videos}', stats.videos)
                .replace('{views}', stats.views.toLocaleString());
            document.getElementById('channelStats').textContent = statsText;
            
            document.title = `${currentChannelName} | Youvi`;
        }

        
        async function loadAllVideosAndPlaylistsForAutocomplete() {
          if (typeof AutocompleteDataLoader === 'undefined') {
            console.error('[Autocomplete] AutocompleteDataLoader module not loaded');
            return { videos: [], playlists: [] };
          }
          
          const result = await AutocompleteDataLoader.loadData();
          return { videos: result.videos || [], playlists: result.playlists || [] };
        }

        async function initializeChannelWithFileSystem() {
            currentChannelName = getUrlParam('channel');
            if (!currentChannelName) {
                const hash = window.location.hash.substring(1);
                if (hash) {
                    currentChannelName = hash;
                }
            }

            try {
                if (DEBUG_MODE) console.log('Opening IndexedDB...');
                const db = await openDB();
                if (DEBUG_MODE) console.log('IndexedDB opened:', db);
                
                const savedHandle = await getFromDB(db, 'videoDirectoryHandle');
                if (DEBUG_MODE) console.log('Saved video directory handle:', savedHandle);
                
                if (savedHandle) {
                    if (DEBUG_MODE) console.log('Checking permission for saved handle...');
                    const permission = await savedHandle.queryPermission();
                    if (DEBUG_MODE) console.log('Permission status:', permission);
                    
                                            if (permission === 'granted' || (permission === 'prompt' && await savedHandle.requestPermission() === 'granted')) {
                            if (DEBUG_MODE) console.log('Permission granted, setting video directory handle');
                            videoDirectoryHandle = savedHandle;
                            await loadChannelData();
                            await setupSubscriptionButton();
                            await syncSubscriptions();
                            await renderSubscribedChannelsList();
                            
                            try {
                              const searchInput = document.getElementById('headerSearchInput');
                              if (searchInput && typeof AutocompleteIntegration !== 'undefined' && typeof YouviAutocomplete !== 'undefined') {
                                const { videos, playlists } = await loadAllVideosAndPlaylistsForAutocomplete();
                                
                                const cacheValid = await window.autocompleteCache.isCacheValid(
                                  videos.length,
                                  playlists.length
                                );
                                
                                const autocompleteIntegration = new AutocompleteIntegration();
                                await autocompleteIntegration.init(searchInput, {
                                  videoDirectoryHandle: videoDirectoryHandle,
                                  allVideos: cacheValid ? [] : videos,
                                  allPlaylists: cacheValid ? [] : playlists
                                });
                                if (DEBUG_MODE) console.log('[Autocomplete] ‚úÖ Initialized on youvi_ch_feed.html');
                              }
                            } catch (error) {
                              console.error('[Autocomplete] Failed to initialize:', error);
                            }
                            
                            await renderChannel();
                            
                            if (DEBUG_MODE) console.log('Starting feed render...');
                            await renderFeedPage();
                            if (DEBUG_MODE) console.log('Feed render completed');
                            
                            const postId = getUrlParam('post_id');
                            if (postId) {
                                if (DEBUG_MODE) console.log('Post ID found in URL, scrolling to post:', postId);
                                setTimeout(async () => {
                                    await scrollToPost(postId);
                                }, 1000);
                            } else {
                                const hash = window.location.hash;
                                if (hash && hash.startsWith('#post_')) {
                                    const hashPostId = hash.substring(6);
                                    if (DEBUG_MODE) console.log('Post ID found in hash, scrolling to post:', hashPostId);
                                    setTimeout(async () => {
                                        await scrollToPost(hashPostId);
                                    }, 1000);
                                }
                            }
                        } else {
                            if (DEBUG_MODE) console.log('Permission denied');
                            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–µ —Å –≤–∏–¥–µ–æ</strong></div>';
                        }
                } else {
                    if (DEBUG_MODE) console.log('No saved video directory handle found');
                    document.body.innerHTML = '<div style="padding:20px;text-align:center;color:#7a3c55"><strong>–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É —Å –≤–∏–¥–µ–æ –Ω–∞ –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ</strong></div>';
                }
            } catch (e) {
                console.error('Error accessing directory:', e);
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red"><strong>–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ</strong></div>';
            }
        }

        async function renderChannel() {
            if (DEBUG_MODE) console.log('Rendering channel:', currentChannelName);
            if (DEBUG_MODE) console.log('Channel data:', channelData);
            
            if (!channelData) {
                if (DEBUG_MODE) console.log('Channel data not loaded, waiting...');
                await loadChannelData();
            }
            
            document.getElementById('channelName').textContent = currentChannelName;
            document.getElementById('channelAvatar').textContent = currentChannelName.charAt(0).toUpperCase();
            document.title = `${currentChannelName} | Youvi`;

            const nameEl = document.getElementById('channelName');
            if (nameEl) {
                nameEl.className = `channel-name ${channelData.textColor === 'black' ? 'dark-text' : ''}`;
            }

            const channelDir = await getChannelDirectory();
            
            if (channelData && channelData.avatar) {
                const avatarEl = document.getElementById('channelAvatar');
                loadLazyImageFile(channelDir, channelData.avatar, avatarEl, 'custom-avatar')
                    .then(() => { avatarEl.textContent = ''; })
                    .catch(() => { avatarEl.textContent = currentChannelName.charAt(0).toUpperCase(); });
            }

            if (channelData && channelData.header) {
                const headerEl = document.getElementById('channelHeader');
                loadImageFile(channelDir, channelData.header)
                    .then(url => {
                        if (url) {
                            headerEl.style.backgroundImage = `url(${url})`;
                            headerEl.classList.add('custom-bg');
                        }
                    })
                    .catch(() => {});
            }

            if (channelData.background) {
                loadImageFile(channelDir, channelData.background)
                    .then(url => {
                        if (url) {
                            document.body.style.setProperty('--bg-image', `url(${url})`);
                            document.body.classList.add('custom-background');
                        }
                    })
                    .catch(() => {
                        document.body.classList.remove('custom-background');
                        document.body.style.removeProperty('--bg-image');
                    });
            }

            loadChannelVideos().catch(e => console.error('Error loading videos:', e));

            await renderFeed();
        }

        function setupEventListeners() {
            const postFeed = document.getElementById('postFeed');
            if (postFeed) {
                postFeed.addEventListener('click', async () => {
                    await createFeedPost(false);
                });
            }
            
            document.addEventListener('click', (e) => {
                const channelSpan = e.target.closest('[data-channel-name]');
                if (channelSpan) {
                    const ch = channelSpan.getAttribute('data-channel-name');
                    if (ch) {
                        e.preventDefault();
                        window.location.href = `youvi_ch_feed.html?channel=${encodeURIComponent(ch)}`;
                        return;
                    }
                }
                if (e.target.matches('[data-tab]')) {
                    e.preventDefault();
                    const tab = e.target.dataset.tab;
                    if (tab === 'feed') {
                        window.location.href = `youvi_ch_feed.html?channel=${encodeURIComponent(currentChannelName)}`;
                    } else {
                        window.location.href = `youvi_ch_view.html?channel=${encodeURIComponent(currentChannelName)}&tab=${tab}`;
                    }
                }
            });
            
            const authorPostBtn = document.getElementById('authorPostBtn');
            if (authorPostBtn) {
                authorPostBtn.addEventListener('click', async () => {
                    const text = document.getElementById('feedInput').innerHTML.trim();
                    
                    if (!text) {
                        alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏');
                        return;
                    }
                    
                    await createFeedPost(true);
                    
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'position:fixed;top:15px;right:15px;background:#4caf50;color:white;padding:10px 15px;border-radius:6px;z-index:1000;animation:slideIn 0.3s ease-out;';
                    successMsg.textContent = '–ü–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –æ—Ç –∏–º–µ–Ω–∏ –∫–∞–Ω–∞–ª–∞!';
                    document.body.appendChild(successMsg);
                    
                    setTimeout(() => {
                        successMsg.style.animation = 'slideOut 0.3s ease-in';
                        setTimeout(() => successMsg.remove(), 300);
                    }, 2000);
                });
            }
            
            const loadMoreBtn = document.getElementById('loadMoreFeedBtn');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', async () => {
                    await loadMoreFeedPosts();
                });
            }
            
             document.addEventListener('click', (e) => {
                 if (e.target.classList.contains('close-reply-btn')) {
                     const postId = e.target.dataset.postId;
                     const replyForm = document.getElementById(`replyForm_${postId}`);
                     if (replyForm) {
                         replyForm.style.display = 'none';
                     }
                 }
                 
                 if (e.target.classList.contains('close-nested-reply-btn')) {
                     const postId = e.target.dataset.postId;
                     const replyId = e.target.dataset.replyId;
                     const nestedReplyForm = document.getElementById(`nestedReplyForm_${postId}_${replyId}`);
                     if (nestedReplyForm) {
                         nestedReplyForm.style.display = 'none';
                     }
                 }
             });

            window.addEventListener('subscriptionChanged', async function() {
                await setupSubscriptionButton();
                await renderSubscribedChannelsList();
            });

            window.addEventListener('storage', async function(e) {
                if (e.key === '8site_subscriptions') {
                    await setupSubscriptionButton();
                }
            });
        }
        
        function setupEditorToolbars() {
            document.addEventListener('input', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è') {
                        const toolbar = editor.previousElementSibling;
                        if (toolbar && toolbar.classList.contains('compact-editor-toolbar')) {
                            toolbar.querySelectorAll('button[data-cmd]').forEach(btn => {
                                btn.classList.remove('active');
                            });
                        }
                    }
                }
            });
            
            document.addEventListener('focusin', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è') {
                        editor.textContent = '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è';
                        editor.style.color = '#999';
                    }
                }
            });
            
            document.addEventListener('keydown', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è' && ev.key.length === 1) {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('focusout', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    const text = editor.textContent || editor.innerText;
                    
                    if (text === '' || text === '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è') {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('click', (ev) => {
                if (ev.target.matches('#feedInput + .compact-editor-toolbar button[data-cmd]')) {
                    ev.preventDefault();
                    const button = ev.target;
                    const editor = document.getElementById('feedInput');
                    
                    if (editor) {
                        editor.focus();
                        
                        const selection = document.getSelection();
                        if (selection.rangeCount === 0 || selection.isCollapsed) {
                            const range = selection.getRangeAt(0);
                            const placeholder = document.createTextNode('–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è');
                            range.insertNode(placeholder);
                            range.selectNodeContents(placeholder);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        
                        const command = button.dataset.cmd;
                        const value = button.dataset.value;
                        
                        if (command === 'formatBlock' && value) {
                            document.execCommand(command, false, value);
                        } else {
                            document.execCommand(command, false, null);
                        }
                        
                        editor.focus();
                    }
                }
            });
            
            document.addEventListener('focusin', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    if (editor.textContent === '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è') {
                        editor.textContent = '';
                        editor.style.color = '#333';
                    }
                }
            });
            
            document.addEventListener('focusout', (ev) => {
                if (ev.target.classList.contains('compact-editor')) {
                    const editor = ev.target;
                    if (editor.textContent.trim() === '') {
                        editor.textContent = '–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è';
                        editor.style.color = '#999';
                    }
                }
            });
            
            document.addEventListener('click', (ev) => {
                if (ev.target.matches('.compact-editor-toolbar button[data-cmd]')) {
                    ev.preventDefault();
                    const button = ev.target;
                    const editor = button.closest('.compact-editor-toolbar').nextElementSibling;
                    
                    if (editor && editor.classList.contains('compact-editor')) {
                        const cmd = button.dataset.cmd;
                        
                        editor.focus();
                        
                        if (['bold', 'italic', 'underline'].includes(cmd)) {
                            const selection = document.getSelection();
                            
                            document.execCommand(cmd, false, null);
                            
                            setTimeout(() => {
                                button.classList.toggle('active', document.queryCommandState(cmd));
                            }, 10);
                            return;
                        }
                        
                        const selection = document.getSelection();
                        if (selection.rangeCount === 0 || selection.isCollapsed) {
                            const range = selection.getRangeAt(0);
                            const placeholder = document.createTextNode('–¢–µ–∫—Å—Ç –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è');
                            range.insertNode(placeholder);
                            range.selectNodeContents(placeholder);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        
                        if (cmd === 'insertUnorderedList') {
                            const range = selection.getRangeAt(0);
                            const list = document.createElement('ul');
                            const li = document.createElement('li');
                            li.appendChild(range.extractContents());
                            list.appendChild(li);
                            range.insertNode(list);
                            
                            const newRange = document.createRange();
                            newRange.setStart(li, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                        } else if (cmd === 'insertOrderedList') {
                            const range = selection.getRangeAt(0);
                            const list = document.createElement('ol');
                            const li = document.createElement('li');
                            li.appendChild(range.extractContents());
                            list.appendChild(li);
                            range.insertNode(list);
                            
                            const newRange = document.createRange();
                            newRange.setStart(li, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                        } else if (cmd === 'removeList') {
                            const range = selection.getRangeAt(0);
                            const listItem = range.commonAncestorContainer.closest('li');
                            if (listItem) {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const textContent = listItem.textContent;
                                    const textNode = document.createTextNode(textContent);
                                    listItem.parentNode.replaceChild(textNode, listItem);
                                    
                                    if (list.children.length === 0) {
                                        list.remove();
                                    }
                                }
                            }
                        } else if (cmd === 'formatBlock') {
                            const range = selection.getRangeAt(0);
                            const block = document.createElement(button.dataset.value);
                            block.appendChild(range.extractContents());
                            range.insertNode(block);
                        }
                        
                        editor.focus();
                    }
                }
            });
            
            document.addEventListener('mouseup', updateButtonStates);
            document.addEventListener('keyup', updateButtonStates);
            document.addEventListener('input', updateButtonStates);
            document.addEventListener('selectionchange', updateButtonStates);
            
            document.addEventListener('keydown', (ev) => {
                if (ev.target.classList.contains('compact-editor') && ev.key === 'Enter') {
                    const selection = document.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const listItem = range.commonAncestorContainer.closest('li');
                        
                        if (listItem) {
                            ev.preventDefault();
                            
                            if (listItem.textContent.trim() === '') {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const textNode = document.createTextNode('\n');
                                    list.parentNode.insertBefore(textNode, list.nextSibling);
                                    list.remove();
                                    
                                    const newRange = document.createRange();
                                    newRange.setStartAfter(textNode);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            } else {
                                const list = listItem.closest('ol, ul');
                                if (list) {
                                    const newLi = document.createElement('li');
                                    newLi.textContent = '';
                                    list.appendChild(newLi);
                                    
                                    const newRange = document.createRange();
                                    newRange.setStart(newLi, 0);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            }
                        }
                    }
                }
            });
            
            function updateButtonStates() {
                const activeEditor = document.activeElement;
                if (!activeEditor || !activeEditor.classList.contains('compact-editor')) return;
                
                const toolbar = activeEditor.previousElementSibling;
                if (!toolbar || !toolbar.classList.contains('compact-editor-toolbar')) return;
                
                const boldBtn = toolbar.querySelector('[data-cmd="bold"]');
                const italicBtn = toolbar.querySelector('[data-cmd="italic"]');
                const underlineBtn = toolbar.querySelector('[data-cmd="underline"]');
                
                if (boldBtn) {
                    const isBold = document.queryCommandState('bold');
                    boldBtn.classList.toggle('active', isBold);
                }
                if (italicBtn) {
                    const isItalic = document.queryCommandState('italic');
                    italicBtn.classList.toggle('active', isItalic);
                }
                if (underlineBtn) {
                    const isUnderline = document.queryCommandState('underline');
                    underlineBtn.classList.toggle('active', isUnderline);
                }
            }
            
                 document.addEventListener('click', (ev) => {
                     if (ev.target.classList.contains('create-link-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const url = prompt('–í–≤–µ–¥–∏—Ç–µ URL —Å—Å—ã–ª–∫–∏:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.classList.contains('insert-image-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const imageInput = document.querySelector(`.image-file-input[data-post-id="${postId}"]`);
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.classList.contains('center-image-btn')) {
                         ev.preventDefault();
                         document.execCommand('justifyCenter', false, null);
                     }
                     
                     if (ev.target.classList.contains('create-nested-link-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const url = prompt('–í–≤–µ–¥–∏—Ç–µ URL —Å—Å—ã–ª–∫–∏:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.classList.contains('insert-nested-image-btn')) {
                         ev.preventDefault();
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const imageInput = document.querySelector(`.nested-image-file-input[data-post-id="${postId}"][data-reply-id="${replyId}"]`);
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.id === 'createLinkBtnFeed') {
                         ev.preventDefault();
                         const url = prompt('–í–≤–µ–¥–∏—Ç–µ URL —Å—Å—ã–ª–∫–∏:');
                         if (url) {
                             document.execCommand('createLink', false, url);
                         }
                     }
                     
                     if (ev.target.id === 'insertImageBtnFeed') {
                         ev.preventDefault();
                         const imageInput = document.getElementById('imageFileInputFeed');
                         if (imageInput) {
                             imageInput.click();
                         }
                     }
                     
                     if (ev.target.id === 'centerImageBtnFeed') {
                         ev.preventDefault();
                         document.execCommand('justifyCenter', false, null);
                     }
                 });
            
                 document.addEventListener('change', (ev) => {
                     if (ev.target.classList.contains('image-file-input')) {
                         const files = ev.target.files;
                         const postId = ev.target.dataset.postId;
                         const editor = document.getElementById(`replyInput_${postId}`);
                         
                         if (files && editor) {
                             Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     const fileName = await saveOriginalImageFile(file, postId);
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'reply-image');
                                         if (fileName && typeof fileName === 'string' && !fileName.startsWith('data:')) {
                                             img.setAttribute('data-filename', fileName);
                                             img.onclick = () => openImageModal(e.target.result, fileName);
                                         } else {
                                         img.onclick = () => openImageModal(e.target.result);
                                         }
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                     
                     if (ev.target.classList.contains('nested-image-file-input')) {
                         const files = ev.target.files;
                         const postId = ev.target.dataset.postId;
                         const replyId = ev.target.dataset.replyId;
                         const editor = document.getElementById(`nestedReplyInput_${postId}_${replyId}`);
                         
                         if (files && editor) {
                             Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     const fileName = await saveOriginalImageFile(file, postId, replyId);
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'nested-reply-image');
                                         if (fileName && typeof fileName === 'string' && !fileName.startsWith('data:')) {
                                             img.setAttribute('data-filename', fileName);
                                             img.onclick = () => openImageModal(e.target.result, fileName);
                                         } else {
                                         img.onclick = () => openImageModal(e.target.result);
                                         }
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                     
                     if (ev.target.id === 'imageFileInputFeed') {
                         const files = ev.target.files;
                         const editor = document.getElementById('feedInput');
                         
                         if (files && editor) {
                            Array.from(files).forEach(async file => {
                                 if (file.type.startsWith('image/')) {
                                     
                                     const reader = new FileReader();
                                     reader.onload = async function(e) {
                                         const img = await createLazyImage(e.target.result, 'comment-image');
                                        img.setAttribute('data-original-file', 'true');
                                         img.onclick = () => openImageModal(e.target.result);
                                         editor.appendChild(img);
                                     };
                                     reader.readAsDataURL(file);
                                 }
                             });
                         }
                     }
                 });
        }
        
        function setupEnterKeyHandling() {
            const feedInput = document.getElementById('feedInput');
            if (feedInput) {
                feedInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.execCommand('insertParagraph', false, null);
                    } else if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        const postFeedBtn = document.getElementById('postFeed');
                        if (postFeedBtn) {
                            postFeedBtn.click();
                        }
                    }
                });
            }
            
             document.addEventListener('keydown', (e) => {
                 if (e.target.classList.contains('compact-editor') && e.target.id && e.target.id.startsWith('replyInput_')) {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         document.execCommand('insertParagraph', false, null);
                     } else if (e.key === 'Enter' && e.ctrlKey) {
                         e.preventDefault();
                         const postId = e.target.id.replace('replyInput_', '');
                         postReply(postId);
                     }
                 }
                 
                 if (e.target.classList.contains('compact-editor') && e.target.id && e.target.id.startsWith('nestedReplyInput_')) {
                     if (e.key === 'Enter' && !e.shiftKey) {
                         e.preventDefault();
                         document.execCommand('insertParagraph', false, null);
                     } else if (e.key === 'Enter' && e.ctrlKey) {
                         e.preventDefault();
                         const idParts = e.target.id.replace('nestedReplyInput_', '').split('_');
                         if (idParts.length === 2) {
                             const postId = idParts[0];
                             const replyId = idParts[1];
                             postNestedReply(postId, replyId);
                         }
                     }
                 }
             });
        }

        function searchByTag(tag) {
            if (DEBUG_MODE) console.log('Searching by tag:', tag);
        }

        async function loadSubscriptionsFromFile() {
            try {
                const localSubscriptions = localStorage.getItem('8site_subscriptions');
                if (localSubscriptions && localSubscriptions !== 'null' && localSubscriptions !== 'undefined') {
                    const parsed = JSON.parse(localSubscriptions);
                    if (Array.isArray(parsed)) {
                        return parsed;
                    }
                }

                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json');
                        const file = await subscriptionsFile.getFile();
                        const text = await file.text();
                        const fileSubscriptions = JSON.parse(text);

                        if (Array.isArray(fileSubscriptions)) {
                            localStorage.setItem('8site_subscriptions', JSON.stringify(fileSubscriptions));
                            return fileSubscriptions;
                        }
                    } catch (fileError) {
                        if (DEBUG_MODE) console.log('Could not load from file:', fileError.message);
                    }
                }

                return [];
            } catch (e) {
                console.error('Error loading subscriptions:', e);
                return [];
            }
        }

        async function loadChannelAvatar(channelName) {
            const cacheKey = `avatar_${channelName}`;
            if (avatarCache.has(cacheKey)) {
                const cached = avatarCache.get(cacheKey);
                if (Date.now() - cached.timestamp < 300000) {
                    return cached.url;
                }
                if (cached.url && cached.url.startsWith('blob:')) {
                    URL.revokeObjectURL(cached.url);
                }
                avatarCache.delete(cacheKey);
            }

            try {
                const channelsDir = await videoDirectoryHandle.getDirectoryHandle('.channels', { create: true });
                const channelDir = await channelsDir.getDirectoryHandle(channelName, { create: true });

                const channelData = await readJSONFile(channelDir, 'channel.json', {});
                let avatarUrl = null;

                if (channelData.avatar) {
                    avatarUrl = await loadImageFile(channelDir, channelData.avatar);
                }

                avatarCache.set(cacheKey, {
                    url: avatarUrl,
                    timestamp: Date.now()
                });

                return avatarUrl;
            } catch (e) {
                avatarCache.set(cacheKey, {
                    url: null,
                    timestamp: Date.now()
                });
                return null;
            }
        }

        async function renderSubscribedChannelsList() {
            const container = document.getElementById('subscribedChannelsContainer');
            if (!container) return;

            try {
                const subscriptions = await loadSubscriptionsFromFile();

                if (!subscriptions || subscriptions.length === 0) {
                    container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">–ù–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫</div>';
                    return;
                }

                container.innerHTML = '';

                for (const channelName of subscriptions.slice(0, 10)) {
                    const link = document.createElement('a');
                    link.href = `youvi_ch_view.html?channel=${encodeURIComponent(channelName)}`;
                    link.className = 'sidebar-item';
                    link.style.display = 'flex';
                    link.style.alignItems = 'center';
                    link.style.gap = '8px';
                    link.style.cursor = 'pointer';
                    link.style.paddingTop = '6px';
                    link.style.paddingBottom = '6px';

                    const avatarDiv = document.createElement('div');
                    avatarDiv.style.width = '20px';
                    avatarDiv.style.height = '20px';
                    avatarDiv.style.borderRadius = '0';
                    avatarDiv.style.background = '#ff69b4';
                    avatarDiv.style.display = 'flex';
                    avatarDiv.style.alignItems = 'center';
                    avatarDiv.style.justifyContent = 'center';
                    avatarDiv.style.fontSize = '10px';
                    avatarDiv.style.color = 'white';
                    avatarDiv.style.fontWeight = 'bold';
                    avatarDiv.style.flexShrink = '0';
                    avatarDiv.textContent = channelName.charAt(0).toUpperCase();

                    const nameSpan = document.createElement('span');
                    nameSpan.style.flex = '1';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    nameSpan.textContent = channelName;

                    link.appendChild(avatarDiv);
                    link.appendChild(nameSpan);
                    container.appendChild(link);

                    loadChannelAvatar(channelName).then(avatarUrl => {
                        if (avatarUrl) {
                            avatarDiv.style.backgroundImage = `url(${avatarUrl})`;
                            avatarDiv.style.backgroundSize = 'cover';
                            avatarDiv.style.backgroundPosition = 'center';
                            avatarDiv.style.backgroundRepeat = 'no-repeat';
                            avatarDiv.textContent = '';
                        }
                    }).catch(() => {
                    });
                }

                if (subscriptions.length > 10) {
                    const moreLink = document.createElement('a');
                    moreLink.href = 'youvi_subscriptions.html';
                    moreLink.className = 'sidebar-item';
                    moreLink.style.fontSize = '11px';
                    moreLink.style.color = '#666';
                    moreLink.style.textAlign = 'center';
                    moreLink.textContent = `+${subscriptions.length - 10} –µ—â–µ`;
                    container.appendChild(moreLink);
                }
            } catch (e) {
                console.error('Error rendering subscriptions:', e);
                container.innerHTML = '<div style="color:#999;font-size:12px;padding:8px 0;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</div>';
            }
        }

        async function saveSubscriptionsToFile(subscriptions) {
            try {
                localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));

                if (videoDirectoryHandle) {
                    try {
                        const subscriptionsFile = await videoDirectoryHandle.getFileHandle('.subscriptions.json', { create: true });
                        const writable = await subscriptionsFile.createWritable();
                        await writable.write(JSON.stringify(subscriptions, null, 2));
                        await writable.close();
                    } catch (fileError) {
                        console.warn('Could not save to file, but localStorage saved:', fileError);
                    }
                } else {
                    if (DEBUG_MODE) console.log('No videoDirectoryHandle, using localStorage only');
                }

                window.dispatchEvent(new CustomEvent('subscriptionChanged'));
            } catch (e) {
                console.error('Error saving subscriptions:', e);
                try {
                    localStorage.setItem('8site_subscriptions', JSON.stringify(subscriptions));
                } catch (storageError) {
                    console.error('Critical: Could not save subscriptions anywhere!', storageError);
                }
            }
        }

        async function saveToDB(db, storeName, key, value) {
            try {
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
                
                if (db && db.objectStoreNames.contains(storeName)) {
                    const tx = db.transaction(storeName, 'readwrite');
                    const store = tx.objectStore(storeName);
                    await store.put(value, key);
                    if (DEBUG_MODE) console.log('Saved to IndexedDB successfully');
                } else {
                    console.warn(`IndexedDB store '${storeName}' does not exist, but data saved to localStorage`);
                }
            } catch (e) {
                console.error('Error saving to IndexedDB:', e);
                if (storeName === 'subscriptions' && key === 'subscriptions') {
                    await saveSubscriptionsToFile(value);
                }
            }
        }

        async function syncSubscriptions() {
            try {
                const db = await openDB();
                const fileSubscriptions = await loadSubscriptionsFromFile();
                const dbSubscriptions = await getFromDB(db, 'subscriptions');
                
                if (fileSubscriptions && !dbSubscriptions) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
                else if (dbSubscriptions && !fileSubscriptions) {
                    await saveSubscriptionsToFile(dbSubscriptions);
                }
                else if (fileSubscriptions && dbSubscriptions && 
                         JSON.stringify(fileSubscriptions) !== JSON.stringify(dbSubscriptions)) {
                    await saveToDB(db, 'subscriptions', 'subscriptions', fileSubscriptions);
                }
            } catch (e) {
                console.error('Error syncing subscriptions:', e);
            }
        }

        (function initLangSwitcher() {
            const langSwitcher = document.getElementById('langSwitcher');
            if (!langSwitcher) return;
            
            langSwitcher.value = i18n.getCurrentLanguage();
            
            langSwitcher.addEventListener('change', async (e) => {
                const newLang = e.target.value;
                await i18n.setLanguage(newLang);
                await loadChannelVideos();
                updateSubscribeButtonText();
                renderFeed();
            });
            
            i18n.subscribe(async (lang) => {
                langSwitcher.value = lang;
                await loadChannelVideos();
                updateSubscribeButtonText();
                renderFeed();
            });
        })();
        
        function updateSubscribeButtonText() {
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (subscribeBtn) {
                const isSubscribed = subscribeBtn.classList.contains('subscribed');
                subscribeBtn.textContent = i18n.t(isSubscribed ? 'channels.subscribed' : 'channels.subscribe');
            }
        }


    </script>
    
    <!-- Autocomplete Module -->
    <link rel="stylesheet" href="youvi/autocomplete/autocomplete.css">
    <script src="youvi/autocomplete-data-loader.js"></script>
    <script src="youvi/autocomplete/autocomplete-cache.js"></script>
    <script src="youvi/autocomplete/autocomplete.js"></script>
    <script src="youvi/autocomplete/autocomplete-integration.js"></script>
    
    <script src="youvi/themes/theme-toggle.js"></script>
</body>
</html>